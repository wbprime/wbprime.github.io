<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Spring: XML based configuration</title>
        <style>

    html body {
        font-family: Raleway, sans-serif;
        background-color: white;
    }

    :root {
        --accent: lightseagreen;
        --border-width:  0 ;
    }

</style>


<link rel="stylesheet" href="/css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 


    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

     <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/c&#43;&#43;.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/kotlin.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script> 

    <script>hljs.initHighlightingOnLoad();</script>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.32-DEV" />
        
    </head>

    <body>

        <nav class="navbar navbar-default navbar-fixed-top">

            <div class="container">

                <div class="navbar-header">

                    <a class="navbar-brand visible-xs" href="#">Spring: XML based configuration</a>

                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>

                </div>

                <div class="collapse navbar-collapse">

                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/posts/">Posts</a></li>
                            
                                <li><a href="/categories/">Categories</a></li>
                            
                                <li><a href="/tags/">Tags</a></li>
                            
                        </ul>
                    

                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="https://github.com/wbprime/"><i class="fa fa-github"></i></a></li>
                            
                        </ul>
                    

                </div>

            </div>

        </nav>


<main>

    <div class="item">

    
    
    

    
      

    <h4><a href="/posts/2015-06-02-spring-xml-based-configuration/">Spring: XML based configuration</a></h4>
    <h5>The Springframework XML-based metadata configuration guide.</h5>
     <kbd class="item-tag">Spring</kbd>  <kbd class="item-tag">java</kbd> 

</div>


    <br> <div class="text-justify">

<h1 id="overview">Overview</h1>

<h2 id="spring-configuration">Spring Configuration</h2>

<p>The Springframework supports 3 kinds of configuration methods, including XML-based configuration, annotation-based configuration and Java-based configuration.</p>

<ul>
<li>Xml-based configuration: traditionally supplied as a simple and intuitive XMl format metadata.</li>
<li>Annotation-based configuration: introduced by Spring 2.5.</li>
<li>Java-based configuration: introduced as the Spring JavaConfig project by Spring 3.0.</li>
</ul>

<p>XML-based configuration is widely used and best supported.</p>

<p>Typical xml configuration file:</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;aBean&quot; class=&quot;MyBean&quot;&gt;
    &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions go here --&gt;

&lt;/beans&gt;
</code></pre>

<h2 id="applicationcontext">ApplicationContext</h2>

<p>XML-based configuration provides bean metadata to Spring through a single or a set of XML file(s).</p>

<p>Generally Spring read configuration metadata via a <code>BeanFactory</code> interface.  Direct use of <code>BeanFactory</code> is not supported officially in dailly application development, though you can implement <code>BeanFactory</code> interface and provide your own class.  However Spring provide a more convinient interface <code>ApplicationContext</code> inheriting <code>BeanFactory</code>.</p>

<p>The <code>org.springframework.context.ApplicationContext</code> interface provides more features over <code>BeanFactory</code> interface such as: integration with Spring AOP interfaces, message resource handling for internationalization, event publication, web application support and so on.</p>

<p>Implementations of <code>ApplicationContext</code> interface differ in ways reading configuration metadata, among which are <code>ClassPathXmlApplicationContext</code> and <code>FileSystemXmlApplicationContext</code> that providing control of XML-based configuration metadata.</p>

<p><code>ClassPathXmlApplicationContext</code> is a standalone XML application context, taking the context definition files from the class path, interpreting plain paths as class path resource names that include the package path (e.g. &ldquo;mypackage/myresource.txt&rdquo;).  <code>ClassPathXmlApplicationContext</code> accepts one or more String and intepretes them as files in CLASSPATH, then loads configuration metadata from those files.  The leading slash in parameters, if exists, will be ignored.</p>

<p>Note: In case of multiple config locations, later bean definitions will override ones defined in earlier loaded files. This can be leveraged to deliberately override certain bean definitions via an extra XML file.</p>

<p><code>FileSystemXmlApplicationContext</code> is a Standalone XML application context, taking the context definition files from the file system or from URLs, interpreting plain paths as relative file system locations (e.g. &ldquo;mydir/myfile.txt&rdquo;). Useful for test harnesses as well as for standalone environments.  Plain path(s) will always treated relative to the current VM working directory whether it has or has not leading slash.  To avoid this, add a &ldquo;file:&rdquo; prefix to declare an absolute file path.</p>

<p>Note: In case of multiple config locations, later bean definitions will override ones defined in earlier loaded files. This can be leveraged to deliberately override certain bean definitions via an extra XML file.</p>

<p>Typical usage of <code>ApplicationContext</code> to load xml configuration metadata:</p>

<pre><code>// create and configure beans
ApplicationContext context =
    new ClassPathXmlApplicationContext(new String[] {&quot;mybean.xml&quot;, &quot;mybean2.xml&quot;});

// retrieve configured instance
MyBean my_bean = context.getBean(&quot;aBean&quot;, MyBean.class);

// use configured instance
boolean is_succeed = myBean.doSomething();
</code></pre>

<h1 id="xml-file-format">XML file format</h1>

<h2 id="beans"><code>beans</code></h2>

<p>An xml configuration file is, of cource, a regular xml file with a top-level <code>&lt;beans /&gt;</code> element and some springframework specific definitions.</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt;
</code></pre>

<h2 id="bean"><code>bean</code></h2>

<p>An xml file consists of at least one bean definition through <code>&lt;bean /&gt;</code> element inside a top-level <code>&lt;beans /&gt;</code> element.  A <code>&lt;bean /&gt;</code> element represents a bean object; a bean object can be anything whatever you want it to be: a service layer object, a data access object (DAO), a presentation object and so forth, only if it is a standard BEAN object.</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;aSerice&quot; class=&quot;me.wbprime.java.MySerice&quot; /&gt;
    &lt;bean id=&quot;aDao&quot; class=&quot;me.wbprime.java.MyDAO&quot; /&gt;
    &lt;bean id=&quot;aAction&quot; class=&quot;me.wbprime.java.MyAction&quot; /&gt;
    &lt;bean id=&quot;aSession&quot; class=&quot;me.wbprime.java.MySession&quot; /&gt;

    &lt;!-- more bean definitions go here --&gt;

&lt;/beans&gt;
</code></pre>

<h2 id="alias"><code>alias</code></h2>

<p>Spring supports alias for a bean which is valid in the <code>ApplicationContext</code> scope.</p>

<p>In file <code>a.xml</code>:</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;alias name=&quot;appService&quot; alias=&quot;b-serice&quot;/&gt;
&lt;/beans&gt;
</code></pre>

<p>In file <code>b.xml</code>:</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;alias name=&quot;appService&quot; alias=&quot;b-serice&quot;/&gt;
&lt;/beans&gt;
</code></pre>

<p>In file <code>app.xml</code>:</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;alias name=&quot;appService&quot; alias=&quot;app-serice&quot;/&gt;

    &lt;bean id=&quot;appSerice&quot; class=&quot;me.wbprime.java.MySerice&quot; /&gt;
    &lt;bean id=&quot;appDao&quot; class=&quot;me.wbprime.java.MyDAO&quot; /&gt;
    &lt;bean id=&quot;appAction&quot; class=&quot;me.wbprime.java.MyAction&quot; /&gt;
    &lt;bean id=&quot;appSession&quot; class=&quot;me.wbprime.java.MySession&quot; /&gt;
&lt;/beans&gt;
</code></pre>

<h2 id="import"><code>import</code></h2>

<p>It can be useful to have bean definitions span multiple XML files. Often each individual XML configuration file represents a logical layer or module in your architecture.</p>

<p>In file <code>app.xml</code>:</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;import resource=&quot;a.xml&quot;/&gt;
    &lt;import resource=&quot;resources/b.xml&quot;/&gt;
    &lt;import resource=&quot;/resources/c.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>

<p>Thus loading <code>app.xml</code> means loading configuration data from three files: <code>a.xml</code>, <code>b.xml</code> and <code>c.xml</code>.  As a implicit constraint, pathes of all files being imported must be given relative to the file doing the import.  So <code>a.xml</code> must be in the same directory or classpath location as <code>app.xml</code>, while <code>b.xml</code> and <code>c.xml</code> must be in <code>resources</code> sub-directory of the importing file.  Also a leading slash is ignored.</p>

<p>Note that the contents of the files being imported, including the top level <beans/> element, must be valid XML bean definitions according to the Spring Schema.</p>

<h1 id="bean-configuration">Bean Configuration</h1>

<p>Spring container manages one or more beans by <code>&lt;bean /&gt;</code> definitions.  A <code>&lt;bean /&gt;</code> element can provide the following metadata for a target <code>Bean</code> object:</p>

<ul>
<li>a full-qualified class name</li>
<li>object scope</li>
<li>object lifecycle behavior</li>
<li>properties being injected, including plain values and references, also called <em>collaborators</em> or <em>dependencies</em></li>
<li>other configuration</li>
</ul>

<h2 id="name">Name</h2>

<p>In Spring, every bean should have one or more identifiers.  These identifiers must be unique within the container that hosts the bean.</p>

<p>In a <code>&lt;bean /&gt;</code> element, an identifier can be specified by an <code>id</code> attribute.  Note that <code>id</code> uniqueness is enforced by the container.</p>

<pre><code>&lt;bean id=&quot;unique id&quot; ... /&gt;
</code></pre>

<p>Also you can use a <code>name</code> attribute.  Interestingly, you can specify more than one identifiers in <code>name</code> attribute, treated as aliases, separated by a comma (<code>,</code>), a semicolon (<code>;</code>) or white space(s).</p>

<pre><code>&lt;beans name=&quot;id1,id2,id3&quot; ... /&gt;
&lt;beans name=&quot;id1;id2;id3&quot; ... /&gt;
&lt;beans name=&quot;id1 id2 id3&quot; ... /&gt;
</code></pre>

<p>If neither <code>id</code> nor <code>name</code> sttribute are explicitly given, Spring would generate a unique identifier for that bean.  However this bean can not be referenced by other beans.</p>

<h2 id="class">Class</h2>

<p>The object type is specified by <code>class</code> attribute for a bean.  The <code>class</code> attribute can be used in 2 ways:</p>

<ul>
<li>when specifying a static factory method, <code>class</code> attribute must match the calss type containning the static factory method.</li>

<li><p>when not specified, <code>class</code> attribute must match the return type of <code>new</code> operator.</p>

<pre><code>&lt;bean class=&quot;ClassA&quot; ... /&gt;
</code></pre></li>
</ul>

<h2 id="instantiating-a-bean">Instantiating a Bean</h2>

<p>Spring provides 3 ways to instantiating a bean.</p>

<ol>
<li><p>using a constructor.</p>

<p>If you got a class with default constructor which has no parameters, you can simply specify the <code>class</code> attribute.</p>

<p>If you got a class without a default constructor, you can add a <code>class</code> attribute and then provide additional <code>constructor-arg</code> sub-elements.</p>

<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;me.wbprime.java.ExampleBean&quot; &gt;
    &lt;constructor-arg value=&quot;some value&quot; /&gt;
&lt;/bean&gt;
</code></pre>

<p>If your constructor have more than one parameters, for example, class <code>ExampleBean</code>:</p>

<pre><code>package me.wbprime.java

public class ExampleBean {
    private int _age;
    private String _name;

    public ExampleBean(int age, String name) {
        this._age = age;
        this._name = name;
    }
}
</code></pre>

<p>You can specify the parameter type:</p>

<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;me.wbprime.java.ExampleBean&quot; &gt;
    &lt;constructor-arg type=&quot;int&quot; value=&quot;26&quot; /&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;Elvis Wang&quot; /&gt;
&lt;/bean&gt;
</code></pre>

<p>Or you can specify the parameter position:</p>

<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;me.wbprime.java.ExampleBean&quot; &gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;26&quot; /&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;Elvis Wang&quot; /&gt;
&lt;/bean&gt;
</code></pre>

<p>Or you can use parameter names:</p>

<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;me.wbprime.java.ExampleBean&quot; &gt;
    &lt;constructor-arg name=&quot;age&quot; value=&quot;26&quot; /&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;Elvis Wang&quot; /&gt;
&lt;/bean&gt;
</code></pre>

<p>Keep in mind that to make this work out of the box your code must be compiled with the debug flag enabled so that Spring can look up the parameter name from the constructor.</p></li>

<li><p>using a static factory method</p>

<p>You may want to implement your <code>Factory method</code> pattern, by using a static factory method.  Of cource you can make your work together with Spring.  In such case, you need a <code>class</code> attribute which contains the static factory method as is discussed right before.  Then you need a new attribute named <code>factory-method</code>.</p>

<p>For example:</p>

<pre><code>package me.wbprime.java

public class ExampleFactory {
    private static ExampleBean aBean = new ExampleBean();
    private ExampleFactory() {}

    public static ExampleBean createBean() {
        return aBean;
    }
}
</code></pre>

<p>You can add a <code>&lt;bean /&gt;</code> like this:</p>

<pre><code>&lt;bean id=&quot;aaBean&quot;
    class=&quot;me.wbprime.java.ExampleFactory&quot;
    factory-method=&quot;createBean&quot;/&gt;
</code></pre>

<p>The definition does not specify the return type.</p></li>

<li><p>using a non-static factory method</p>

<p>Similar to a static factory method, instance factory method is also supported by Spring.  All you need to do is to leave the <code>class</code> attribute empty, set the <code>factory-bean</code> attribute to the bean reference containning the factory method, set the <code>factory-method</code> attribute to the name of the factory method.</p>

<p>Example:</p>

<pre><code>    package me.wbprime.java

    public class ExampleFactory {
        public ExampleFactory() {}

        public ExampleBean createBeanA() {
            return new BeanA;
        }

        public ExampleBean createBeanB() {
            return new BeanB;
        }
    }
</code></pre>

<p>Configuration in xml file:</p>

<pre><code>...

&lt;bean id=&quot;aFactory&quot; class=&quot;ExampleFactory&quot; /&gt;
&lt;bean id=&quot;aBean&quot; factory-bean=&quot;aFactory&quot; factory-method=&quot;createBeanA&quot; /&gt;
&lt;bean id=&quot;bBean&quot; factory-bean=&quot;aFactory&quot; factory-method=&quot;createBeanB&quot; /&gt;

...
</code></pre>

<p>Note that a <code>factory-bean</code> can have more than one factory method, and the return type is not specified.</p></li>
</ol>

<h2 id="scope">Scope</h2>

<p>You can control the bean scope by specifying an additional <code>scope</code> attribute to your <code>&lt;bean /&gt;</code> element.  The Spring Framework supports six scopes out of box, four of which are web-aware.</p>

<table>
<thead>
<tr>
<th>Scope</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>singleton</td>
<td>(Default) Scopes a single bean definition to a single object instance per Spring IoC container.</td>
</tr>

<tr>
<td>prototype</td>
<td>Scopes a single bean definition to any number of object instances.</td>
</tr>

<tr>
<td>request</td>
<td>Scopes a single bean definition to the lifecycle of a single HTTP request. Web-aware.</td>
</tr>

<tr>
<td>session</td>
<td>Scopes a single bean definition to the lifecycle of an HTTP Session. Web-aware.</td>
</tr>

<tr>
<td>global session</td>
<td>Scopes a single bean definition to the lifecycle of a global HTTP Session. Web-aware.</td>
</tr>

<tr>
<td>application</td>
<td>Scopes a single bean definition to the lifecycle of a ServletContext. Web-aware.</td>
</tr>
</tbody>
</table>

<h3 id="singleton"><code>singleton</code></h3>

<p>The Spring container creates only one instance of that object if you specify singleton scope to a bean by adding a <code>scope</code> attribute.</p>

<pre><code>&lt;bean id=&quot;demo1&quot; class=&quot;Demo1&quot; scope=&quot;singleton&quot; /&gt;
</code></pre>

<p>Note that this is the default value for <code>scope</code> attribute, if not specified explicitly.</p>

<h3 id="prototype"><code>prototype</code></h3>

<p>In contrast to singleton, prototype scope means that the Spring container creates an instance each time a request for that bean is made. As a rule, use the prototype scope for all stateful beans and the singleton scope for stateless beans.</p>

<pre><code>&lt;bean id=&quot;demo2&quot; class=&quot;Demo2&quot; scope=&quot;prototype&quot; /&gt;
</code></pre>

<p>If you use a singleton-scoped bean which referenced a prototype-scoped bean, all dependencies are injected at instantiation time and injected once.</p>

<h3 id="request-session-and-global-session"><code>request</code>, <code>session</code> and <code>global session</code></h3>

<p>The request, session, and global session scopes are web-aware (using <code>ApplicationContext</code> such as <code>XmlWebApplicationContext</code>). If you use these scopes with regular <code>ApplicationContext</code> such as the <code>ClassPathXmlApplicationContext</code>, you get an <code>IllegalStateException</code> complaining about an unknown bean scope.</p>

<h3 id="application"><code>application</code></h3>

<p>The application scope is similar to singleton for a entire web application, but differs in 2 ways: It is a singleton per <code>ServletContext</code>, not per Spring <code>ApplicationContext</code>, and it is actually exposed and therefore visible as a <code>ServletContext</code> attribute.</p>

<h3 id="custom-scope">Custom Scope</h3>

<p>To do.</p>

<h2 id="lazy-initializing">Lazy-initializing</h2>

<p>By default, the Spring container creates and configures all singleton dependencies when initializing a bean.  If this behavior is not desirable, you can set lazy initializing mode for a bean.</p>

<pre><code>&lt;bean id=&quot;lazyBean&quot; class=&quot;LazyBean&quot; lazy-init=&quot;true&quot; /&gt;
</code></pre>

<p>Now <code>lazyBean</code> bean will not be pre-instantiated when the Spring container is starting up.  However, if a lazy-initialized bean is referenced by another singleton bean that is not lazy-initialized, the lazy-initialized bean will still be created and initialized when starting up.</p>

<h2 id="lifecycle-callbacks">Lifecycle Callbacks</h2>

<h3 id="init-method"><code>init-method</code></h3>

<p>The Spring provides <code>init-method</code> attribute to allow a bean performing initialization work after instantiating and all necessary properties been set.</p>

<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;
</code></pre>

<p><code>init</code> is a name of method in <code>examples.ExampleBean</code> with a <code>public void init() {..}</code> like implementation.</p>

<h3 id="destroy-method"><code>destroy-method</code></h3>

<p>The Spring provides <code>destroy-method</code> attribute to allow a bean performing cleaning up work before destroyed.</p>

<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot; destroy-method=&quot;cleanup&quot;/&gt;
</code></pre>

<p><code>cleanup</code> is a name of method in <code>examples.ExampleBean</code> with a <code>public void cleanup() {...}</code> like implementation.</p>

<h3 id="default-init-destroy-method">Default <code>init/destroy</code> Method</h3>

<p>The fact is that init methods in your project keep the same name such as <code>init()</code>, <code>initialize()</code> and so on.  Adding it to each bean seems stupid.  To avoid this, you can set <code>default-init-method</code> attribute for <code>beans</code> element.</p>

<pre><code>&lt;beans default-init-method=&quot;init&quot;/&gt;
</code></pre>

<p>Similarly, you can set <code>default-destroy-method</code> attribute for destroy methods.</p>

<pre><code>&lt;beans default-destroy-method=&quot;destroy&quot;/&gt;
</code></pre>

<p>The <code>init-method</code>/<code>destroy-method</code> attribute for <code>bean</code> element will override the default values set to <code>beans</code>.</p>

<h2 id="dependency-injection">Dependency Injection</h2>

<p>Dependency injection (DI) is a process that bean objects define their dependencies, while the dependencies are handled by the container.  DI can be fulfilled by 1) interface, 2) constructor and 3) setters.</p>

<p>The Spring provides support for constructor-based DI and setter-based DI.</p>

<h3 id="constructor-based-di">Constructor-based DI</h3>

<p>This applies to constructor and factory method based bean instantiation process.</p>

<pre><code>&lt;bean id=&quot;bBean&quot; ... &gt;
    &lt;constructor-arg value=&quot;lalala&quot; /&gt; &lt;!-- auto detecting --&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;lalala&quot; /&gt; &lt;!-- using type detecting --&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;lalala&quot; /&gt; &lt;!-- using index detecting --&gt;
    &lt;constructor-arg name=&quot;info&quot; value=&quot;lalala&quot; /&gt; &lt;!-- using name detecting --&gt;
&lt;/bean&gt;
</code></pre>

<h3 id="setter-based-di">Setter-based DI</h3>

<p>Setter-based DI applies to beans being instantiated.</p>

<p>Setter-based DI can be done via <code>property</code> sub-element.</p>

<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;property name=&quot;prop1&quot;&gt;
        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;
    &lt;/property&gt;

    &lt;property name=&quot;prop2&quot; ref=&quot;yetAnotherBean&quot;/&gt;
    &lt;property name=&quot;prop3&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;
</code></pre>

<h3 id="di-values">DI Values</h3>

<p>The Spring supports constructor-based DI via <code>&lt;constructor-arg /&gt;</code> element and setter-based DI via <code>&lt;property /&gt;</code> element.  Values for these two elements can be specified inline (via attribute) or via sub element.  And values can be Java primitives (int, boolean and so on), String (java.lang.String) and reference to other beans.</p>

<ol>
<li><p>straight values</p>

<p>Java primitives and String values can be setted using <code>value</code> attribute or <code>value</code> element.</p>

<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;property name=&quot;prop1&quot; value=&quot;1&quot;/&gt;
    &lt;property name=&quot;prop2&quot;&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name=&quot;prop3&quot; value=&quot;My name&quot;/&gt;
    &lt;property name=&quot;prop4&quot;&gt;
        &lt;value&gt;My name&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>

<li><p>bean reference</p>

<p>References to other beans can be setted using <code>ref</code> attribute or <code>ref</code> element.  You can specify each of <code>bean</code>, <code>local</code> and <code>parent</code> attributes to <code>ref</code> element.</p>

<p>Specifying the target bean through the <code>bean</code> attribute of the <code>&lt;ref/&gt;</code> tag is the most general form, and allows creation of a reference to any bean in the same container or parent container, regardless of whether it is in the same XML file. The value of the <code>bean</code> attribute may be the same as the <code>id</code> attribute of the target bean, or as one of the values in the <code>name</code> attribute of the target bean.</p>

<p>Specifying the target bean through the <code>parent</code> attribute creates a reference to a bean that is in a parent container of the current container. The value of the <code>parent</code> attribute may be the same as either the <code>id</code> attribute of the target bean, or one of the values in the <code>name</code> attribute of the target bean, and the target bean must be in a parent container of the current one. You use this bean reference variant mainly when you have a hierarchy of containers and you want to wrap an existing bean in a parent container with a proxy that will have the same name as the parent bean.</p>

<p>The <code>local</code> attribute on the <code>ref</code> element is no longer supported in the 4.0 beans xsd since it does not provide value over a regular bean reference any more.</p>

<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;property name=&quot;prop1&quot; ref=&quot;aBean&quot;/&gt;
    &lt;property name=&quot;prop2&quot;&gt;
        &lt;ref bean=&quot;aBean&quot; /&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>

<li><p>inner beans</p>

<p>A <code>&lt;bean/&gt;</code> element inside the <code>&lt;property/&gt;</code> or <code>&lt;constructor-arg/&gt;</code> elements defines a inner bean. An inner bean definition does not require a defined id or name; the container ignores these values. It also ignores the scope flag. Inner beans are always anonymous and they are always created with the outer bean. It is not possible to inject inner beans into collaborating beans other than into the enclosing bean.</p>

<pre><code>&lt;bean id=&quot;outer&quot; class=&quot;...&quot;&gt;
    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;bean class=&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt;
            &lt;property name=&quot;name&quot; value=&quot;Fiona Apple&quot;/&gt;
            &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>

<li><p>collections</p>

<p>You can set values of Java collection types <code>List</code>, <code>Set</code>, <code>Map</code> and <code>Properties</code> via <code>&lt;list /&gt;</code>, <code>&lt;set /&gt;</code>, <code>&lt;map /&gt;</code> and <code>&lt;props /&gt;</code> elements respectively.</p>

<pre><code>&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;
    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;
    &lt;property name=&quot;adminEmails&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;
            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;
            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeList(java.util.List) call --&gt;
    &lt;property name=&quot;someList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;a list element followed by a reference&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
    &lt;property name=&quot;someMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;
            &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
    &lt;property name=&quot;someSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;just some string&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>

<li><p>null</p>

<p>Using <code>&lt;null /&gt;</code> element to set Java <code>null</code> value.</p>

<pre><code>&lt;bean class=&quot;ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot;&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
</ol>

<h3 id="p-namespace"><code>p-namespace</code></h3>

<p>The Spring p-namespace (property namespace ?) is introduced to describe straight values and bean references as a shorcut/replacement for <code>&lt;property /&gt;</code> element.</p>

<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
</code></pre>

<p>Typically</p>

<pre><code>&lt;bean name=&quot;pnamespaceBean&quot; class=&quot;com.example.ExampleBean&quot;
    p:email=&quot;foo@bar.com&quot;/&gt;
</code></pre>

<p>is the same as</p>

<pre><code>&lt;bean name=&quot;classicBean&quot; class=&quot;com.example.ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot; value=&quot;foo@bar.com&quot;/&gt;
&lt;/bean&gt;
</code></pre>

<p>And also</p>

<pre><code>&lt;bean name=&quot;pnamespaceStudent&quot;
    class=&quot;com.example.Student&quot;
    p:teacher-ref=&quot;jane&quot;/&gt;
</code></pre>

<p>is the same as</p>

<pre><code>&lt;bean name=&quot;classicStudent&quot; class=&quot;com.example.Student&quot;&gt;
    &lt;property name=&quot;teacher&quot; ref=&quot;jane&quot;/&gt;
&lt;/bean&gt;
</code></pre>

<p>Spring p-namespace provide inline attribute for <code>&lt;property /&gt;</code> element, using <code>p:PROPERRY</code> to set straight values and <code>p:PROPERTY-ref</code> to set bean references, of which <code>PROPERTY</code> is the actual property name.</p>

<h3 id="c-namespace"><code>c-namespace</code></h3>

<p>The Spring c-namespace (constructor namespace ?) is introduced to describe straight values and bean references as a shorcut/replacement for <code>&lt;constructor-arg /&gt;</code> element.</p>

<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
</code></pre>

<p>Typically</p>

<pre><code>&lt;bean name=&quot;cnamespaceBean&quot; class=&quot;com.example.ExampleBean&quot;
    c:email=&quot;foo@bar.com&quot;/&gt;
</code></pre>

<p>is the same as</p>

<pre><code>&lt;bean name=&quot;classicBean&quot; class=&quot;com.example.ExampleBean&quot;&gt;
    &lt;constraint-arg name=&quot;email&quot; value=&quot;foo@bar.com&quot;/&gt;
&lt;/bean&gt;
</code></pre>

<p>And also</p>

<pre><code>&lt;bean name=&quot;cnamespaceStudent&quot;
    class=&quot;com.example.Student&quot;
    c:teacher-ref=&quot;jane&quot;/&gt;
</code></pre>

<p>is the same as</p>

<pre><code>&lt;bean name=&quot;classicStudent&quot; class=&quot;com.example.Student&quot;&gt;
    &lt;constructor-arg name=&quot;teacher&quot; ref=&quot;jane&quot;/&gt;
&lt;/bean&gt;
</code></pre>

<p>Of course the name of constructor parameters should be available (compiled with debug information).  If this is not the case, you can use index position based version.</p>

<pre><code>&lt;bean id=&quot;foo&quot; class=&quot;Foo&quot; c:_0=&quot;foo@bar.com&quot; c:_1-ref=&quot;jane&quot;/&gt;
</code></pre>

<h3 id="compound-property">Compound Property</h3>

<p>You can use compound property to simplify property injection.</p>

<pre><code>&lt;bean id=&quot;foo&quot; class=&quot;foo.Bar&quot;&gt;
    &lt;property name=&quot;fred.bob.sammy&quot; value=&quot;123&quot; /&gt;
&lt;/bean&gt;
</code></pre>

<p>will call <code>foo.getFred().getBob().setSammy(&quot;123&quot;)</code> equally.  In order for this to work, the fred property of foo, and the bob property of fred must not be null after the bean is constructed, or a NullPointerException is thrown.</p>

<h2 id="autowiring">Autowiring</h2>

<p>Autowiring is such a feature that the container manages the relationship between a bean and its implicit collaborating beans and resolves the dependencies automatically.  Within the Spring autowiring decrease your work significantly specifying properties/constructor-args and helps when your project evolves and bean dependencies changes slightly.  To be brief, autowiring moves additional work to the Spring container to detect bean dependencies which needs explicit to be done by you programmers.</p>

<p>The Spring supports 4 kinds of autowiring modes:</p>

<ul>
<li><code>no</code> autowiring.  (Default) No autowiring means all dependencies must be specified explicitely.</li>
<li><code>byName</code> autowiring.  Autowiring is done by property name.</li>
<li><code>byType</code> autowiring.  Autowiring is done by property type.  Note that if more than one beans for target type exists, a fatal exception is thrown.</li>
<li><code>constructor</code> autowiring.  Autowiring is done by constructor-arg type, similar to <code>byType</code> for property.</li>
</ul>

<pre><code>&lt;bean ... autowire=&quot;byName&quot; /&gt;
</code></pre>

<p>If you want to exclude a bean from the autowiring of another bean, you can:</p>

<ul>
<li>set <code>default-autowire-candidates</code> attribute for top level <code>&lt;beans /&gt;</code> element.  For example, <code>&lt;beans ... default-autowire-candidates=&quot;*DAO&quot; /&gt;</code> will exclude all beans in this element not matching <code>&quot;*DAO</code> pattern for autowiring.</li>
<li>set <code>autowire-candidates</code> attribute for target <code>&lt;bean /&gt;</code> element to <code>false</code>.</li>
</ul>

<p>The latter takes precedence.</p>

<p>Typically it is best practice to keep consistent across your project when using autowiring.</p>

<h1 id="summary">Summary</h1>

<p>XML based configuration is the traditional method to fulfill ths Spring IoC/DI and other features, and it is the best supported and documented.</p>

<p>Ths Spring also supports Annotation based configuration and Java based configuration.  Annotation based configuration is more convenient and simply in syntax; Java based configuration is implemented using Java classes.</p>
</div>

    
    

    

    

</main>

        <footer>

            <p class="copyright text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a></p>

        </footer>

    </body>

</html>

