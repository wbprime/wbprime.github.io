<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Learning Java Concurrency - Semaphore</title>
        <style>

    html body {
        font-family: Raleway, sans-serif;
        background-color: white;
    }

    :root {
        --accent: lightseagreen;
        --border-width:  0 ;
    }

</style>


<link rel="stylesheet" href="/css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 


    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

     <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/c&#43;&#43;.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/kotlin.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script> 

    <script>hljs.initHighlightingOnLoad();</script>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.26" />
        
    </head>

    <body>

        <nav class="navbar navbar-default navbar-fixed-top">

            <div class="container">

                <div class="navbar-header">

                    <a class="navbar-brand visible-xs" href="#">Learning Java Concurrency - Semaphore</a>

                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>

                </div>

                <div class="collapse navbar-collapse">

                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/posts/">Posts</a></li>
                            
                                <li><a href="/categories/">Categories</a></li>
                            
                                <li><a href="/tags/">Tags</a></li>
                            
                        </ul>
                    

                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="mailto:mail@wbprime.me"><i class="fa fa-envelope-o"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://github.com/wbprime/"><i class="fa fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.stackoverflow.com/wbprime/"><i class="fa fa-stack-overflow"></i></a></li>
                            
                        </ul>
                    

                </div>

            </div>

        </nav>


<main>

    <div class="item">

    
    
    

    
    

    <h4><a href="/posts/2016-03-30-java-concurrent-semaphore/">Learning Java Concurrency - Semaphore</a></h4>
    <h5>March 30, 2016</h5>
     <kbd class="item-tag">java</kbd>  <kbd class="item-tag">concurrency</kbd> 

</div>


    <br> <div class="text-justify">

<p>Semaphore，信号量。信号量可以理解为令牌掌牌使，负责令牌的发放；当线程需要执行任务时，先到信号量处领取令牌，领取到了令牌再去执行任务；如果令牌被领光了，就需要一直等待；如果任务执行完了，需要到信号量处交还令牌。很简单的逻辑！</p>

<p>还是吃个栗子，地铁里面公厕，一般也就3、4个坑位。人有三急，当你有需要的时候，还必须得靠这个解决。这个时候，如果公厕里没有人，或者还剩最后一个坑位，那就啥也别说了，进去吧。但是，如果，满了。就，只有，等，了。不着急可以等一等；实在憋不住的，可以催一催。但是不管急不急，都要等里面随便一个里面出来人了才能进去。这个就是典型的信号量。</p>

<p>还有就是非常典型的生产者/消费者问题了。有一个仓库，里面的仓位是有限的。生产者只有当仓库里面有空仓位时才能进行生产；如果没有空仓位，则需要等待；如果生产了一次，则仓库少了一个空仓位。消费者只有当仓库里有非空仓位时才能消费；如果没有非空仓位，就需要等待；如果消费了一次，仓库里多了一个空仓位。</p>

<!-- More -->

<h1 id="semaphore的简单实用">Semaphore的简单实用</h1>

<p>首先，初始化信号量控制的令牌的个数。</p>

<p>然后，消费者去申请令牌，可能申请到，也可能被阻塞。</p>

<p>然后，生产者去释放令牌。</p>

<p>然后，交互就可以开始了。</p>

<p>注意，信号量只是保证资源的可用性，当资源不可用时，阻塞线程；然而线程使用资源的过程不保证是原子的，需要另外加锁控制。</p>

<p>举个例子，你成功申请到了令牌开始执行任务，但是这个任务可能失败，可能成功，还有可能部分成功部分失败。</p>

<h1 id="semaphore的api">Semaphore的API</h1>

<ol>
<li>Semaphore(int permits) &amp; Semaphore(int permits, boolean fair)
构造一个信号量实例（可以是公平的或者非公平的），默认是非公平的。</li>
<li>void acquire() throws InterruptedException
申请一枚令牌；如果没有可用令牌，则阻塞。</li>
<li>void acquireUninterruptibly()
同上；当调用线程被中断时，不抛出异常。</li>
<li>void acquire(int permits) throws InterruptedException
申请多枚令牌；如果没有可用令牌，则阻塞。</li>
<li>void acquireUninterruptibly(int permits)
同上；当调用线程被中断时，不抛出异常。</li>
<li>boolean tryAcquire()
申请一枚令牌；立即返回，申请成功返回true，反之false。</li>
<li>boolean tryAcquire(int permits)
申请多枚令牌；立即返回，申请成功返回true，反之false。</li>
<li>boolean tryAcquire(long timeout, TimeUnit unit) throws TimeoutException
申请一枚令牌，不允许超时；立即返回，申请成功返回true，反之false。</li>
<li>boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws TimeoutException
申请多枚令牌，不允许超时；立即返回，申请成功返回true，反之false。</li>
<li>void release()
归还一枚令牌。</li>
<li>void release(int permits)
归还多枚令牌。</li>
<li>int availablePermits()
当前可用的令牌数。</li>
<li>int drainPermits()
申请获取所有可用令牌，返回申请到的令牌数。</li>
<li>boolean isFair()
是否公平。</li>
</ol>

<p>Semaphore内部有一个静态类Sync来实现公平策略，NonFairSync来实现非公平策略。</p>

<pre><code class="language-java">static class Sync extends AbstractQueuedSynchronizer

...

static final class NonfairSync extends Sync
</code></pre>

<p>公平与非公平的区别在于申请令牌的调用中是否可以插队。公平的策略是将所有线程放入一个FIFO队列，按照出队顺序分配令牌；非公平策略是如果申请的时候有新的释放出来的令牌，直接获取，不需要排队。由于线程阻塞然后被唤醒的开销可能会比较大，所以非公平可能会比公平策略有潜在的更高的性能。</p>

<p>公平与非公平策略只影响申请令牌时的操作；如果已经被放入了等待队列，则公平与非公平没有区别。</p>

<h1 id="示例代码">示例代码</h1>

<pre><code class="language-java">package me.wbprime.showcase.concurrent;


import com.google.common.collect.Lists;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * Class: SemaphoreCase
 * Date: 2016/03/30 18:15
 *
 * @author Elvis Wang [mail@wbprime.me]
 */
public final class SemaphoreCase {
    private static class Item {
        private String name;

        public Item(int idx) {
            name = String.format(&quot;%s %d&quot;, Thread.currentThread().getName(), idx);
        }

        public final String getName() {
            return name;
        }

        @Override
        public String toString() {
            return getName();
        }
    }

    private static class WareHouse {
        private final List&lt;Item&gt; items;
        private final Semaphore notFull;
        private final Semaphore notEmpty;
        private final Semaphore mutex;

        public WareHouse(final int cnt) {
            items = Lists.newArrayListWithExpectedSize(cnt);
            this.notFull = new Semaphore(cnt);
            this.notEmpty = new Semaphore(0);
            this.mutex = new Semaphore(1);
        }

        public String itemsString() {
            return items.toString();
        }

        public void put(final Item obj) throws InterruptedException {
            if (null != obj) {

                /*
                 * 获取非满的保证
                 *
                 * 如果是满的，则挂起
                 */
                notFull.acquire();

                /*
                 * 获取容器操作的独占保证
                 */
                mutex.acquire();

                items.add(obj);

                System.out.println(&quot;Put &quot; + obj.getName());
                System.out.println(items.toString());

                /*
                 * 结束容器操作
                 */
                mutex.release();

                /*
                 * 保证非空，允许take操作（唤醒挂起线程）
                 */
                notEmpty.release();
            }
        }

        public Item take() throws InterruptedException {

            /*
             * 获取非空的保证
             *
             * 如果是空的，则挂起
             */
            notEmpty.acquire();

            /*
             * 获取容器操作的独占保证
             */
            mutex.acquire();

            final int lastIdx = items.size() - 1;
            final Item item = items.get(lastIdx);
            items.remove(lastIdx);

            System.out.println(&quot;Take &quot; + item.getName());
            System.out.println(items.toString());

            /*
             * 结束容器操作
             */
            mutex.release();

            /*
             * 保证非满，允许put操作（唤醒挂起进程）
             */
            notFull.release();

            return item;
        }
    }

    private static class Producer implements Runnable {
        private WareHouse wareHouse;

        private int i = 0;

        public Producer(final WareHouse s) {
            wareHouse = s;
        }

        public void run() {
            try {
                while (true) {
                    final Item itm = new Item(i++);

                    wareHouse.put(itm);

                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {

            }
        }
    }

    private static class Consumer implements Runnable {
        private WareHouse wareHouse;

        public Consumer(final WareHouse s) {
            wareHouse = s;
        }

        public void run() {
            try {
                while (true) {
                    wareHouse.take();

                    Thread.sleep(1500);
                }
            } catch (InterruptedException e) {

            }
        }
    }

    public static void main(final String[] args) {
        final WareHouse wareHouse = new WareHouse(5);

        final ExecutorService executor = Executors.newCachedThreadPool();

        final int countOfConsumers = 3;
        final int countOfProducers = 5;

        for (int i = 0; i &lt; countOfProducers; i++) {
            executor.execute(new Producer(wareHouse));
        }

        for (int i = 0; i &lt; countOfConsumers; i++) {
            executor.execute(new Consumer(wareHouse));
        }

//        try {
//            executor.awaitTermination(1, TimeUnit.MINUTES);
//        } catch (InterruptedException e) {
//            executor.shutdown();
//        }
    }
}
</code></pre>

<h1 id="示例代码说明">示例代码说明</h1>

<ol>
<li><p>典型的生产者/消费者模型，WareHouse类表征仓库，Consumer类表征消费者，Producer类表征生产者。</p></li>

<li><p>notFull信号量负责发放生产令牌，由生产者acquire，消费者release。</p></li>

<li><p>notEmpty信号量负责发放消费令牌，由消费者acquire，生产者release。</p></li>

<li><p>mutex信号量表示生产和消费的互斥，用来保证列表元素读取的线程安全性，可以用ReentrantLock代替。</p></li>
</ol>

<h1 id="代码下载">代码下载</h1>

<ol>
<li><a href="SemaphoreCase.java">SemaphoreCase.java</a></li>
</ol>
</div>

    
    

    

    

</main>

        <footer>

            <p class="copyright text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a></p>

        </footer>

    </body>

</html>

