<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Spring MVC Integration Testing - Controllers</title>
        <style>

    html body {
        font-family: Raleway, sans-serif;
        background-color: white;
    }

    :root {
        --accent: lightseagreen;
        --border-width:  0 ;
    }

</style>


<link rel="stylesheet" href="/css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 


    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

     <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/c&#43;&#43;.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/kotlin.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script> 

    <script>hljs.initHighlightingOnLoad();</script>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.26" />
        
    </head>

    <body>

        <nav class="navbar navbar-default navbar-fixed-top">

            <div class="container">

                <div class="navbar-header">

                    <a class="navbar-brand visible-xs" href="#">Spring MVC Integration Testing - Controllers</a>

                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>

                </div>

                <div class="collapse navbar-collapse">

                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/posts/">Posts</a></li>
                            
                                <li><a href="/categories/">Categories</a></li>
                            
                                <li><a href="/tags/">Tags</a></li>
                            
                        </ul>
                    

                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="mailto:mail@wbprime.me"><i class="fa fa-envelope-o"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://github.com/wbprime/"><i class="fa fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.stackoverflow.com/wbprime/"><i class="fa fa-stack-overflow"></i></a></li>
                            
                        </ul>
                    

                </div>

            </div>

        </nav>


<main>

    <div class="item">

    
    
    

    
    

    <h4><a href="/posts/2016-04-09-spring-mvc-testing-integration-testing-controllers/">Spring MVC Integration Testing - Controllers</a></h4>
    <h5>April 9, 2016</h5>
     <kbd class="item-tag">Spring MVC</kbd>  <kbd class="item-tag">Test</kbd>  <kbd class="item-tag">Java</kbd> 

</div>


    <br> <div class="text-justify">

<p>本文是<a href="/2016/04/09/spring-mvc-testing-content/">Spring MVC Testing</a> 集成测试系列的第2篇，原文链接：<a href="http://www.petrikainulainen.net/programming/spring-framework/integration-testing-of-spring-mvc-applications-controllers/">Integration Testing of Spring MVC Applications: Controllers</a>。</p>

<p>本文主要介绍如何为“标准”Controller编写集成测试。在这里“标准”的含义延续前一个序列 <a href="/2016/04/09/spring-mvc-testing-content/">Spring MVC Testing</a> 中的含义，表示不使用Ajax的请求或者处理Form结果的请求。</p>

<p>同样地，本文还是一步一步地为我们的TodoApplication编写集成测试。该程序提供Todo项的增删改查（CRUD）接口，本文主要关注其中的3个接口：获取Todo项列表；查看单个Todo项的详情；以及删除某个Todo项。</p>

<!-- More -->

<h1 id="通过maven获取依赖">通过Maven获取依赖</h1>

<p>本文用到的依赖如下：</p>

<ul>
<li>Hamcrest 1.3</li>
<li>JUnit 4.10</li>
<li>Spring Test 3.2.3.RELEASE</li>
<li>Spring Test DBUnit 1.0.0</li>
<li>DBUnit 2.4.8</li>
</ul>

<p>生成的pom.xml文件的片段如下：</p>

<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
    &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt;
    &lt;version&gt;1.3&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.10&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;
            &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;3.2.3.RELEASE&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.springtestdbunit&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test-dbunit&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.dbunit&lt;/groupId&gt;
    &lt;artifactId&gt;dbunit&lt;/artifactId&gt;
    &lt;version&gt;2.4.8&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;            
&lt;/dependency&gt;
</code></pre>

<h1 id="spring-test-dbunit-快速入门">Spring Test DBUnit 快速入门</h1>

<p>我们在集成测试中使用了 <a href="http://springtestdbunit.github.com/spring-test-dbunit/">Spring Test DBUnit</a> 库和 <a href="http://www.dbunit.org/">DBUnit</a> 库。我们快速地熟悉一下如何使用它们。</p>

<h2 id="配置">配置</h2>

<h3 id="创建spring上下文配置">创建Spring上下文配置</h3>

<p>首先需要创建Spring上下文配置，让Spring来管理依赖。</p>

<ol>
<li>创建一个Java类，并用<code>@Configuration</code>注解</li>
<li>新建<code>application.properties</code>属性文件，并使用<code>@PropertySource</code>注解导入类配置上下文中</li>
<li>添加一个<code>Environment</code>类型的成员用于获取属性文件中的配置信息</li>
<li>使用<code>@Bean</code>注解创建一个<code>DataSource</code>类型的Bean</li>
</ol>

<p>最终的结果如下：</p>

<pre><code class="language-java">import com.jolbox.bonecp.BoneCPDataSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;
 
import javax.annotation.Resource;
import javax.sql.DataSource;
 
@Configuration
@PropertySource(&quot;classpath:application.properties&quot;)
public class ExampleApplicationContext {
 
    @Resource
    private Environment environment;
 
    @Bean
    public DataSource dataSource() {
        BoneCPDataSource dataSource = new BoneCPDataSource();
 
        dataSource.setDriverClass(environment.getRequiredProperty(&quot;db.driver&quot;));
        dataSource.setJdbcUrl(environment.getRequiredProperty(&quot;db.url&quot;));
        dataSource.setUsername(environment.getRequiredProperty(&quot;db.username&quot;));
        dataSource.setPassword(environment.getRequiredProperty(&quot;db.password&quot;));
 
        return dataSource;
    }
}
</code></pre>

<h3 id="配置测试用例类">配置测试用例类</h3>

<p>我们可以通过如下步骤在测试用例类中使用DBUnit：</p>

<ol>
<li>对测试用例类使用<code>@RunWith(SpringJUnit4ClassRunner.class)</code>注解</li>
<li>对测试用例类使用<code>@ContextConfiguratiON</code>注解并引入上一步创建的<code>ExampleApplicationContext</code>类作为Spring配置上下文</li>
<li>对测试用例类使用<code>@TestExecutionListeners</code>注解并使用<code>DbUnitTestExecutionListener</code>来处理DBUnit的相关注解</li>
</ol>

<p>最终代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
 
import javax.annotation.Resource;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = {ExampleApplicationContext.class})
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class })
public class Test {
    //Add test methods here
}
</code></pre>

<h2 id="使用">使用</h2>

<p>使用DBUnit，我们可以用注解来初始化数据库、初始化数据表以及在测试结束后验证数据库的状态。详细使用请参见 <a href="http://springtestdbunit.github.com/spring-test-dbunit/">Spring Test DBUnit</a>。本文将会使用如下两个注解：</p>

<ul>
<li>@DatabaseSetup 用于在测试开始之前将数据库初始化到指定状态</li>
<li>@ExpectedDatabase 用于在测试结束之后验证数据库状态</li>
</ul>

<h1 id="spring-mvc-test-快速入门">Spring MVC Test 快速入门</h1>

<h2 id="创建并执行请求">创建并执行请求</h2>

<p><code>MockMvc</code>类的<code>perform(RequestBuilder requestBuilder)</code>方法可以用来模拟执行HTTP请求。<code>MockMvcRequestBuilders</code>类提供了几个静态方法用来模拟HTTP请求实体，具体是：</p>

<ul>
<li><code>get()</code> 用于创建一个模拟的HTTP GET请求实体</li>
<li><code>delete()</code> 用于创建一个模拟的HTTP DELETE请求实体</li>
<li><code>fileUpload()</code> 用于创建一个模拟的HTTP文件上传请求实体（multipart request）</li>
<li><code>post()</code> 用于创建一个模拟的HTTP POST请求实体</li>
<li><code>put()</code> 用于创建一个模拟的HTTP PUT请求实体</li>
</ul>

<p>详情可以查看<code>MockHttpServletRequestBuilder</code>类的说明文档。</p>

<h2 id="验证请求返回结果">验证请求返回结果</h2>

<p><code>ResultActions</code>类提供了3个方法来提供对模拟的HTTP请求返回结果的处理：</p>

<ul>
<li><code>void andExpect(ResultMatcher matcher)</code> 用于对返回结果作断言验证</li>
<li><code>void andDo(ResultHandler handler)</code> 用于对返回结果进行二次操作</li>
<li><code>MvcResult andReturn()</code> 用于直接返回结果</li>
</ul>

<p>为了提高代码效率，<code>MockMvcResultMatchers</code>类和<code>MockMvcResultHandlers</code>类提供了许多静态方法：</p>

<ul>
<li><code>MockMvcResultMatchers</code>类提供了很多包装好的<code>Matcher</code>实例</li>
<li><code>MockMvcResultHandlers</code>类目前只提供了<code>print()</code>方法返回一个<code>Handler</code>实例可以输出返回结果到控制台</li>
</ul>

<h1 id="示例web应用结构">示例web应用结构</h1>

<h2 id="domain-层">Domain 层</h2>

<p>Domain层提供了<code>Todo</code>实体类，表示一个一个的Todo项。</p>

<p><code>Todo</code>类代码如下：</p>

<pre><code class="language-java">import org.hibernate.annotations.Type;
import org.joda.time.DateTime;
import javax.persistence.*;
 
@Entity
@Table(name=&quot;todos&quot;)
public class Todo {
 
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
 
    @Column(name = &quot;creation_time&quot;, nullable = false)
    @Type(type=&quot;org.jadira.usertype.dateandtime.joda.PersistentDateTime&quot;)
    private DateTime creationTime;
 
    @Column(name = &quot;description&quot;, nullable = true, length = 500)
    private String description;
 
    @Column(name = &quot;modification_time&quot;, nullable = false)
    @Type(type=&quot;org.jadira.usertype.dateandtime.joda.PersistentDateTime&quot;)
    private DateTime modificationTime;
 
    @Column(name = &quot;title&quot;, nullable = false, length = 100)
    private String title;
 
    @Version
    private long version;
 
    public Todo() {
 
    }
 
    //Getters and other methods
}
</code></pre>

<h2 id="service-层">Service 层</h2>

<p>Service层提供了<code>TodoService</code>接口，用来连接Controller层和Domain层的通信。该接口提供了3个方法：</p>

<ul>
<li><code>Todo deleteById(Long id)</code> 删除指定id的Todo项；如果不存在该Todo项，则抛出<code>TodoNotFoundException</code>异常</li>
<li><code>List&lt;Todo&gt; findAll()</code> 返回所有Todo项的列表；如果没有Todo项，则返回空列表</li>
<li><code>Todo findById(Long id)</code> 返回指定id的Todo项；如果不存在该Todo项，则抛出<code>TodoNotFoundException</code>异常</li>
</ul>

<p><code>TodoService</code>接口代码如下：</p>

<pre><code class="language-java">public interface TodoService {
 
    public Todo deleteById(Long id) throws TodoNotFoundException;
 
    public List&lt;Todo&gt; findAll();
 
    public Todo findById(Long id) throws TodoNotFoundException;
}
</code></pre>

<h2 id="controller-层">Controller 层</h2>

<p>Controller层提供了<code>TodoController</code>类，用于创建视图、处理请求。</p>

<p><code>TodoController</code>类代码如下：</p>

<pre><code class="language-java">import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;
 
import javax.annotation.Resource;
import javax.validation.Valid;
 
@Controller
public class TodoController {
 
    @Resource
    private TodoService service;
 
    @Resource
    private MessageSource messageSource;
 
    @RequestMapping(value = &quot;/todo/delete/{id}&quot;, method = RequestMethod.GET)
    public String deleteById(@PathVariable(&quot;id&quot;) Long id, RedirectAttributes attributes) throws TodoNotFoundException {
        Todo deleted = service.deleteById(id);
 
        addFeedbackMessage(attributes, &quot;feedback.message.todo.deleted&quot;, deleted.getTitle());
 
        return createRedirectViewPath(&quot;/&quot;);
    }
 
    @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)
    public String findAll(Model model) {
        List&lt;Todo&gt; models = service.findAll();
 
        model.addAttribute(&quot;todos&quot;, models);
 
        return &quot;todo/list&quot;;
    }
 
    @RequestMapping(value = &quot;/todo/{id}&quot;, method = RequestMethod.GET)
    public String findById(@PathVariable(&quot;id&quot;) Long id, Model model) throws TodoNotFoundException {
        Todo found = service.findById(id);
 
        model.addAttribute(&quot;todo&quot;, found);
 
        return &quot;todo/view&quot;;
    }
 
    private void addFeedbackMessage(RedirectAttributes attributes, String messageCode, Object... messageParameters) {
        String localizedFeedbackMessage = getMessage(messageCode, messageParameters);
        attributes.addFlashAttribute(&quot;feedbackMessage&quot;, localizedFeedbackMessage);
    }
 
    private String getMessage(String messageCode, Object... messageParameters) {
        Locale current = LocaleContextHolder.getLocale();
        return messageSource.getMessage(messageCode, messageParameters, current);
    }
 
    private String createRedirectViewPath(String requestMapping) {
        StringBuilder redirectViewPath = new StringBuilder();
        redirectViewPath.append(&quot;redirect:&quot;);
        redirectViewPath.append(requestMapping);
        return redirectViewPath.toString();
    }
}
</code></pre>

<h1 id="测试用例">测试用例</h1>

<h2 id="创建测试用例类框架">创建测试用例类框架</h2>

<p>要搭建起测试框架，需要以下步骤：</p>

<ol>
<li>搭建Spring MVC Test环境</li>
<li>搭建DbUnit环境</li>
<li>配置DBUnit，设定测试开始和结束时的状态</li>
</ol>

<p>没有添加任何测试方法前的框架代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import org.junit.Before;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
import org.springframework.test.web.server.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;
 
import javax.annotation.Resource;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class })
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    @Resource
    private WebApplicationContext webApplicationContext;
 
    private MockMvc mockMvc;
 
    @Before
    public void setUp() {
        mockMvc = MockMvcBuilders.webApplicationContextSetup(webApplicationContext)
                .build();
    }
     
    //Add tests here
}
</code></pre>

<p>注意代码中的<code>@DatabaseSetup(&quot;toDoData.xml&quot;)</code>注解，该注解的作用在于使用<code>todoData.xml</code>文件中的数据去初始化数据库表，该注解由<code>DbUnitTestExecutionListener</code>进行解析。</p>

<p><code>todoData.xml</code>文件内容如下：</p>

<pre><code class="language-xml">&lt;dataset&gt;
    &lt;todos id=&quot;1&quot; creation_time=&quot;2012-10-21 11:13:28&quot; description=&quot;Lorem ipsum&quot; modification_time=&quot;2012-10-21 11:13:28&quot; title=&quot;Foo&quot; version=&quot;0&quot;/&gt;
    &lt;todos id=&quot;2&quot; creation_time=&quot;2012-10-21 11:13:28&quot; description=&quot;Lorem ipsum&quot; modification_time=&quot;2012-10-21 11:13:28&quot; title=&quot;Bar&quot; version=&quot;0&quot;/&gt;
&lt;/dataset&gt;
</code></pre>

<h2 id="编写集成测试用例">编写集成测试用例</h2>

<h3 id="获取todo项列表接口的测试用例">获取Todo项列表接口的测试用例</h3>

<p>编写该测试用例的思路如下：</p>

<ol>
<li>使用<code>@ExpectedDatabase</code>注解来验证接口没有对数据库表状态产生变化</li>
<li>模拟执行&rdquo;/&ldquo;的GET请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为200</li>
<li>对返回的响应结果作断言：view的名字是&rsquo;todo/list&rsquo;</li>
<li>对返回的响应结果作断言：view的路径为&rdquo;/WEB-INF/jsp/todo/list.jsp&rdquo;</li>
<li>对返回的响应结果作断言：model中Todo项的个数是2</li>
<li>对返回的响应结果作断言：model中的Todo项符合预期</li>
</ol>

<p>最终的代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.*;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class })
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData.xml&quot;)
    public void findAll() throws Exception {
        mockMvc.perform(get(&quot;/&quot;))
                .andExpect(status().isOk())
                .andExpect(view().name(&quot;todo/list&quot;))
                .andExpect(forwardedUrl(&quot;/WEB-INF/jsp/todo/list.jsp&quot;))
                .andExpect(model().attribute(&quot;todos&quot;, hasSize(2)))
                .andExpect(model().attribute(&quot;todos&quot;, hasItem(
                        allOf(
                                hasProperty(&quot;id&quot;, is(1L)),
                                hasProperty(&quot;description&quot;, is(&quot;Lorem ipsum&quot;)),
                                hasProperty(&quot;title&quot;, is(&quot;Foo&quot;))
                        )
                )))
                .andExpect(model().attribute(&quot;todos&quot;, hasItem(
                        allOf(
                                hasProperty(&quot;id&quot;, is(2L)),
                                hasProperty(&quot;description&quot;, is(&quot;Lorem ipsum&quot;)),
                                hasProperty(&quot;title&quot;, is(&quot;Bar&quot;))
                        )
                )));
    }
}
</code></pre>

<h3 id="获取单个todo项详情接口的测试用例">获取单个Todo项详情接口的测试用例</h3>

<p>根据参数的不同，获取单个Todo项详情接口会有两种不同的返回结果：</p>

<ul>
<li>如果指定id的Todo项存在，返回单个Todo项的详情页</li>
<li>如果指定id的Todo项不存在，返回404页</li>
</ul>

<p>对于指定Todo项存在的情况，我们可以按照以下步骤来编写测试用例：</p>

<ol>
<li>使用<code>@ExpectedDatabase</code>注解来验证接口没有对数据库表状态产生变化</li>
<li>模拟执行&rdquo;/todo/1&rdquo;的GET请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为200</li>
<li>对返回的响应结果作断言：view的名字是&rsquo;todo/view&rsquo;</li>
<li>对返回的响应结果作断言：view的路径为&rdquo;/WEB-INF/jsp/todo/view.jsp&rdquo;</li>
<li>对返回的响应结果作断言：model中的Todo项符合预期</li>
</ol>

<p>最终的代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.*;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class })
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData.xml&quot;)
    public void findById() throws Exception {
        mockMvc.perform(get(&quot;/todo/{id}&quot;, 1L))
                .andExpect(status().isOk())
                .andExpect(view().name(&quot;todo/view&quot;))
                .andExpect(forwardedUrl(&quot;/WEB-INF/jsp/todo/view.jsp&quot;))
                .andExpect(model().attribute(&quot;todo&quot;, hasProperty(&quot;id&quot;, is(1L))))
                .andExpect(model().attribute(&quot;todo&quot;, hasProperty(&quot;description&quot;, is(&quot;Lorem ipsum&quot;))))
                .andExpect(model().attribute(&quot;todo&quot;, hasProperty(&quot;title&quot;, is(&quot;Foo&quot;))));
    }
}
</code></pre>

<p>对于指定Todo项不存在的情况，我们可以按照以下步骤来编写测试用例：</p>

<ol>
<li>使用<code>@ExpectedDatabase</code>注解来验证接口没有对数据库表状态产生变化</li>
<li>模拟执行&rdquo;/todo/3&rdquo;的GET请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为404</li>
<li>对返回的响应结果作断言：view的名字是&rsquo;error/404&rsquo;</li>
<li>对返回的响应结果作断言：view的路径为&rdquo;/WEB-INF/jsp/error/404.jsp&rdquo;</li>
</ol>

<p>最终的代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.*;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class })
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData.xml&quot;)
    public void findByIdWhenTodoIsNotFound() throws Exception {
        mockMvc.perform(get(&quot;/todo/{id}&quot;, 3L))
                .andExpect(status().isNotFound())
                .andExpect(view().name(&quot;error/404&quot;))
                .andExpect(forwardedUrl(&quot;/WEB-INF/jsp/error/404.jsp&quot;));
    }
}
</code></pre>

<h3 id="删除指定todo项接口的测试用例">删除指定Todo项接口的测试用例</h3>

<p>根据参数的不同，删除指定Todo项接口会有两种不同的返回结果：</p>

<ul>
<li>如果指定id的Todo项存在，数据库中的Todo会被删除</li>
<li>如果指定id的Todo项不存在，返回404页</li>
</ul>

<p>对于指定Todo项存在的情况，我们可以按照以下步骤来编写测试用例：</p>

<ol>
<li>使用<code>@ExpectedDatabase</code>注解来验证接口对数据库的操作符合预期</li>
<li>模拟执行&rdquo;/todo/delete/1&rdquo;的GET请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为200</li>
<li>对返回的响应结果作断言：view的名字是&rsquo;redirect:/&rsquo;</li>
<li>对返回的响应结果作断言：view的路径为&rdquo;/WEB-INF/jsp/todo/view.jsp&rdquo;</li>
<li>对返回的响应结果作断言：flash中返回了预期的提示信息</li>
</ol>

<p>最终的代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.hamcrest.Matchers.is;
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.*;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class })
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;todoData-delete-expected.xml&quot;)
    public void deleteById() throws Exception {
        mockMvc.perform(get(&quot;/todo/delete/{id}&quot;, 1L))
                .andExpect(status().isOk())
                .andExpect(view().name(&quot;redirect:/&quot;))
                .andExpect(flash().attribute(&quot;feedbackMessage&quot;, is(&quot;Todo entry: Foo was deleted.&quot;)));
    }
}
</code></pre>

<p>作为对照，<code>todoData-delete-expected.xml</code>文件包含了预期的数据库表结果，内容如下：</p>

<pre><code class="language-xml">&lt;dataset&gt;
    &lt;todos id=&quot;2&quot; creation_time=&quot;2012-10-21 11:13:28&quot; description=&quot;Lorem ipsum&quot; modification_time=&quot;2012-10-21 11:13:28&quot; title=&quot;Bar&quot; version=&quot;0&quot;/&gt;
&lt;/dataset&gt;
</code></pre>

<p>对于指定Todo项不存在的情况，我们可以按照以下步骤来编写测试用例：</p>

<ol>
<li>使用<code>@ExpectedDatabase</code>注解来验证接口没有对数据库表状态产生变化</li>
<li>模拟执行&rdquo;/todo/delete/3&rdquo;的GET请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为404</li>
<li>对返回的响应结果作断言：view的名字是&rsquo;error/404&rsquo;</li>
<li>对返回的响应结果作断言：view的路径为&rdquo;/WEB-INF/jsp/error/404.jsp&rdquo;</li>
</ol>

<p>最终的代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.*;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class })
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData.xml&quot;)
    public void deleteByIdWhenTodoIsNotFound() throws Exception {
        mockMvc.perform(get(&quot;/todo/delete/{id}&quot;, 3L))
                .andExpect(status().isNotFound())
                .andExpect(view().name(&quot;error/404&quot;))
                .andExpect(forwardedUrl(&quot;/WEB-INF/jsp/error/404.jsp&quot;));
    }
}
</code></pre>

<h1 id="总结">总结</h1>

<p>到此为止，我们就写完了所有的测试用例代码。总结一下，本文主要内容如下：</p>

<ul>
<li>如何生成并执行模拟的HTTP请求，以及如何对响应结果作断言</li>
<li>使用Spring MVC Test编写的集成测试用例可读性非常好，可以作为接口文档的补充</li>
<li>Spring MVC Test没法验证view是否正确绘制，但可以验证是否使用了预期的view模板</li>
</ul>

<p>下一篇是 <a href="/2016/04/09/spring-mvc-testing-integration-testing-forms/">Spring MVC Integration Testing - Forms</a>。</p>
</div>

    
    

    

    

</main>

        <footer>

            <p class="copyright text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a></p>

        </footer>

    </body>

</html>

