<!DOCTYPE html>
<html lang="en">
    <head>
    <title>Learning Java Concurrency - ReentrantLock &amp; Condition - Elvis Wang</title>
    
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="description" content="wangbo’s home &amp; blog"/>

    <meta property="og:title" content="
    wangbo’s home &amp; blog -&nbsp;Learning Java Concurrency - ReentrantLock &amp; Condition" />
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https:&#x2F;&#x2F;www.wangbo.im&#x2F;posts&#x2F;2016-04-07-learning-java-concurrency-reentrantlock-condition&#x2F;"/>
    <meta property="og:description" content="&lt;p&gt;&lt;code&gt;ReentrantLock&lt;&#x2F;code&gt;是&lt;code&gt;synchronized&lt;&#x2F;code&gt;的高阶版本，用来控制多线程同步。&lt;code&gt;ReentrantLock&lt;&#x2F;code&gt;是一种独占锁，同一时间只能有一个线程使用一把锁，其他请求加锁的线程都会被阻塞。除了控制多线程…"/>
    <link rel="stylesheet" href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;style.css">
    <link rel="stylesheet" href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;color&#x2F;blue.css">
<link rel="shortcut icon" href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;favicon.ico" type="image/x-icon" /></head>
    <body>
        <div class="container full">
<header class="header">
    <div class="header__inner">
        <div class="header__logo">
            <a href="&#x2F;">
    <div class="logo">
        WB Prime
    </div>
</a>
        </div>
        <div class="menu-trigger">menu</div>
    </div>
    
    <nav class="menu">
        <ul class="menu__inner menu__inner--desktop">
            
            
                    <li>
                        <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;about">About</a>
                    </li>
                
                    <li>
                        <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;categories">Categories</a>
                    </li>
                
                    <li>
                        <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;tags">Tags</a>
                    </li>
                
            </ul>

        <ul class="menu__inner menu__inner--mobile">
            
        <li>
            <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;about">About</a>
        </li>
        <li>
            <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;categories">Categories</a>
        </li>
        <li>
            <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;tags">Tags</a>
        </li>
        </ul>
    </nav>

    </header>
<div class="content"><div class="post">
        <h1 class="post-title">
            <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;posts&#x2F;2016-04-07-learning-java-concurrency-reentrantlock-condition&#x2F;">Learning Java Concurrency - ReentrantLock &amp; Condition</a>
        </h1>
        
    <div class="post-meta">
        <span class="post-date">2016.04.07
                </span>

        <span class="post-author"></span>

        

    
    :: {<a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;categories&#x2F;learning-java-concurrency&#x2F;">Learning Java Concurrency</a>} 

            
    ::
    #<a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;tags&#x2F;java&#x2F;">java</a>
        
    #<a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;tags&#x2F;concurrency&#x2F;">concurrency</a>
        
    
            
        
    </div>



        

        <div class="post-content">
            <p><code>ReentrantLock</code>是<code>synchronized</code>的高阶版本，用来控制多线程同步。<code>ReentrantLock</code>是一种独占锁，同一时间只能有一个线程使用一把锁，其他请求加锁的线程都会被阻塞。除了控制多线程同步之外，<code>ReentrantLock</code>还提供了<code>Condition</code>用来进行多线程通讯。<code>Condition</code>是<code>Object</code>类的方法<code>wait &amp; notify</code>的替代版本，可以用等待/通知模式来有效控制多线程对共享资源的访问。</p>
<p>仿<a href="https://www.wangbo.im/posts/learning-java-concurrency-synchronized/"><code>synchronized</code></a>，用<code>ReentrantLock</code>实现单例模式的代码如下：</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#569cd6;">private static class </span><span style="color:#dcdcdc;">Singleton {
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">private static volatile </span><span style="color:#dcdcdc;">Singleton INSTANCE;
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">private static </span><span style="color:#dcdcdc;">ReentrantLock lock = </span><span style="color:#569cd6;">new </span><span style="color:#dcdcdc;">ReentrantLock();
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">private </span><span style="color:#dcdcdc;">Singleton() {}
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">public static </span><span style="color:#dcdcdc;">Singleton instance() {
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">Singleton </span><span style="color:#569cd6;">var </span><span style="color:#dcdcdc;">= </span><span style="color:#b4cea8;">INSTANCE</span><span style="color:#dcdcdc;">;
</span><span style="color:#dcdcdc;">        </span><span style="color:#569cd6;">if </span><span style="color:#dcdcdc;">(</span><span style="color:#569cd6;">null </span><span style="color:#dcdcdc;">== var) {
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">lock.lock();
</span><span style="color:#dcdcdc;">            </span><span style="color:#569cd6;">try </span><span style="color:#dcdcdc;">{
</span><span style="color:#dcdcdc;">                </span><span style="color:#569cd6;">var </span><span style="color:#dcdcdc;">= </span><span style="color:#b4cea8;">INSTANCE</span><span style="color:#dcdcdc;">;
</span><span style="color:#dcdcdc;">                </span><span style="color:#569cd6;">if </span><span style="color:#dcdcdc;">(</span><span style="color:#569cd6;">null </span><span style="color:#dcdcdc;">== var) {
</span><span style="color:#dcdcdc;">                    </span><span style="color:#b4cea8;">INSTANCE </span><span style="color:#dcdcdc;">= var = </span><span style="color:#569cd6;">new </span><span style="color:#dcdcdc;">Singleton();
</span><span style="color:#dcdcdc;">                </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">} </span><span style="color:#569cd6;">finally </span><span style="color:#dcdcdc;">{
</span><span style="color:#dcdcdc;">                </span><span style="color:#dcdcdc;">lock.unlock();
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">        </span><span style="color:#569cd6;">return var</span><span style="color:#dcdcdc;">;
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">}
</span></pre>
<p>仿<a href="https://www.wangbo.im/posts/2016-04-06-learning-java-concurrency-wait-notify/"><code>wait &amp; notify</code></a>，用<code>Condition</code>来实现父子通知汇款的代码如下：</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#569cd6;">private static class </span><span style="color:#dcdcdc;">DepositAccount {
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">private int </span><span style="color:#dcdcdc;">money;
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">private final </span><span style="color:#dcdcdc;">ReentrantLock lock = </span><span style="color:#569cd6;">new </span><span style="color:#dcdcdc;">ReentrantLock();
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">private final </span><span style="color:#dcdcdc;">Condition cond = lock.newCondition();
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">public </span><span style="color:#dcdcdc;">DepositAccount() {
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">this.money = </span><span style="color:#b5cea8;">0</span><span style="color:#dcdcdc;">;
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">public void </span><span style="color:#dcdcdc;">withdraw(</span><span style="color:#569cd6;">final int </span><span style="color:#dcdcdc;">val) {
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">lock.lock();
</span><span style="color:#dcdcdc;">        </span><span style="color:#569cd6;">try </span><span style="color:#dcdcdc;">{
</span><span style="color:#dcdcdc;">            </span><span style="color:#569cd6;">while </span><span style="color:#dcdcdc;">(money &lt; val) {
</span><span style="color:#dcdcdc;">                </span><span style="color:#569cd6;">try </span><span style="color:#dcdcdc;">{
</span><span style="color:#dcdcdc;">                    </span><span style="color:#dcdcdc;">cond.await(); </span><span style="color:#608b4e;">// 钱不够，等一会儿
</span><span style="color:#dcdcdc;">                </span><span style="color:#dcdcdc;">} </span><span style="color:#569cd6;">catch </span><span style="color:#dcdcdc;">(InterruptedException e) {
</span><span style="color:#dcdcdc;">                    </span><span style="color:#608b4e;">// do nothing here
</span><span style="color:#dcdcdc;">                </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">money -= val;
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">} </span><span style="color:#569cd6;">finally </span><span style="color:#dcdcdc;">{
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">lock.unlock();
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">public void </span><span style="color:#dcdcdc;">deposite(</span><span style="color:#569cd6;">final int </span><span style="color:#dcdcdc;">val) {
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">lock.lock();
</span><span style="color:#dcdcdc;">        </span><span style="color:#569cd6;">try </span><span style="color:#dcdcdc;">{
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">money += val;
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">cond.signalAll(); </span><span style="color:#608b4e;">// 存完钱周知一下
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">} </span><span style="color:#569cd6;">finally </span><span style="color:#dcdcdc;">{
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">lock.unlock();
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">}
</span></pre><p><a name="continue-reading"></a></p>
<h1 id="reentrantlock-s-api"><a class="zola-anchor" href="#reentrantlock-s-api" aria-label="Anchor link for: reentrantlock-s-api">🔗</a>
ReentrantLock's API</h1>
<ol>
<li>ReentrantLock() &amp; ReentrantLock(boolean fair)</li>
<li>void lock()</li>
<li>void lockInterruptibly() throws InterruptedException</li>
<li>boolean tryLock()</li>
<li>boolean tryLock(long timeout, TimeUnit unit)</li>
<li>void unlock()</li>
<li>boolean isHelpByCurrentThread()</li>
<li>boolean isLocked()</li>
<li>boolean isFair()</li>
<li>Condition newCondition()</li>
<li>boolean hasWaiters(Condition cond)</li>
</ol>
<p><code>ReentrantLock</code>的实现是委托给内部静态类<code>FairSync</code>和<code>NonfairSync</code>，这两个类又继承自<code>AbstractQueuedSynchronizer</code>。</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#569cd6;">abstract static class </span><span style="color:#dcdcdc;">Sync </span><span style="color:#569cd6;">extends </span><span style="color:#4ec9b0;">AbstractQueuedSynchronizer </span><span style="color:#dcdcdc;">{
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">...
</span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">static final class </span><span style="color:#dcdcdc;">NonfairSync </span><span style="color:#569cd6;">extends </span><span style="color:#4ec9b0;">Sync </span><span style="color:#dcdcdc;">{
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">...
</span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">static final class </span><span style="color:#dcdcdc;">FairSync </span><span style="color:#569cd6;">extends </span><span style="color:#4ec9b0;">Sync </span><span style="color:#dcdcdc;">{
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">...
</span><span style="color:#dcdcdc;">}
</span></pre><h2 id="gong-ping-suo-yu-fei-gong-ping-suo"><a class="zola-anchor" href="#gong-ping-suo-yu-fei-gong-ping-suo" aria-label="Anchor link for: gong-ping-suo-yu-fei-gong-ping-suo">🔗</a>
公平锁与非公平锁</h2>
<p><code>FairSync</code>和<code>NonfairSync</code>即所谓的公平锁和非公平锁。对比一下两个锁版本对于<code>lock</code>方法的实现，就能明白公平和非公平的区别在哪里了。</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#569cd6;">final</span><span style="color:#dcdcdc;"> void lock() { </span><span style="color:#608b4e;">// NonfairSync
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">if </span><span style="color:#dcdcdc;">(compareAndSetState(</span><span style="color:#b5cea8;">0</span><span style="color:#dcdcdc;">, </span><span style="color:#b5cea8;">1</span><span style="color:#dcdcdc;">))
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">setExclusiveOwnerThread(Thread.currentThread());
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">else
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">acquire(</span><span style="color:#b5cea8;">1</span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">final</span><span style="color:#dcdcdc;"> void lock() { </span><span style="color:#608b4e;">// FairSync
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">acquire(</span><span style="color:#b5cea8;">1</span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">}
</span></pre>
<p>可以看到，公平锁直接让当前线程加入等待队列；而非公平锁首先试图去获取锁，如果当前有线程恰好释放了锁，就可以插队获取到锁，如果获取失败，还是会加入等待队列。也就是说，非公平锁会在调用lock的时候去尝试获取锁。如果这时候能够获取锁，就直接获取到锁，这样可以减少线程挂起和恢复的性能开销；缺点就是有可能在等待队列中的线程有可能永远拿不到锁。</p>
<p><code>ReentrantLock</code>在构造器中可以指定使用公平锁还是非公平锁策略，默认是非公平锁。</p>
<h2 id="lock"><a class="zola-anchor" href="#lock" aria-label="Anchor link for: lock">🔗</a>
<code>lock</code></h2>
<p><code>lock()</code>和<code>lockInterruptibly()</code>用于获取锁。调用线程试图去获取一个锁，如果锁已经被当前线程占用，则锁的计数器加1；如果锁被其他线程占用，则当前线程被阻塞，进入等待队列等待锁被释放。</p>
<p>两者的区别在于等待线程在等待的过程中是否可以被中断。</p>
<h2 id="trylock"><a class="zola-anchor" href="#trylock" aria-label="Anchor link for: trylock">🔗</a>
<code>tryLock</code></h2>
<p>如果调用线程不想被阻塞，可以使用<code>lock</code>的异步版本<code>tryLock</code>。<code>tryLock</code>会试图去获取锁，如果获取成功了，就返回成功；如果失败了，就会返回失败。获取失败，可以设定一个等待时间，自旋等待。</p>
<h2 id="unlock"><a class="zola-anchor" href="#unlock" aria-label="Anchor link for: unlock">🔗</a>
<code>unlock</code></h2>
<p>如果调用线程持有了目标锁，当前线程调用<code>unlock</code>会试图释放锁定。准确的说是让目标锁的计数器减1,如果目标锁的计数器为0,则锁被释放。</p>
<p>如果调用线程没有持有目标锁，会导致<code>IllegalMonitorStateException</code>异常。</p>
<h2 id="newcondition"><a class="zola-anchor" href="#newcondition" aria-label="Anchor link for: newcondition">🔗</a>
<code>newCondition</code></h2>
<p>创建一个与目标锁相关联的<code>Condition</code>对象。</p>
<h1 id="condition-s-api"><a class="zola-anchor" href="#condition-s-api" aria-label="Anchor link for: condition-s-api">🔗</a>
Condition's API</h1>
<ol>
<li>void await() throws InterruptedException</li>
<li>void awaitUninterruptibly()</li>
<li>long awaitNanos(long nanos) throws InterruptedException</li>
<li>boolean await(long timeout, TimeUnit unit) throws InterruptedException</li>
<li>boolean awaitUnit(Date dt) throws InterruptedException</li>
<li>void signal()</li>
<li>void signalAll()</li>
</ol>
<p><code>Condition</code>的作用和用法可以参考<code>Object</code>类的<code>wait &amp; notify</code>族。</p>
<p><code>ReentrantLock</code>返回的<code>Condition</code>对象与一个互斥锁相关联。<code>Condition</code>对象本身维护一个线程的等待队列，<code>await</code>会将调用线程放到等待队列中；<code>signal</code>会将等待线程中的所有线程放到关联的<code>ReentrantLock</code>对象的等待队列中。这样线程的挂起和唤醒工作就由<code>ReentrantLock</code>对象完成。</p>
<h2 id="await"><a class="zola-anchor" href="#await" aria-label="Anchor link for: await">🔗</a>
<code>await</code></h2>
<p>同<code>Object</code>的<code>wait</code>族，估计就是因为已经有了<code>wait</code>，所以新的API才被命名为<code>await</code>。</p>
<p>调用线程会被挂起，一直等到条件满足被其他线程用<code>signal</code>来唤醒。</p>
<p>等待可以设置允不允许中断，也可以设置等待时间间隔。</p>
<p>调用线程被挂起之后会释放持有的锁，加入到<code>Condition</code>对象的等待队列中去。</p>
<h2 id="signal"><a class="zola-anchor" href="#signal" aria-label="Anchor link for: signal">🔗</a>
<code>signal</code></h2>
<p>同<code>Object</code>的<code>notify</code>族。</p>
<p><code>signal</code>唤醒线程的顺序是未定义的，不同的JVM实现会有不同的策略，可以是等待时间最长的最先被唤醒。</p>
<p><code>signal</code>会将需要唤醒的线程从<code>Condition</code>自己的等待队列移动到绑定的<code>ReentrantLock</code>对象的等待序列，按照<code>ReentrantLock</code>的规则去获取锁。</p>
<h1 id="dai-ma-xia-zai"><a class="zola-anchor" href="#dai-ma-xia-zai" aria-label="Anchor link for: dai-ma-xia-zai">🔗</a>
代码下载</h1>
<p><a href="https://www.wangbo.im/posts/2016-04-07-learning-java-concurrency-reentrantlock-condition/ConditionCase.java">ConditionCase.java</a>
<a href="https://www.wangbo.im/posts/2016-04-07-learning-java-concurrency-reentrantlock-condition/ReentrantLockCase.java">ReentrantLockCase.java</a></p>

        </div>
        
    
</div></div>
            
    <div class="pagination">
        <div class="pagination__buttons">
            </div>
    </div>
<footer class="footer">
                    <div class="footer__inner"><div class="copyright">
            <span>© 2019 <a href="https://github.com/ejmg/zerm">zerm</a> :: Powered by <a href="https://www.getzola.org/">Zola</a></span>
            <span>:: Theme made by <a href="https://github.com/ejmg">ejmg</a></span>
        </div>
    <script type="text/javascript" src="https:&#x2F;&#x2F;www.wangbo.im&#x2F;assets&#x2F;js&#x2F;main.js"></script>
</div>
                    

                </footer></div>
    </body>
</html>
