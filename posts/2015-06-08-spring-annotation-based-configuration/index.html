<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Spring: Annotation based configuration</title>
        <style>

    html body {
        font-family: Raleway, sans-serif;
        background-color: white;
    }

    :root {
        --accent: lightseagreen;
        --border-width:  0 ;
    }

</style>


<link rel="stylesheet" href="/css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 


    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

     <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/c&#43;&#43;.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/kotlin.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script> 

    <script>hljs.initHighlightingOnLoad();</script>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.32-DEV" />
        
    </head>

    <body>

        <nav class="navbar navbar-default navbar-fixed-top">

            <div class="container">

                <div class="navbar-header">

                    <a class="navbar-brand visible-xs" href="#">Spring: Annotation based configuration</a>

                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>

                </div>

                <div class="collapse navbar-collapse">

                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/posts/">Posts</a></li>
                            
                                <li><a href="/categories/">Categories</a></li>
                            
                                <li><a href="/tags/">Tags</a></li>
                            
                        </ul>
                    

                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="https://github.com/wbprime/"><i class="fa fa-github"></i></a></li>
                            
                        </ul>
                    

                </div>

            </div>

        </nav>


<main>

    <div class="item">

    
    
    

    
      

    <h4><a href="/posts/2015-06-08-spring-annotation-based-configuration/">Spring: Annotation based configuration</a></h4>
    <h5>The Springframework annotation-based metadata configuration guide.</h5>
     <kbd class="item-tag">Spring</kbd>  <kbd class="item-tag">java</kbd> 

</div>


    <br> <div class="text-justify">

<p>Despite XML-based configuration, the Springframework provides full support for annotation-based metadata configuration.</p>

<p>XML-based configuration isolates the configuration metadata from source code using independent xml files, while annotation-based configuration mixes source code and configuration data.  Thus which is the better one to collaborate with the Springframework?  The answer is it depends.  The XML one performes good isolation between source code and configuration, however you need to bear its stupid and complex and long-but-useless xml syntax, and you must do additional work to sync youc onfiguration data and you source code when you need to update your code, which however is very frequent during development.  The annotation one is easy-understanding and simple to update/sync your configuration with your source code.  The cons is obvious that it addes more semantics to a regular Java bean leading to a mixing of configuration and source.</p>

<p>Fortunately you can use both styels and mix them together.  Note that annotation-based configuration is performed before XMl injection.</p>

<p>Note that almost all annotation-based configurations are per-class other than per-bean.</p>

<h1 id="dependency-injection-annotations">Dependency Injection Annotations</h1>

<p>Beans can be injected into a host bean through annotations.  Typical DI-related annotations are <code>@Required</code>, <code>@Autowired</code>, <code>@Resource</code>, <code>@PostConstruct</code>, <code>@PreDestroy</code>.</p>

<p>To enable annotations <code>@Required</code>, <code>@Autowired</code>, <code>@Resource</code>, <code>@PostConstruct</code>, <code>@PreDestroy</code>, you need to add a <code>&lt;context:annotation-config /&gt;</code> element in your beans xml file.</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config /&gt;
&lt;/beans&gt;
</code></pre>

<p>Alternatively you can include explicite <code>RequiredAnnotationBeanPostProcessor</code>, <code>AutowiredAnnotationBeanPostProcessor</code>, <code>CommonAnnotationBeanPostProcessor</code> or <code>PersistenceAnnotationBeanPostProcessor</code> dependencies instead.</p>

<p>To make it clear, these annotations help DI procedure, while the annotation detection and bean recovery are done by XML definitions.</p>

<h2 id="required"><code>@Required</code></h2>

<p>The <code>@Required</code> annotation applies to bean property setter to specify that this property must be populated at configuration time.  This annotation is introduced from Spring 2.0.</p>

<pre><code>public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // more methods
}
</code></pre>

<h2 id="autowired"><code>@Autowired</code></h2>

<p>The <code>@Autowired</code> annotation performs autowiring by type.  This annotation is introduced from Spring 2.5.</p>

<p>The <code>@Autowired</code> annotation can be applied to field.</p>

<pre><code>public class OuterBean {
    @Autowired
    private InnerBean inner;
}
</code></pre>

<p>Applied to setter:</p>

<pre><code>public class OuterBean {
    private InnerBean inner;

    @Required
    public void setInner(InnerBean inner) {
        this.inner = inner;
    }
}
</code></pre>

<p>Applied to regular (set) method:</p>

<pre><code>public class OuterBean {
    private InnerBean1 inner1;
    private InnerBean2 inner2;

    @Autowired
    public void prepare(InnerBean1 inner1, InnerBean2 inner2) {
        this.inner1 = inner1;
        this.inner2 = inner2;
    }
}
</code></pre>

<p>Applied to constructor:</p>

<pre><code>public class OuterBean {
    private InnerBean inner;

    @Autowired
    public void OuterBean(InnerBean inner) {
        this.inner = inner;
    }
}
</code></pre>

<p>There should only be one constructor annotated with <code>@Autowired</code> in a class.  However you can use <code>required</code> attribute to annotate multi constructor.  Typically the target constructor is <code>public</code> but not limited to.</p>

<pre><code>public class OuterBean {
    private InnerBean inner;

    @Autowired
    public void OuterBean(InnerBean inner) {
        this.inner = inner;
    }

    @Autowired(required=false)
    public void OuterBean(InnerBean inner, AnotherBean anther) {
        this.inner = inner;
    }
}
</code></pre>

<p>Applied to array:</p>

<pre><code>public class OuterBean {
    @Autowired
    private InnerBean[] inners;
}
</code></pre>

<p>Applied to typed collection:</p>

<pre><code>public class OuterBean {
    @Autowired
    private Set&lt;InnerBean&gt; inners;
}
</code></pre>

<p>Specially, a <code>Map</code> can be autowired if and only if its key type is <code>String</code>.</p>

<pre><code>public class OuterBean {
    @Autowired
    private Map&lt;String, InnerBean&gt; innersMap;
}
</code></pre>

<h2 id="autowired-combined-with-qualifier"><code>@Autowired</code> Combined with <code>@Qualifier</code></h2>

<p>When there are multi candidates for auotwiring, <code>@Qualifier</code> can help you control wiring details.</p>

<p>Generally you can specify which bean is needed among multi beans of the same type. For example:</p>

<p>In your annotation source file:</p>

<pre><code>public class OuterBean {
    @Autowired
    @Qualifier(&quot;main&quot;)
    private InnerBean inner;
}
</code></pre>

<p>In your xml file:</p>

<pre><code>&lt;bean id=&quot;inner1&quot; class=&quot;InnerBean&quot;&gt;
    &lt;qualifier value=&quot;main&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;inner2&quot; class=&quot;InnerBean&quot;&gt;
    &lt;qualifier value=&quot;action&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;outer&quot; class=&quot;OuterBean&quot;/&gt;
</code></pre>

<p>Thus bean <code>inner1</code> will be autowired to bean <code>outer</code>.</p>

<p>The <code>@Qualifier</code> can also be applied to a construtor argument.</p>

<pre><code>public class OuterBean {
    @Autowired
    public void OuterBean(@Qualifier(&quot;main&quot;) InnerBean inner) {
    }
}
</code></pre>

<p>If the value of <code>@Qualifier</code> is not given, the bean id/name will be used as a fallback qualifier value.</p>

<h2 id="custom-qualifier">Custom <code>@Qualifier</code></h2>

<p>Dispite value based <code>@Qualifier</code> identification, you can custom your own qualifier annotation and use type based <code>@Qualifier</code>.</p>

<p>Given:</p>

<pre><code>@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Genre {
    String value();
}

public class OuterBean {
    @Autowired
    @Genre(&quot;Action&quot;)
    private InnerBean inner;
}
</code></pre>

<p>Thus following configuration works:</p>

<pre><code>&lt;context:annotation-config/&gt;

&lt;bean class=&quot;OuterBean&quot;&gt;
    &lt;qualifier type=&quot;Genre&quot; value=&quot;Action&quot;/&gt;
&lt;/bean&gt;
</code></pre>

<h2 id="resource"><code>@Resource</code></h2>

<p>The Spring introduces support for JSR-250 annotations like <code>@Resource</code> from version 2.5.  <code>@Resource</code> works on fields or setters, taking a name attribute indicating the bean id/name to be injected.  One of the differences between <code>@Resource</code> and <code>@Autowired</code> is that the former performs by-name injection while the latter by-type.</p>

<pre><code>public class OuterBean {

    @Resource(name=&quot;inner&quot;)
    private InnerBean inner;

    @Resource
    private InnerBean inner1;

    private InnerBean inner2;

    @Resource
    public void setInner2(InnerBean inner2) { }
}
</code></pre>

<p>The bean <code>inner</code> will be injected as it is specified explicitely.  However, if not specified, a fallback injection will be done by setting the field name (for field annotation, i.e., <code>inner1</code>) or the arguement name (for setter method, e.g., <code>inner2</code>).</p>

<h2 id="postconstruct-and-predestroy"><code>@PostConstruct</code> and <code>@PreDestroy</code></h2>

<p>Similar to XML based configuration, the Spring annotation based configuration also provides annotations to support bean lifecycle management.</p>

<p>The <code>@PostConstruct</code> annotation specifies the callback after bean instantiation and dependency injection.</p>

<p>The <code>@PreDestroy</code> annotation specifies the callback before bean destruction.</p>

<pre><code>public class OuterBean {
    @PostConstruct
    public void myCustomInit() {
    }

    @PreDestroy
    public void myCustomDestroy() {
    }
}
</code></pre>

<h1 id="classpath-scanning">Classpath Scanning</h1>

<p>Last annotations demonstrate ways to help dependency injection, however dependency beans themself need to be specified using traditional XML definitions.</p>

<p>More or less, the Springframework also provides annotations to help bean registration and dependecy detection, removing the need of xml files.</p>

<h2 id="component-repository-service-and-controller"><code>@Component</code>, <code>@Repository</code>, <code>@Service</code> and <code>@Controller</code></h2>

<p>The <code>@Component</code> annotation is a generic marker of any conponents that are designing to managed by the Spring container.  That is to say, that the any class decorated by <code>@Component</code> would be instatiated as a bean, and the beans lifecycle is managed by the Spring container, and the beans will be scanned and filtered in DI step.</p>

<p>The <code>@Component</code> annotation provides three specializtions concentrating on semantics.  The <code>@Repository</code> annotation marks, say, a repository type (DAO).  The <code>@Service</code> annotation marks a service layer type.  The <code>@Controller</code> annotation marks a presentation layer type.  These annotations differ in semantics and may be used differently by the Spring framework in future releases.</p>

<pre><code>@Component
public class MyCustomBean {}

@Repository
public class MyCustomDAO {}

@Service
public class MyCustomService {}

@Controller
public class MyCustomController {}
</code></pre>

<p>To enable classpath scanning, you need additional work.  Adding following lines in your xml configuration file:</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;org.example&quot;/&gt;

&lt;/beans&gt;
</code></pre>

<p>The <code>&lt;context:component-scan /&gt;</code> calles classpath auto scanning, specifying the qualified package name <code>org.example</code>.  This implicit enables the <code>&lt;context:annotation-config /&gt;</code> which enables <code>AutowiredAnnotationBeanPostProcessor</code>, <code>CommonAnnotationBeanPostProcessor</code> and <code>RequiredAnnotationBeanPostProcessor</code> at the same time.  So the <code>@Required</code>, <code>@Autowired</code>, <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations are also out of box.</p>

<p>Also you can implement your own annotations based on <code>@Component</code> meta annotation.</p>

<pre><code>// Spring will treat @MyComponent in the same way as @Component
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Component 
public @interface MyComponent { }
</code></pre>

<p>The custom <code>@MyComponent</code> annotation will be treated like the <code>@Component</code> besides more costom semantics.</p>

<p>The bean name for a annotated class is generated by the Spring following a default rule: returning the uncapitalized non-qualified class name.</p>

<p>i.g.,</p>

<pre><code>@Repository
public class MyCustomDAO {}
</code></pre>

<p>will auto introduce a bean named *myCustomDAO&rdquo;.</p>

<p>However, if you don&rsquo;t like this name, you can set <code>name</code> using <code>@Repository(&quot;myBestName&quot;)</code>.  The <code>name</code> property applies to <code>@Component</code>, <code>@Repository</code>, <code>@Service</code> and <code>@Controller</code>.</p>

<p>If you don&rsquo;t like the default naming rule, you can use <code>BeanNameGenerator</code> interface.</p>

<h2 id="scope"><code>@Scope</code></h2>

<p>Specifying bean scope using the <code>@Scope</code> annotation.</p>

<pre><code>@Scope(&quot;prototype&quot;)
@Repository
public class MyCustomBean { }
</code></pre>

<h2 id="lazy"><code>@Lazy</code></h2>

<p>Specifying bean lazy instantiating using the <code>@Lazy</code> annotation.</p>

<pre><code>@Lazy
@Repository
public class MyCustomBean { }
</code></pre>

<h2 id="beans-filtering">Beans Filtering</h2>

<p>You may want to cusotm the beans are to be scanned by setting some filters.  You can achieve this by adding <code>include-filter</code> and <code>exclude-filter</code> sub-element to <code>component-scan</code> element.</p>

<pre><code>&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;org.example&quot;&gt;
        &lt;context:include-filter type=&quot;regex&quot;
                expression=&quot;.*Stub.*Repository&quot;/&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot;
                expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;
    &lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre>

<p>This implies the configuration will ignore all <code>@Repository</code> annotations and using &ldquo;stub Repository&rdquo; instead.</p>

<p>You must set <code>type</code> and <code>expression</code> attributes for a <code>include-filter</code> or a <code>exclude-filter</code> element.  Types are <em>annotation</em>, <em>assignable</em>, <em>aspectj</em>, <em>regex</em> and <em>custom</em>.</p>

<table>
<thead>
<tr>
<th>Filter Type</th>
<th>Example Expression</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>annotation (default)</td>
<td>org.example.SomeAnnotation</td>
<td>An annotation to be present at the type level in target components.</td>
</tr>

<tr>
<td>assignable</td>
<td>org.example.SomeClass</td>
<td>A class (or interface) that the target components are assignable to (extend/implement).</td>
</tr>

<tr>
<td>aspectj</td>
<td>org.example..*Service+</td>
<td>An AspectJ type expression to be matched by the target components.</td>
</tr>

<tr>
<td>regex</td>
<td>org.example.Default.*</td>
<td>A regex expression to be matched by the target components class names.</td>
</tr>

<tr>
<td>custom</td>
<td>org.example.MyTypeFilter</td>
<td>A custom implementation of the org.springframework.core.type .TypeFilter interface.</td>
</tr>
</tbody>
</table>

<h1 id="jsr-3-0-annotations-alternatives">JSR 3.0 Annotations Alternatives</h1>

<p>You can use also JSR 3.0 standard annotations for dependency injection.  These annotations are scanned in the same way as the Spring annotations.</p>

<p>To use JSR 3.0 annotations, you need to add relevant jars to your classpath.</p>

<p>For maven, adding following lines:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.inject&lt;/groupId&gt;
    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;
    &lt;version&gt;1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h2 id="inject"><code>@Inject</code></h2>

<p>Think <code>@Inject</code> as <code>@Autowired</code>.</p>

<p>The <code>@Inject</code> annotation can be applied at the class-level, field-level, method-level and constructor-argument level.</p>

<pre><code>import javax.inject.Inject;

public class OuterBean {
    private InnerBean inner;

    @Inject
    public void setInner(InnerBean inner) {
        this.inner = inner;
    }
}
</code></pre>

<h2 id="named"><code>@Named</code></h2>

<p>Think <code>@Named</code> as <code>@Component</code>.</p>

<pre><code>import javax.inject.Named;

@Named
public class OuterBean { }
</code></pre>

<p>You can specify a <em>name</em> to the <code>@Named</code>.</p>

<pre><code>@Named(&quot;myOuterBean&quot;)
public class OuterBean { }
</code></pre>

<p>Specially, you can use <code>@Named</code> combined with <code>@Inject</code>.</p>

<pre><code>@Inject
public void setInner(@Named(&quot;main&quot;) InnerBean inner) {
    this.inner = inner;
}
</code></pre>

<h2 id="jsr-3-0-annotations-vs-spring-annotations"><em>JSR 3.0 Annotations</em> VS <em>Spring Annotations</em></h2>

<p>The comparison between <em>JSR 3.0 annotations</em> VS <em>Spring annotations</em> is shown in following table.</p>

<table>
<thead>
<tr>
<th>Spring</th>
<th>javax.inject.*</th>
<th>javax.inject restrictions / comments</th>
</tr>
</thead>

<tbody>
<tr>
<td>@Autowired</td>
<td>@Inject</td>
<td>@Inject has no required attribute</td>
</tr>

<tr>
<td>@Component</td>
<td>@Named</td>
<td>-</td>
</tr>

<tr>
<td>@Scope(&ldquo;singleton&rdquo;)</td>
<td>@Singleton</td>
<td>The JSR-330 default scope is like Spring’s prototype. However, in order to keep it consistent with Spring’s general defaults, a JSR-330 bean declared in the Spring container is a singleton by default. In order to use a scope other than singleton, you should use Spring’s @Scope annotation.</td>
</tr>

<tr>
<td>@Qualifier</td>
<td>@Named</td>
<td>-</td>
</tr>

<tr>
<td>-@Value</td>
<td>-</td>
<td>-no equivalent</td>
</tr>

<tr>
<td>@Required</td>
<td>-</td>
<td>-no equivalent</td>
</tr>

<tr>
<td>@Lazy</td>
<td>-</td>
<td>-no equivalent</td>
</tr>
</tbody>
</table>

<h1 id="summary">Summary</h1>

<p>The Spring annotation-based metadata configuration method is a full-featured and easy to use alternative to traditional XML-based metadata configuration.</p>

<p>Note that annotation injection is performed before XML injection, thus the latter configuration will override the former for properties wired through both approaches.</p>
</div>

    
    

    

    

</main>

        <footer>

            <p class="copyright text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a></p>

        </footer>

    </body>

</html>

