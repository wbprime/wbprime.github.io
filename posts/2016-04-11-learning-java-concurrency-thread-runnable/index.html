<!DOCTYPE html>
<html lang="en">
    <head>
    <title>Learning Java Concurrency - Thread &amp; Runnable - Elvis Wang</title>
    
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="description" content="wangbo’s home &amp; blog"/>

    <meta property="og:title" content="
    wangbo’s blog -&nbsp;Learning Java Concurrency - Thread &amp; Runnable" />
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https:&#x2F;&#x2F;www.wangbo.im&#x2F;posts&#x2F;2016-04-11-learning-java-concurrency-thread-runnable&#x2F;"/>
    <meta property="og:description" content="&lt;p&gt;Java并发多线程的第一课，应该就是&lt;code&gt;Thread&lt;&#x2F;code&gt;了。顾名思义，&lt;code&gt;Thread&lt;&#x2F;code&gt;就是一个线程。线程是很底层的一个概念，在不同的操作系统上实现的模型和细节并不相同，甚至于可以说天差地别；但是总体来说，线程是比进程更细粒度的操作系统调度的单位，线程有自己的运行栈，但是同一…"/>
    <link rel="stylesheet" href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;style.css">
    <link rel="stylesheet" href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;color&#x2F;blue.css">
<link rel="shortcut icon" href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;favicon.ico" type="image/x-icon" /></head>
    <body>
        <div class="container full">
<header class="header">
    <div class="header__inner">
        <div class="header__logo">
            <a href="&#x2F;">
    <div class="logo">
        WB Prime
    </div>
</a>
        </div>
        <div class="menu-trigger">menu</div>
    </div>
    
    <nav class="menu">
        <ul class="menu__inner menu__inner--desktop">
            
            
                    <li>
                        <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;about">About</a>
                    </li>
                
                    <li>
                        <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;categories">Categories</a>
                    </li>
                
                    <li>
                        <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;tags">Tags</a>
                    </li>
                
            </ul>

        <ul class="menu__inner menu__inner--mobile">
            
        <li>
            <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;about">About</a>
        </li>
        <li>
            <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;categories">Categories</a>
        </li>
        <li>
            <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;tags">Tags</a>
        </li>
        </ul>
    </nav>

    </header>
<div class="content"><div class="post">
        <h1 class="post-title">
            <a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;posts&#x2F;2016-04-11-learning-java-concurrency-thread-runnable&#x2F;">Learning Java Concurrency - Thread &amp; Runnable</a>
        </h1>
        
    <div class="post-meta">
        <span class="post-date">2016.04.11
                </span>

        <span class="post-author"></span>

        

    
    :: {<a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;categories&#x2F;learning-java-concurrency&#x2F;">Learning Java Concurrency</a>} 

            
    ::
    #<a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;tags&#x2F;java&#x2F;">java</a>
        
    #<a href="https:&#x2F;&#x2F;www.wangbo.im&#x2F;tags&#x2F;concurrency&#x2F;">concurrency</a>
        
    
            
        
    </div>



        

        <div class="post-content">
            <p>Java并发多线程的第一课，应该就是<code>Thread</code>了。顾名思义，<code>Thread</code>就是一个线程。线程是很底层的一个概念，在不同的操作系统上实现的模型和细节并不相同，甚至于可以说天差地别；但是总体来说，线程是比进程更细粒度的操作系统调度的单位，线程有自己的运行栈，但是同一个进程的线程共享方法区和堆区数据。</p>
<p>对于进程和线程的差别，有一种说法是：线程是操作系统调度的基本单位，而进程是操作系统分配运行资源的基本单位。</p>
<p>Java中对线程作了很好的封装：<code>Thread</code>类。<code>Thread</code>类的使用非常简单。</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#569cd6;">public class </span><span style="color:#dcdcdc;">ThreadCase {
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">private static class </span><span style="color:#dcdcdc;">EchoThread </span><span style="color:#569cd6;">extends </span><span style="color:#4ec9b0;">Thread </span><span style="color:#dcdcdc;">{
</span><span style="color:#dcdcdc;">        </span><span style="color:#569cd6;">private final </span><span style="color:#dcdcdc;">String word;
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">        </span><span style="color:#569cd6;">public </span><span style="color:#dcdcdc;">EchoThread(</span><span style="color:#569cd6;">final </span><span style="color:#dcdcdc;">String word) {
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">this.word = word;
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">@Override
</span><span style="color:#dcdcdc;">        </span><span style="color:#569cd6;">public void </span><span style="color:#dcdcdc;">run() {
</span><span style="color:#dcdcdc;">            </span><span style="color:#569cd6;">for </span><span style="color:#dcdcdc;">(</span><span style="color:#569cd6;">int</span><span style="color:#dcdcdc;"> i = </span><span style="color:#b5cea8;">0</span><span style="color:#dcdcdc;">; i &lt; </span><span style="color:#b5cea8;">1000</span><span style="color:#dcdcdc;">; i</span><span style="color:#569cd6;">++</span><span style="color:#dcdcdc;">) {
</span><span style="color:#dcdcdc;">                </span><span style="color:#dcdcdc;">System.out.println(this.getName() + </span><span style="color:#d69d85;">&quot; echos &quot; </span><span style="color:#dcdcdc;">+ word);
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">public static void </span><span style="color:#dcdcdc;">main(String </span><span style="color:#569cd6;">[] </span><span style="color:#dcdcdc;">_args) {
</span><span style="color:#dcdcdc;">        </span><span style="color:#569cd6;">final </span><span style="color:#dcdcdc;">Thread echo1 = </span><span style="color:#569cd6;">new </span><span style="color:#dcdcdc;">EchoThread(</span><span style="color:#d69d85;">&quot;First&quot;</span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">        </span><span style="color:#569cd6;">final </span><span style="color:#dcdcdc;">Thread echo2 = </span><span style="color:#569cd6;">new </span><span style="color:#dcdcdc;">EchoThread(</span><span style="color:#d69d85;">&quot;Second&quot;</span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">System.out.println(</span><span style="color:#d69d85;">&quot;Main thread started!&quot;</span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">echo1.start();
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">echo2.start();
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">joinThread(echo1);
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">joinThread(echo2);
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">System.out.println(</span><span style="color:#d69d85;">&quot;Main thread finished!&quot;</span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">private static void </span><span style="color:#dcdcdc;">joinThread(</span><span style="color:#569cd6;">final </span><span style="color:#dcdcdc;">Thread th) {
</span><span style="color:#dcdcdc;">        </span><span style="color:#569cd6;">try </span><span style="color:#dcdcdc;">{
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">th.join();
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">} </span><span style="color:#569cd6;">catch </span><span style="color:#dcdcdc;">(InterruptedException e) {
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">System.out.println(th.getName() + </span><span style="color:#d69d85;">&quot; interrupted!&quot;</span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">}
</span></pre>
<p>可以很明显地发现：</p>
<ul>
<li>main负责启动其他线程，main本身也是一个线程</li>
<li>线程的调度是难以预料的，<code>echo1</code>和<code>echo2</code>的输出结果相互交错可以看出这一点</li>
<li>线程之间可以进行同步控制，使用<code>Thread.join()</code>方法可以强制等待另一个线程结束</li>
<li>自定义线程行为只需要重新实现<code>Thread.run()</code>方法即可</li>
<li>线程的启动入口是<code>Thread.start()</code>方法，不要直接运行<code>Thread.run()</code>方法</li>
<li><code>Thread</code>类是一个<code>class</code>（与<code>interface</code>相对应），意味着自定义线程类不能继承别的父类</li>
</ul>
<p><a name="continue-reading"></a></p>
<h1 id="thread"><a class="zola-anchor" href="#thread" aria-label="Anchor link for: thread">🔗</a>
Thread</h1>
<h2 id="api-lie-biao"><a class="zola-anchor" href="#api-lie-biao" aria-label="Anchor link for: api-lie-biao">🔗</a>
API 列表</h2>
<ol>
<li>Thread()</li>
<li>Thread(Runnable target)</li>
<li>Thread(Runnable target, AccessControlContext acc)</li>
<li>Thread(ThreadGroup group, Runnable target)</li>
<li>Thread(String name)</li>
<li>Thread(ThreadGroup group, String name)</li>
<li>Thread(Runnable target, String name)</li>
<li>Thread(ThreadGroup group, Runnable target, String name)</li>
<li>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</li>
<li>void start()</li>
<li>void interrupt()</li>
<li>boolean isInterrupted()</li>
<li>boolean isAlive()</li>
<li>State getState()</li>
<li>void run()</li>
<li>void join(long millis)</li>
<li>void join(long millis, int nanos)</li>
<li>void join() throws InterruptedException</li>
<li>static native void sleep(long millis) throws InterruptedException</li>
<li>static void sleep(long millis, int nanos)</li>
<li>void setDaemon(boolean on)</li>
<li>boolean isDaemon()</li>
<li>static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()</li>
<li>static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)</li>
<li>UncaughtExceptionHandler getUncaughtExceptionHandler()</li>
<li>void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)</li>
<li>static native Thread currentThread()</li>
</ol>
<h2 id="chuang-jian-xian-cheng-lei-dui-xiang"><a class="zola-anchor" href="#chuang-jian-xian-cheng-lei-dui-xiang" aria-label="Anchor link for: chuang-jian-xian-cheng-lei-dui-xiang">🔗</a>
创建线程类对象</h2>
<p><code>Thread</code>类一共有9个公开的构造函数，咋一看很杂乱无章的，但是其实是有规律的。</p>
<p>考虑以下事实：</p>
<ul>
<li>每个线程应该有一个名字，用来标识自己</li>
<li>每个线程可以有自己的行为，应该有一个用于自定义行为的类<code>Runnable</code></li>
<li>线程应该可以分组，属于某个特定的<code>ThreadGroup</code>实例</li>
<li>线程应该有权限控制，用<code>AccessControlContext</code>来设置</li>
<li>每个线程有自己的栈，应该可以自定义栈的大小</li>
</ul>
<p>这些线程相关的属性相互组合，并添加一些默认值，能够得到的构造函数绝对不止9个，哈！</p>
<p>实际上，以上所有的构造函数都是调用了内部私有的<code>init()</code>方法。</p>
<p>注意：<code>Thread</code>类是一个普通的Java类，所以构造器创建的对象引用是分配在当前的线程。该实例对应的线程还没有被创建。</p>
<h2 id="qi-dong-xian-cheng"><a class="zola-anchor" href="#qi-dong-xian-cheng" aria-label="Anchor link for: qi-dong-xian-cheng">🔗</a>
启动线程</h2>
<p>构造了一个线程对象之后，就可以启动该线程对象代表的线程开始执行任务。</p>
<p><code>run()</code>方法里面是需要执行的任务。想要在该线程对象代表的线程中运行该任务，需要调用<code>start()</code>方法。</p>
<p>需要再次澄清一下，<code>Thread</code>对象是存在于创建它的线程中，调用<code>start()</code>方法会启动一个新的线程来运行<code>run()</code>里面的代码。如果直接调用<code>run()</code>方法，只是让当前线程去执行该任务，达不到预期的效果。</p>
<p>由于线程的运行需要操作系统进行调度，所以执行<code>start()</code>方法之后，什么时候执行线程是不可预期的。如果对线程运行的先后顺序有要求，请主动对线程进行同步控制。</p>
<h2 id="xian-cheng-de-sheng-ming-zhou-qi"><a class="zola-anchor" href="#xian-cheng-de-sheng-ming-zhou-qi" aria-label="Anchor link for: xian-cheng-de-sheng-ming-zhou-qi">🔗</a>
线程的生命周期</h2>
<p>当前线程创建了<code>Thread</code>对象，实际的线程还没有被创建，线程对象处于<code>NEW</code>状态。</p>
<p>根据<code>Thread</code>的api说明，一个<code>Thread</code>对象会有6种状态，同一时间该对象只可能处于一种状态。</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#569cd6;">public enum </span><span style="color:#dcdcdc;">State {
</span><span style="color:#dcdcdc;">    </span><span style="color:#b4cea8;">NEW</span><span style="color:#dcdcdc;">,			</span><span style="color:#608b4e;">// 新建状态
</span><span style="color:#dcdcdc;">    </span><span style="color:#b4cea8;">RUNNABLE</span><span style="color:#dcdcdc;">, 		</span><span style="color:#608b4e;">// 运行状态
</span><span style="color:#dcdcdc;">    </span><span style="color:#b4cea8;">BLOCKED</span><span style="color:#dcdcdc;">,		</span><span style="color:#608b4e;">// 阻塞状态
</span><span style="color:#dcdcdc;">    </span><span style="color:#b4cea8;">WAITING</span><span style="color:#dcdcdc;">,		</span><span style="color:#608b4e;">// 无条件的等待状态
</span><span style="color:#dcdcdc;">    </span><span style="color:#b4cea8;">TIMED_WAITING</span><span style="color:#dcdcdc;">, 	</span><span style="color:#608b4e;">// 有条件的等待状态
</span><span style="color:#dcdcdc;">    </span><span style="color:#b4cea8;">TERMINATED</span><span style="color:#dcdcdc;">; 	</span><span style="color:#608b4e;">// 终止状态
</span><span style="color:#dcdcdc;">}
</span></pre>
<p>新建状态表明线程对象还未运行；运行状态表明线程对象正在运行一个线程；阻塞状态表明本线程对象在等待一个锁或同步器；无条件等待状态表明本线程对象在无限期地等待一个条件，比如调用了无过期时间的<code>Object.wait()</code>、<code>Thread.join()</code>等方法；有条件等待状态表明本线程对象在有条件地等待一个条件，是无条件等待状态的过期时间版本（timeout）；终止状态表明本线程对象代表的线程已经结束运行。</p>
<h2 id="zi-ding-yi-xian-cheng-xing-wei"><a class="zola-anchor" href="#zi-ding-yi-xian-cheng-xing-wei" aria-label="Anchor link for: zi-ding-yi-xian-cheng-xing-wei">🔗</a>
自定义线程行为</h2>
<p>前面已经说到，线程执行的任务在<code>run()</code>方法里面。所以，自定义线程就需要自定义该方法。</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#569cd6;">public</span><span style="color:#dcdcdc;"> void run() {
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">if </span><span style="color:#dcdcdc;">(target != </span><span style="color:#569cd6;">null</span><span style="color:#dcdcdc;">) {
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">target.run();
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">}
</span></pre>
<p><code>run()</code>方法的默认实现是去执行构造器里面提供的<code>Runnable</code>对象的<code>run()</code>方法。</p>
<p>所以，有两种方法可以自定义线程。</p>
<ul>
<li>继承<code>Thread</code>类，覆盖<code>run()</code>方法</li>
<li>创建一个<code>Runnable</code>对象并用之构造一个<code>Thread</code>对象</li>
</ul>
<p>这两种方式没有本质上的区别，选择哪一种需要看具体的场合。</p>
<p>值得一提的是，<code>Thread</code>类实现了<code>Runnable</code>接口。</p>
<h2 id="xian-cheng-deng-dai"><a class="zola-anchor" href="#xian-cheng-deng-dai" aria-label="Anchor link for: xian-cheng-deng-dai">🔗</a>
线程等待</h2>
<p>线程的操作系统调度是不可预期的，所以在需要显式地控制线程运行的场合，需要使用额外的方法来达到目的。</p>
<p>比较高级的工具有<code>ReentrantLock</code>、<code>CountDownLatch</code>和<code>Semaphore</code>等，最简单的方法是调用<code>Thread.join()</code>方法。</p>
<p>假如有一个线程对象A，它创建了一个新的线程对象B，然后调用<code>B.start()</code>启动B线程。这时候A线程可以紧接着调用<code>B.join()</code>进入等待状态，知道B线程执行完毕才开始执行A线程。</p>
<p><code>join()</code>方法有多个变体，区别在于是否提供超时时间。如果对线程对象的生命周期还有映像的话，提供了超时时间的<code>join()</code>方法会导致当前线程进入有条件等待状态，反之进入无条件等待状态。</p>
<h2 id="hou-tai-xian-cheng"><a class="zola-anchor" href="#hou-tai-xian-cheng" aria-label="Anchor link for: hou-tai-xian-cheng">🔗</a>
后台线程</h2>
<p>正常情况下，JVM会等待所有的线程都运行结束之后才会退出。通过设置线程为后台线程可以使得JVM不用等待。</p>
<p>当所有运行的线程都是后台线程时，JVM会结束运行。</p>
<p><code>setDaemon()</code>方法用来设置线程为后台线程，<code>isDaemon()</code>方法可以用来检测是否为后台线程。</p>
<p>需要注意的是，<code>setDaemon()</code>方法需要在<code>start()</code>方法被调用之前调用才能生效。</p>
<h2 id="yi-chang-chu-li"><a class="zola-anchor" href="#yi-chang-chu-li" aria-label="Anchor link for: yi-chang-chu-li">🔗</a>
异常处理</h2>
<p>线程执行<code>run()</code>方法的过程中，有可能会遇到未捕获的异常。Java规范规定，JVM在执行线程过程中遇到了未捕获的异常，会主动去寻找该线程对象的未捕获异常处理器，如果没找到就去该线程对象的<code>ThreadGroup</code>对象里找，如果还是没有找到就去找<code>Thread</code>类的静态的未捕获异常处理器。</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#569cd6;">public interface </span><span style="color:#dcdcdc;">UncaughtExceptionHandler {
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">void </span><span style="color:#dcdcdc;">uncaughtException(Thread t, Throwable e);
</span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">private volatile </span><span style="color:#dcdcdc;">UncaughtExceptionHandler uncaughtExceptionHandler;
</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">private static volatile </span><span style="color:#dcdcdc;">UncaughtExceptionHandler defaultUncaughtExceptionHandler;
</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">public static</span><span style="color:#dcdcdc;"> void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) ;
</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">public static </span><span style="color:#dcdcdc;">UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()
</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">public </span><span style="color:#dcdcdc;">UncaughtExceptionHandler getUncaughtExceptionHandler();
</span></pre>
<p>可以通过上面的方法自定义未捕获异常的处理行为。</p>
<h1 id="threadgroup"><a class="zola-anchor" href="#threadgroup" aria-label="Anchor link for: threadgroup">🔗</a>
ThreadGroup</h1>
<p>顾名思义，<code>ThreadGroup</code>类表征了一个线程组。</p>
<p>可以在创建线程对象的时候指定所属的线程组。可以通过线程组对象控制组内的线程。</p>
<p><code>ThreadGroup</code>类比较有用的方法如下：</p>
<ul>
<li>void setDaemon(boolean daemon)</li>
<li>boolean isDaemon()</li>
<li>void setMaxPriority(int pri)</li>
<li>int getMaxPriority()</li>
<li>void interrupt()</li>
<li>void uncaughtException(Thread t, Throwable e)</li>
</ul>
<p>各个方法的含义不言自明，比较有意思的是<code>uncaughtException(Thread, Throwable)</code>方法。如果还记得线程对象的异常处理流程的话，就能明白为什么线程对象本身没有设置未捕获异常处理器时，会到所属的线程组对象里找。</p>
<p>因为<code>ThreadGroup</code>类实现了<code>Thread.UncaughtExceptionHandler</code>接口。<code>ThreadGroup</code>类的<code>uncaughtException(Thread, Throwable)</code>方法实现中，首先委托父线程组对象处理未捕获异常，如果没有父线程组，则跳到<code>Thread</code>类的静态的默认未捕获异常处理器进行处理。</p>
<h1 id="runnable"><a class="zola-anchor" href="#runnable" aria-label="Anchor link for: runnable">🔗</a>
Runnable</h1>
<p><code>Runnable</code>接口很简单。</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#569cd6;">public interface </span><span style="color:#dcdcdc;">Runnable {
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">public abstract void </span><span style="color:#dcdcdc;">run();
</span><span style="color:#dcdcdc;">}
</span></pre>
<p>实际使用中使用<code>Runnable</code>的方式经常是使用匿名内部类。</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#569cd6;">public final class </span><span style="color:#dcdcdc;">RunnableCase {
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">public static void </span><span style="color:#dcdcdc;">main(String </span><span style="color:#569cd6;">[] </span><span style="color:#dcdcdc;">_args) {
</span><span style="color:#dcdcdc;">        </span><span style="color:#569cd6;">final </span><span style="color:#dcdcdc;">Thread echo1 =  </span><span style="color:#569cd6;">new </span><span style="color:#dcdcdc;">Thread(
</span><span style="color:#dcdcdc;">            </span><span style="color:#569cd6;">new </span><span style="color:#dcdcdc;">Runnable() {
</span><span style="color:#dcdcdc;">                </span><span style="color:#569cd6;">public void </span><span style="color:#dcdcdc;">run() {
</span><span style="color:#dcdcdc;">                    </span><span style="color:#569cd6;">for </span><span style="color:#dcdcdc;">(</span><span style="color:#569cd6;">int</span><span style="color:#dcdcdc;"> i = </span><span style="color:#b5cea8;">0</span><span style="color:#dcdcdc;">; i &lt; </span><span style="color:#b5cea8;">1000</span><span style="color:#dcdcdc;">; i</span><span style="color:#569cd6;">++</span><span style="color:#dcdcdc;">) {
</span><span style="color:#dcdcdc;">                        </span><span style="color:#dcdcdc;">System.out.println(Thread.currentThread().getName() + </span><span style="color:#d69d85;">&quot; echos first&quot;</span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">                    </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">                </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">        </span><span style="color:#569cd6;">final </span><span style="color:#dcdcdc;">Thread echo2 =  </span><span style="color:#569cd6;">new </span><span style="color:#dcdcdc;">Thread(
</span><span style="color:#dcdcdc;">            </span><span style="color:#569cd6;">new </span><span style="color:#dcdcdc;">Runnable() {
</span><span style="color:#dcdcdc;">                </span><span style="color:#569cd6;">public void </span><span style="color:#dcdcdc;">run() {
</span><span style="color:#dcdcdc;">                    </span><span style="color:#569cd6;">for </span><span style="color:#dcdcdc;">(</span><span style="color:#569cd6;">int</span><span style="color:#dcdcdc;"> i = </span><span style="color:#b5cea8;">0</span><span style="color:#dcdcdc;">; i &lt; </span><span style="color:#b5cea8;">1000</span><span style="color:#dcdcdc;">; i</span><span style="color:#569cd6;">++</span><span style="color:#dcdcdc;">) {
</span><span style="color:#dcdcdc;">                        </span><span style="color:#dcdcdc;">System.out.println(Thread.currentThread().getName() + </span><span style="color:#d69d85;">&quot; echos second&quot;</span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">                    </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">                </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">System.out.println(</span><span style="color:#d69d85;">&quot;Main thread started!&quot;</span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">echo1.start();
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">echo2.start();
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">joinThread(echo1);
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">joinThread(echo2);
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">System.out.println(</span><span style="color:#d69d85;">&quot;Main thread finished!&quot;</span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">    </span><span style="color:#569cd6;">private static void </span><span style="color:#dcdcdc;">joinThread(</span><span style="color:#569cd6;">final </span><span style="color:#dcdcdc;">Thread th) {
</span><span style="color:#dcdcdc;">        </span><span style="color:#569cd6;">try </span><span style="color:#dcdcdc;">{
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">th.join();
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">} </span><span style="color:#569cd6;">catch </span><span style="color:#dcdcdc;">(InterruptedException e) {
</span><span style="color:#dcdcdc;">            </span><span style="color:#dcdcdc;">System.out.println(th.getName() + </span><span style="color:#d69d85;">&quot; interrupted!&quot;</span><span style="color:#dcdcdc;">);
</span><span style="color:#dcdcdc;">        </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">    </span><span style="color:#dcdcdc;">}
</span><span style="color:#dcdcdc;">}
</span></pre><h1 id="dai-ma-xia-zai"><a class="zola-anchor" href="#dai-ma-xia-zai" aria-label="Anchor link for: dai-ma-xia-zai">🔗</a>
代码下载</h1>
<p><a href="https://www.wangbo.im/posts/2016-04-11-learning-java-concurrency-thread-runnable/RunnableCase.java">RunnableCase.java</a>
<a href="https://www.wangbo.im/posts/2016-04-11-learning-java-concurrency-thread-runnable/ThreadCase.java">ThreadCase.java</a></p>

        </div>
        
    
</div></div>
            
    <div class="pagination">
        <div class="pagination__buttons">
            </div>
    </div>
<footer class="footer">
                    <div class="footer__inner"><div class="copyright copyright--user"><span>© 2019 <a href="https://www.wangbo.im">wangbo&apos; blog</a> :: <a href="https://github.wangbo.im">Github</a> :: Powered by <a href="https://www.getzola.org/">Zola</a></span></div>
    <script type="text/javascript" src="https:&#x2F;&#x2F;www.wangbo.im&#x2F;assets&#x2F;js&#x2F;main.js"></script>
</div>
                    

                </footer></div>
    </body>
</html>
