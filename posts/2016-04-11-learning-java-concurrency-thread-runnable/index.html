<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Learning Java Concurrency - Thread &amp; Runnable</title>
        <style>

    html body {
        font-family: Raleway, sans-serif;
        background-color: white;
    }

    :root {
        --accent: lightseagreen;
        --border-width:  0 ;
    }

</style>


<link rel="stylesheet" href="/css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 


    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

     <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/c&#43;&#43;.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/kotlin.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script> 

    <script>hljs.initHighlightingOnLoad();</script>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.32-DEV" />
        
    </head>

    <body>

        <nav class="navbar navbar-default navbar-fixed-top">

            <div class="container">

                <div class="navbar-header">

                    <a class="navbar-brand visible-xs" href="#">Learning Java Concurrency - Thread &amp; Runnable</a>

                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>

                </div>

                <div class="collapse navbar-collapse">

                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/posts/">Posts</a></li>
                            
                                <li><a href="/categories/">Categories</a></li>
                            
                                <li><a href="/tags/">Tags</a></li>
                            
                        </ul>
                    

                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="https://github.com/wbprime/"><i class="fa fa-github"></i></a></li>
                            
                        </ul>
                    

                </div>

            </div>

        </nav>


<main>

    <div class="item">

    
    
    

    
    

    <h4><a href="/posts/2016-04-11-learning-java-concurrency-thread-runnable/">Learning Java Concurrency - Thread &amp; Runnable</a></h4>
    <h5>April 11, 2016</h5>
     <kbd class="item-tag">java</kbd>  <kbd class="item-tag">concurrency</kbd> 

</div>


    <br> <div class="text-justify">

<p>Java并发多线程的第一课，应该就是<code>Thread</code>了。顾名思义，<code>Thread</code>就是一个线程。线程是很底层的一个概念，在不同的操作系统上实现的模型和细节并不相同，甚至于可以说天差地别；但是总体来说，线程是比进程更细粒度的操作系统调度的单位，线程有自己的运行栈，但是同一个进程的线程共享方法区和堆区数据。</p>

<p>对于进程和线程的差别，有一种说法是：线程是操作系统调度的基本单位，而进程是操作系统分配运行资源的基本单位。</p>

<p>Java中对线程作了很好的封装：<code>Thread</code>类。<code>Thread</code>类的使用非常简单。</p>

<pre><code class="language-java">public class ThreadCase {
    private static class EchoThread extends Thread {
        private final String word;

        public EchoThread(final String word) {
            this.word = word;
        }

        @Override
        public void run() {
            for (int i = 0; i &lt; 1000; i++) {
                System.out.println(this.getName() + &quot; echos &quot; + word);
            }
        }
    }

    public static void main(String [] _args) {
        final Thread echo1 = new EchoThread(&quot;First&quot;);
        final Thread echo2 = new EchoThread(&quot;Second&quot;);

        System.out.println(&quot;Main thread started!&quot;);

        echo1.start();
        echo2.start();

        joinThread(echo1);
        joinThread(echo2);

        System.out.println(&quot;Main thread finished!&quot;);
    }

    private static void joinThread(final Thread th) {
        try {
            th.join();
        } catch (InterruptedException e) {
            System.out.println(th.getName() + &quot; interrupted!&quot;);
        }
    }
}
</code></pre>

<p>可以很明显地发现：</p>

<ul>
<li>main负责启动其他线程，main本身也是一个线程</li>
<li>线程的调度是难以预料的，<code>echo1</code>和<code>echo2</code>的输出结果相互交错可以看出这一点</li>
<li>线程之间可以进行同步控制，使用<code>Thread.join()</code>方法可以强制等待另一个线程结束</li>
<li>自定义线程行为只需要重新实现<code>Thread.run()</code>方法即可</li>
<li>线程的启动入口是<code>Thread.start()</code>方法，不要直接运行<code>Thread.run()</code>方法</li>
<li><code>Thread</code>类是一个<code>class</code>（与<code>interface</code>相对应），意味着自定义线程类不能继承别的父类</li>
</ul>

<!-- More -->

<h1 id="thread">Thread</h1>

<h2 id="api-列表">API 列表</h2>

<ol>
<li>Thread()</li>
<li>Thread(Runnable target)</li>
<li>Thread(Runnable target, AccessControlContext acc)</li>
<li>Thread(ThreadGroup group, Runnable target)</li>
<li>Thread(String name)</li>
<li>Thread(ThreadGroup group, String name)</li>
<li>Thread(Runnable target, String name)</li>
<li>Thread(ThreadGroup group, Runnable target, String name)</li>
<li>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</li>
<li>void start()</li>
<li>void interrupt()</li>
<li>boolean isInterrupted()</li>
<li>boolean isAlive()</li>
<li>State getState()</li>
<li>void run()</li>
<li>void join(long millis)</li>
<li>void join(long millis, int nanos)</li>
<li>void join() throws InterruptedException</li>
<li>static native void sleep(long millis) throws InterruptedException</li>
<li>static void sleep(long millis, int nanos)</li>
<li>void setDaemon(boolean on)</li>
<li>boolean isDaemon()</li>
<li>static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()</li>
<li>static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)</li>
<li>UncaughtExceptionHandler getUncaughtExceptionHandler()</li>
<li>void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)</li>
<li>static native Thread currentThread()</li>
</ol>

<h2 id="创建线程类对象">创建线程类对象</h2>

<p><code>Thread</code>类一共有9个公开的构造函数，咋一看很杂乱无章的，但是其实是有规律的。</p>

<p>考虑以下事实：</p>

<ul>
<li>每个线程应该有一个名字，用来标识自己</li>
<li>每个线程可以有自己的行为，应该有一个用于自定义行为的类<code>Runnable</code></li>
<li>线程应该可以分组，属于某个特定的<code>ThreadGroup</code>实例</li>
<li>线程应该有权限控制，用<code>AccessControlContext</code>来设置</li>
<li>每个线程有自己的栈，应该可以自定义栈的大小</li>
</ul>

<p>这些线程相关的属性相互组合，并添加一些默认值，能够得到的构造函数绝对不止9个，哈！</p>

<p>实际上，以上所有的构造函数都是调用了内部私有的<code>init()</code>方法。</p>

<p>注意：<code>Thread</code>类是一个普通的Java类，所以构造器创建的对象引用是分配在当前的线程。该实例对应的线程还没有被创建。</p>

<h2 id="启动线程">启动线程</h2>

<p>构造了一个线程对象之后，就可以启动该线程对象代表的线程开始执行任务。</p>

<p><code>run()</code>方法里面是需要执行的任务。想要在该线程对象代表的线程中运行该任务，需要调用<code>start()</code>方法。</p>

<p>需要再次澄清一下，<code>Thread</code>对象是存在于创建它的线程中，调用<code>start()</code>方法会启动一个新的线程来运行<code>run()</code>里面的代码。如果直接调用<code>run()</code>方法，只是让当前线程去执行该任务，达不到预期的效果。</p>

<p>由于线程的运行需要操作系统进行调度，所以执行<code>start()</code>方法之后，什么时候执行线程是不可预期的。如果对线程运行的先后顺序有要求，请主动对线程进行同步控制。</p>

<h2 id="线程的生命周期">线程的生命周期</h2>

<p>当前线程创建了<code>Thread</code>对象，实际的线程还没有被创建，线程对象处于<code>NEW</code>状态。</p>

<p>根据<code>Thread</code>的api说明，一个<code>Thread</code>对象会有6种状态，同一时间该对象只可能处于一种状态。</p>

<pre><code class="language-java">public enum State {
    NEW,			// 新建状态
    RUNNABLE, 		// 运行状态
    BLOCKED,		// 阻塞状态
    WAITING,		// 无条件的等待状态
    TIMED_WAITING, 	// 有条件的等待状态
    TERMINATED; 	// 终止状态
}
</code></pre>

<p>新建状态表明线程对象还未运行；运行状态表明线程对象正在运行一个线程；阻塞状态表明本线程对象在等待一个锁或同步器；无条件等待状态表明本线程对象在无限期地等待一个条件，比如调用了无过期时间的<code>Object.wait()</code>、<code>Thread.join()</code>等方法；有条件等待状态表明本线程对象在有条件地等待一个条件，是无条件等待状态的过期时间版本（timeout）；终止状态表明本线程对象代表的线程已经结束运行。</p>

<h2 id="自定义线程行为">自定义线程行为</h2>

<p>前面已经说到，线程执行的任务在<code>run()</code>方法里面。所以，自定义线程就需要自定义该方法。</p>

<pre><code class="language-java">public void run() {
    if (target != null) {
        target.run();
    }
}
</code></pre>

<p><code>run()</code>方法的默认实现是去执行构造器里面提供的<code>Runnable</code>对象的<code>run()</code>方法。</p>

<p>所以，有两种方法可以自定义线程。</p>

<ul>
<li>继承<code>Thread</code>类，覆盖<code>run()</code>方法</li>
<li>创建一个<code>Runnable</code>对象并用之构造一个<code>Thread</code>对象</li>
</ul>

<p>这两种方式没有本质上的区别，选择哪一种需要看具体的场合。</p>

<p>值得一提的是，<code>Thread</code>类实现了<code>Runnable</code>接口。</p>

<h2 id="线程等待">线程等待</h2>

<p>线程的操作系统调度是不可预期的，所以在需要显式地控制线程运行的场合，需要使用额外的方法来达到目的。</p>

<p>比较高级的工具有<code>ReentrantLock</code>、<code>CountDownLatch</code>和<code>Semaphore</code>等，最简单的方法是调用<code>Thread.join()</code>方法。</p>

<p>假如有一个线程对象A，它创建了一个新的线程对象B，然后调用<code>B.start()</code>启动B线程。这时候A线程可以紧接着调用<code>B.join()</code>进入等待状态，知道B线程执行完毕才开始执行A线程。</p>

<p><code>join()</code>方法有多个变体，区别在于是否提供超时时间。如果对线程对象的生命周期还有映像的话，提供了超时时间的<code>join()</code>方法会导致当前线程进入有条件等待状态，反之进入无条件等待状态。</p>

<h2 id="后台线程">后台线程</h2>

<p>正常情况下，JVM会等待所有的线程都运行结束之后才会退出。通过设置线程为后台线程可以使得JVM不用等待。</p>

<p>当所有运行的线程都是后台线程时，JVM会结束运行。</p>

<p><code>setDaemon()</code>方法用来设置线程为后台线程，<code>isDaemon()</code>方法可以用来检测是否为后台线程。</p>

<p>需要注意的是，<code>setDaemon()</code>方法需要在<code>start()</code>方法被调用之前调用才能生效。</p>

<h2 id="异常处理">异常处理</h2>

<p>线程执行<code>run()</code>方法的过程中，有可能会遇到未捕获的异常。Java规范规定，JVM在执行线程过程中遇到了未捕获的异常，会主动去寻找该线程对象的未捕获异常处理器，如果没找到就去该线程对象的<code>ThreadGroup</code>对象里找，如果还是没有找到就去找<code>Thread</code>类的静态的未捕获异常处理器。</p>

<pre><code class="language-java">public interface UncaughtExceptionHandler {
    void uncaughtException(Thread t, Throwable e);
}

private volatile UncaughtExceptionHandler uncaughtExceptionHandler;

private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;

public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) ;

public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()

public UncaughtExceptionHandler getUncaughtExceptionHandler();
</code></pre>

<p>可以通过上面的方法自定义未捕获异常的处理行为。</p>

<h1 id="threadgroup">ThreadGroup</h1>

<p>顾名思义，<code>ThreadGroup</code>类表征了一个线程组。</p>

<p>可以在创建线程对象的时候指定所属的线程组。可以通过线程组对象控制组内的线程。</p>

<p><code>ThreadGroup</code>类比较有用的方法如下：</p>

<ul>
<li>void setDaemon(boolean daemon)</li>
<li>boolean isDaemon()</li>
<li>void setMaxPriority(int pri)</li>
<li>int getMaxPriority()</li>
<li>void interrupt()</li>
<li>void uncaughtException(Thread t, Throwable e)</li>
</ul>

<p>各个方法的含义不言自明，比较有意思的是<code>uncaughtException(Thread, Throwable)</code>方法。如果还记得线程对象的异常处理流程的话，就能明白为什么线程对象本身没有设置未捕获异常处理器时，会到所属的线程组对象里找。</p>

<p>因为<code>ThreadGroup</code>类实现了<code>Thread.UncaughtExceptionHandler</code>接口。<code>ThreadGroup</code>类的<code>uncaughtException(Thread, Throwable)</code>方法实现中，首先委托父线程组对象处理未捕获异常，如果没有父线程组，则跳到<code>Thread</code>类的静态的默认未捕获异常处理器进行处理。</p>

<h1 id="runnable">Runnable</h1>

<p><code>Runnable</code>接口很简单。</p>

<pre><code class="language-java">public interface Runnable {
    public abstract void run();
}
</code></pre>

<p>实际使用中使用<code>Runnable</code>的方式经常是使用匿名内部类。</p>

<pre><code class="language-java">public final class RunnableCase {
    public static void main(String [] _args) {
        final Thread echo1 =  new Thread(
            new Runnable() {
                public void run() {
                    for (int i = 0; i &lt; 1000; i++) {
                        System.out.println(Thread.currentThread().getName() + &quot; echos first&quot;);
                    }
                }
            }
        );

        final Thread echo2 =  new Thread(
            new Runnable() {
                public void run() {
                    for (int i = 0; i &lt; 1000; i++) {
                        System.out.println(Thread.currentThread().getName() + &quot; echos second&quot;);
                    }
                }
            }
        );

        System.out.println(&quot;Main thread started!&quot;);

        echo1.start();
        echo2.start();

        joinThread(echo1);
        joinThread(echo2);

        System.out.println(&quot;Main thread finished!&quot;);
    }

    private static void joinThread(final Thread th) {
        try {
            th.join();
        } catch (InterruptedException e) {
            System.out.println(th.getName() + &quot; interrupted!&quot;);
        }
    }
}
</code></pre>

<h1 id="代码下载">代码下载</h1>

<p><a href="RunnableCase.java">RunnableCase.java</a>
<a href="ThreadCase.java">ThreadCase.java</a></p>
</div>

    
    

    

    

</main>

        <footer>

            <p class="copyright text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a></p>

        </footer>

    </body>

</html>

