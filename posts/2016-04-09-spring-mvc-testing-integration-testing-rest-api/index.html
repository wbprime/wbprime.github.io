<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Spring MVC Integration Testing - REST API</title>
        <style>

    html body {
        font-family: Raleway, sans-serif;
        background-color: white;
    }

    :root {
        --accent: lightseagreen;
        --border-width:  0 ;
    }

</style>


<link rel="stylesheet" href="/css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 


    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

     <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/c&#43;&#43;.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/kotlin.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script> 

    <script>hljs.initHighlightingOnLoad();</script>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.32-DEV" />
        
    </head>

    <body>

        <nav class="navbar navbar-default navbar-fixed-top">

            <div class="container">

                <div class="navbar-header">

                    <a class="navbar-brand visible-xs" href="#">Spring MVC Integration Testing - REST API</a>

                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>

                </div>

                <div class="collapse navbar-collapse">

                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/posts/">Posts</a></li>
                            
                                <li><a href="/categories/">Categories</a></li>
                            
                                <li><a href="/tags/">Tags</a></li>
                            
                        </ul>
                    

                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="https://github.com/wbprime/"><i class="fa fa-github"></i></a></li>
                            
                        </ul>
                    

                </div>

            </div>

        </nav>


<main>

    <div class="item">

    
    
    

    
    

    <h4><a href="/posts/2016-04-09-spring-mvc-testing-integration-testing-rest-api/">Spring MVC Integration Testing - REST API</a></h4>
    <h5>April 9, 2016</h5>
     <kbd class="item-tag">Spring MVC</kbd>  <kbd class="item-tag">testing</kbd>  <kbd class="item-tag">java</kbd> 

</div>


    <br> <div class="text-justify">

<p>本文是 <a href="/2016/04/09/spring-mvc-testing-content/">Spring MVC Testing</a> 集成测试系列的第4篇，原文链接：<a href="http://www.petrikainulainen.net/programming/spring-framework/integration-testing-of-spring-mvc-applications-rest-api-part-one/">Integration Testing of Spring MVC Applications: REST API, Part One</a> 和 <a href="http://www.petrikainulainen.net/programming/spring-framework/integration-testing-of-spring-mvc-applications-rest-api-part-two/">Integration Testing of Spring MVC Applications: REST API, Part Two</a>。</p>

<p>本文主要介绍如何为基于Spring MVC的REST-full的web应用程序添加集成测试。REST服务通过HTTP标准方法的语义（GET/POST/PUT/DELETE等）来隐喻常见的增删改查（CRUD）操作。</p>

<p>本文主要演示如何一步一步地为REST-full API服务添加集成测试用例，包括：</p>

<ul>
<li>获取Todo项列表接口的集成测试</li>
<li>获取单个Todo项接口的集成测试</li>
<li>删除单个Todo项接口的集成测试</li>
<li>添加新Todo项接口的集成测试</li>
<li>更新Todo项接口的集成测试</li>
</ul>

<!-- More -->

<h1 id="示例web应用结构">示例web应用结构</h1>

<h2 id="domain-层">Domain 层</h2>

<p>Domain层有一个Todo的实体类，代码如下：</p>

<pre><code class="language-java">import org.hibernate.annotations.Type;
import org.joda.time.DateTime;
 
import javax.persistence.*;

@Entity
@Table(name=&quot;todos&quot;)
public class Todo {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @Column(name = &quot;creation_time&quot;, nullable = false)
    @Type(type=&quot;org.jadira.usertype.dateandtime.joda.PersistentDateTime&quot;)
    private DateTime creationTime;

    @Column(name = &quot;description&quot;, nullable = true, length = 500)
    private String description;

    @Column(name = &quot;modification_time&quot;, nullable = false)
    @Type(type=&quot;org.jadira.usertype.dateandtime.joda.PersistentDateTime&quot;)
    private DateTime modificationTime;

    @Column(name = &quot;title&quot;, nullable = false, length = 100)
    private String title;

    @Version
    private long version;

    public Todo() {

    }

    //Getters and other methods
}
</code></pre>

<h2 id="service-层">Service 层</h2>

<p>Service层有一个<code>TodoService</code>接口，主要提供了以下个方法：</p>

<ul>
<li><code>Todo deleteById(Long id)</code> 在数据库中删除指定的Todo项；如果指定的Todo项不存在，则抛出<code>TodoNotFoundException</code>异常</li>
<li><code>List&lt;Todo&gt; findAll()</code> 返回所有的Todo项的列表；如果没有Todo项，返回空列表</li>
<li><code>Todo findById(Long id)</code> 返回指定的Todo项；如果指定的Todo项不存在，则抛出<code>TodoNotFoundException</code>异常</li>
<li><code>Todo add(TodoDTO added)</code> 在数据库中添加指定的Todo项</li>
<li><code>Todo update(TodoDTO updated)</code> 在数据库中更新指定的Todo项；如果指定的Todo项不存在，则抛出<code>TodoNotFoundException</code>异常</li>
</ul>

<p>代码如下：</p>

<pre><code class="language-java">public interface TodoService {
 
    public Todo deleteById(Long id) throws TodoNotFoundException;
 
    public List&lt;Todo&gt; findAll();
 
    public Todo findById(Long id) throws TodoNotFoundException;

    public Todo add(TodoDTO added);
 
    public Todo update(TodoDTO updated) throws TodoNotFoundException;
}
</code></pre>

<h2 id="controller-层">Controller 层</h2>

<p>Controller层有一个<code>TodoController</code>类，主要提供json的REST接口以及异常映射机制。</p>

<p>代码如下：</p>

<pre><code class="language-java">import org.springframework.context.MessageSource;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.validation.BeanPropertyBindingResult;
import org.springframework.validation.FieldError;
import org.springframework.validation.Validator;
import org.springframework.web.bind.annotation.*;
 
import javax.annotation.Resource;
import java.util.List;
import java.util.Locale;

@Controller
public class TodoController {
 
    @Resource
    private TodoService service;
 
    @Resource
    private LocaleContextHolderWrapper localeHolderWrapper;
 
    @Resource
    private MessageSource messageSource;

    @RequestMapping(value = &quot;/api/todo/{id}&quot;, method = RequestMethod.DELETE)
    @ResponseBody
    public TodoDTO deleteById(@PathVariable(&quot;id&quot;) Long id) throws TodoNotFoundException {
        Todo deleted = service.deleteById(id);
        return createDTO(deleted);
    }
 
    @RequestMapping(value = &quot;/api/todo&quot;, method = RequestMethod.GET)
    @ResponseBody
    public List&lt;TodoDTO&gt; findAll() {
        List&lt;Todo&gt; models = service.findAll();
        return createDTOs(models);
    }
 
    private List&lt;TodoDTO&gt; createDTOs(List&lt;Todo&gt; models) {
        List&lt;TodoDTO&gt; dtos = new ArrayList&lt;TodoDTO&gt;();
 
        for (Todo model: models) {
            dtos.add(createDTO(model));
        }
 
        return dtos;
    }
 
    @RequestMapping(value = &quot;/api/todo/{id}&quot;, method = RequestMethod.GET)
    @ResponseBody
    public TodoDTO findById(@PathVariable(&quot;id&quot;) Long id) throws TodoNotFoundException {
        Todo found = service.findById(id);
        return createDTO(found);
    }
 
    @RequestMapping(value = &quot;/api/todo&quot;, method = RequestMethod.POST)
    @ResponseBody
    public TodoDTO add(@Valid @RequestBody TodoDTO dto) throws FormValidationError {
        validate(&quot;todo&quot;, dto);
 
        Todo added = service.add(dto);
 
        return createDTO(added);
    }
 
    @RequestMapping(value = &quot;/api/todo/{id}&quot;, method = RequestMethod.PUT)
    @ResponseBody
    public TodoDTO update(
        @Valid @RequestBody TodoDTO dto,
        @PathVariable(&quot;id&quot;) Long todoId
    ) throws TodoNotFoundException, FormValidationError {
 
        Todo updated = service.update(dto);
 
        return createDTO(updated);
    }
 
    private TodoDTO createDTO(Todo model) {
        TodoDTO dto = new TodoDTO();
 
        dto.setId(model.getId());
        dto.setDescription(model.getDescription());
        dto.setTitle(model.getTitle());
 
        return dto;
    }
 
    @ExceptionHandler(FormValidationError.class)
    @ResponseBody
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public FormValidationErrorDTO handleFormValidationError(FormValidationError validationError) {
        Locale current = localeHolderWrapper.getCurrentLocale();
 
        List&lt;FieldError&gt; fieldErrors = validationError.getFieldErrors();
 
        FormValidationErrorDTO dto = new FormValidationErrorDTO();
 
        for (FieldError fieldError: fieldErrors) {
            String[] fieldErrorCodes = fieldError.getCodes();
            for (int index = 0; index &lt; fieldErrorCodes.length; index++) {
                String fieldErrorCode = fieldErrorCodes[index];
 
                String localizedError = messageSource.getMessage(fieldErrorCode, fieldError.getArguments(), current);
                if (localizedError != null &amp;&amp; !localizedError.equals(fieldErrorCode)) {
                    dto.addFieldError(fieldError.getField(), localizedError);
                    break;
                }
                else {
                    if (isLastFieldErrorCode(index, fieldErrorCodes)) {
                        dto.addFieldError(fieldError.getField(), localizedError);
                    }
                }
            }
        }
 
        return dto;
    }
 
    private boolean isLastFieldErrorCode(int index, String[] fieldErrorCodes) {
        return index == fieldErrorCodes.length - 1;
    }
 
    @ExceptionHandler(TodoNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public void handleTodoNotFoundException(TodoNotFoundException ex) {
    }
}
</code></pre>

<h2 id="dto">DTO</h2>

<p>一共添加了3个DTO类，用于向api的调用者传递数据。</p>

<ul>
<li><code>TodoDTO</code>类 用来传递和接收Todo项数据</li>
<li><code>FieldValidationErrorDTO</code>类 用来传递单参数错误提示</li>
<li><code>FormValidationErrorDTO</code>类 用来传递多参数错误提示</li>
</ul>

<h3 id="tododto">TodoDTO</h3>

<p>代码如下：</p>

<pre><code class="language-java">import org.hibernate.validator.constraints.Length;
import org.hibernate.validator.constraints.NotEmpty;
 
public class TodoDTO {
 
    private Long id;
 
    @Length(max = 500)
    private String description;
 
    @NotEmpty
    @Length(max = 100)
    private String title;
 
    public TodoDTO() {
 
    }
 
    //Getters and setters
}
</code></pre>

<h3 id="fieldvalidationerrordto">FieldValidationErrorDTO</h3>

<p>代码如下：</p>

<pre><code class="language-java">public class FieldValidationErrorDTO {
 
    private String path;
    private String message;
 
    public FieldValidationErrorDTO(String path, String message) {
        this.path = path;
        this.message = message;
    }
 
    //Getters
}
</code></pre>

<h3 id="formvalidationerrordto">FormValidationErrorDTO</h3>

<p>代码如下：</p>

<pre><code class="language-java">public class FormValidationErrorDTO {
 
    private List&lt;FieldValidationErrorDTO&gt; fieldErrors = new ArrayList&lt;FieldValidationErrorDTO&gt;();
 
    public FormValidationErrorDTO() {
 
    }
 
    public void addFieldError(String path, String message) {
        FieldValidationErrorDTO fieldError = new FieldValidationErrorDTO(path, message);
        fieldErrors.add(fieldError);
    }
 
    //Getter
}
</code></pre>

<h2 id="exceptions">Exceptions</h2>

<p>一共添加了2个异常类：<code>TodoNotFoundException</code>和<code>FormValidationError</code>。</p>

<p>代码如下：</p>

<pre><code class="language-java">public class TodoNotFoundException extends Exception {
    public TodoNotFoundException(final String message) {
        super(message);
    }
}

public class FormValidationError extends Exception {
 
    private List&lt;FieldError&gt; fieldErrors;
 
    public FormValidationError(List&lt;FieldError&gt; fieldErrors) {
        this.fieldErrors = fieldErrors;
    }
 
    //Getter
}
</code></pre>

<h1 id="编写测试用例">编写测试用例</h1>

<h2 id="get-获取todo项列表">GET 获取Todo项列表</h2>

<p>添加测试用例的思路如下：</p>

<ol>
<li>使用@ExpectedDatabase注解来验证接口没有对数据库表状态产生变化</li>
<li>模拟执行&rdquo;/api/todo&rdquo;的GET请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为200</li>
<li>对返回的响应结果作断言：Content-type的值是”application/json”，并且字符集是”UTF-8”</li>
<li>对返回的响应结果作断言：返回的结果符合预期</li>
</ol>

<p>最终代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.status;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class })
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData.xml&quot;)
    public void findAll() throws Exception {
        mockMvc.perform(get(&quot;/api/todo&quot;))
                .andExpect(status().isOk())
                .andExpect(content().contentType(TestUtil.APPLICATION_JSON_UTF8))
                .andExpect(jsonPath(&quot;$&quot;, hasSize(2)))
                .andExpect(jsonPath(&quot;$[0].id&quot;, is(1)))
                .andExpect(jsonPath(&quot;$[0].description&quot;, is(&quot;Lorem ipsum&quot;)))
                .andExpect(jsonPath(&quot;$[0].title&quot;, is(&quot;Foo&quot;)))
                .andExpect(jsonPath(&quot;$[1].id&quot;, is(2)))
                .andExpect(jsonPath(&quot;$[1].description&quot;, is(&quot;Lorem ipsum&quot;)))
                .andExpect(jsonPath(&quot;$[1].title&quot;, is(&quot;Bar&quot;)));
    }
}
</code></pre>

<p>使用的<code>toDoData.xml</code>文件的内容如下：</p>

<pre><code class="language-xml">&lt;dataset&gt;
    &lt;todos id=&quot;1&quot; creation_time=&quot;2012-10-21 11:13:28&quot; description=&quot;Lorem ipsum&quot; modification_time=&quot;2012-10-21 11:13:28&quot; title=&quot;Foo&quot; version=&quot;0&quot;/&gt;
    &lt;todos id=&quot;2&quot; creation_time=&quot;2012-10-21 11:13:28&quot; description=&quot;Lorem ipsum&quot; modification_time=&quot;2012-10-21 11:13:28&quot; title=&quot;Bar&quot; version=&quot;0&quot;/&gt;
&lt;/dataset&gt;
</code></pre>

<h2 id="get-获取单个todo项">GET 获取单个Todo项</h2>

<p>根据参数的不同，获取单个Todo项详情接口会有不同的返回结果：</p>

<ul>
<li>如果指定id的Todo项存在，返回单个Todo项</li>
<li>如果指定id的Todo项不存在，返回404</li>
</ul>

<p>下面来分别编写测试用例。</p>

<h3 id="指定的todo项存在">指定的Todo项存在</h3>

<p>添加测试用例的思路如下：</p>

<ol>
<li>使用@ExpectedDatabase注解来验证接口没有对数据库表状态产生变化</li>
<li>模拟执行&rdquo;/api/todo/1&rdquo;的GET请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为200</li>
<li>对返回的响应结果作断言：Content-type的值是”application/json”，并且字符集是”UTF-8”</li>
<li>对返回的响应结果作断言：返回的结果符合预期</li>
</ol>

<p>最终代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.status;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class })
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData.xml&quot;)
    public void findById() throws Exception {
        mockMvc.perform(get(&quot;/api/todo/{id}&quot;, 1L))
                .andExpect(status().isOk())
                .andExpect(content().contentType(TestUtil.APPLICATION_JSON_UTF8))
                .andExpect(jsonPath(&quot;$.id&quot;, is(1)))
                .andExpect(jsonPath(&quot;$.description&quot;, is(&quot;Lorem ipsum&quot;)))
                .andExpect(jsonPath(&quot;$.title&quot;, is(&quot;Foo&quot;)));
    }
}
</code></pre>

<h3 id="指定的todo项不存在">指定的Todo项不存在</h3>

<p>添加测试用例的思路如下：</p>

<ol>
<li>使用@ExpectedDatabase注解来验证接口没有对数据库表状态产生变化</li>
<li>模拟执行&rdquo;/api/todo/3&rdquo;的GET请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为404</li>
</ol>

<p>最终代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.status;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class })
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData.xml&quot;)
    public void findByIdWhenTodoIsNotFound() throws Exception {
        mockMvc.perform(get(&quot;/api/todo/{id}&quot;, 3L))
                .andExpect(status().isNotFound());
    }
}
</code></pre>

<h2 id="delete-删除指定的todo项">DELETE 删除指定的Todo项</h2>

<p>根据参数的不同，删除指定Todo项接口会有不同的返回结果：</p>

<ul>
<li>如果指定id的Todo项存在，则删除之并返该结果</li>
<li>如果指定id的Todo项不存在，返回404</li>
</ul>

<p>下面来分别编写测试用例。</p>

<h3 id="指定的todo项存在-1">指定的Todo项存在</h3>

<p>添加测试用例的思路如下：</p>

<ol>
<li>使用@ExpectedDatabase注解来验证接口对数据库的操作符合预期</li>
<li>模拟执行&rdquo;/api/todo/1&rdquo;的DELETE请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为200</li>
<li>对返回的响应结果作断言：Content-type的值是”application/json”，并且字符集是”UTF-8”</li>
<li>对返回的响应结果作断言：返回的结果符合预期</li>
</ol>

<p>最终代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.status;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class})
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData-delete-expected.xml&quot;)
    public void deleteById() throws Exception {
        mockMvc.perform(delete(&quot;/api/todo/{id}&quot;, 1L))
                .andExpect(status().isOk())
                .andExpect(content().contentType(TestUtil.APPLICATION_JSON_UTF8))
                .andExpect(jsonPath(&quot;$.id&quot;, is(1)))
                .andExpect(jsonPath(&quot;$.description&quot;, is(&quot;Lorem ipsum&quot;)))
                .andExpect(jsonPath(&quot;$.title&quot;, is(&quot;Foo&quot;)));
    }
}
</code></pre>

<p>作为对照，<code>todoData-delete-expected.xml</code>文件包含了预期的数据库表结果，内容如下：</p>

<pre><code class="language-xml">&lt;dataset&gt;
    &lt;todos id=&quot;2&quot; creation_time=&quot;2012-10-21 11:13:28&quot; description=&quot;Lorem ipsum&quot; modification_time=&quot;2012-10-21 11:13:28&quot; title=&quot;Bar&quot; version=&quot;0&quot;/&gt;
&lt;/dataset&gt;
</code></pre>

<h3 id="指定的todo项不存在-1">指定的Todo项不存在</h3>

<p>添加测试用例的思路如下：</p>

<ol>
<li>使用@ExpectedDatabase注解来验证接口没有对数据库表状态产生变化</li>
<li>模拟执行&rdquo;/api/todo/3&rdquo;的DELETE请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为404</li>
</ol>

<p>最终代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.status;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class})
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData.xml&quot;)
    public void deleteByIdWhenTodoIsNotFound() throws Exception {
        mockMvc.perform(delete(&quot;/api/todo/{id}&quot;, 3L))
                .andExpect(status().isNotFound());
    }
}
</code></pre>

<h2 id="post-添加todo项">POST 添加Todo项</h2>

<p>根据参数的不同，添加指定Todo项接口会有不同的返回结果：</p>

<ul>
<li>Todo项为空，添加失败，返回错误提示</li>
<li>Todo项的title/description字段值长度不合法，添加失败，返回错误提示</li>
<li>Todo项各个字段都合法，添加成功，返回该项</li>
</ul>

<p>下面来分别编写测试用例。</p>

<h3 id="指定的todo项字段为空">指定的Todo项字段为空</h3>

<p>添加测试用例的思路如下：</p>

<ol>
<li>使用@ExpectedDatabase注解来验证接口没有对数据库表状态产生变化</li>
<li>模拟执行&rdquo;/api/todo&rdquo;的POST请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为400</li>
<li>对返回的响应结果作断言：Content-type的值是”application/json”，并且字符集是”UTF-8”</li>
<li>对返回的响应结果作断言：返回了预期的错误说明</li>
</ol>

<p>最终代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.status;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class})
@DatabaseSetup(toDoData.xml)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData.xml&quot;)
    public void addEmptyTodo() throws Exception {
        TodoDTO added = TodoTestUtil.createDTO(null, &quot;&quot;, &quot;&quot;);
        mockMvc.perform(post(/api/todo)
                .contentType(IntegrationTestUtil.APPLICATION_JSON_UTF8)
                .body(IntegrationTestUtil.convertObjectToJsonBytes(added))
        )
                .andExpect(status().isBadRequest())
                .andExpect(content().contentType(TestUtil.APPLICATION_JSON_UTF8))
                .andExpect(jsonPath(&quot;$.fieldErrors[0]&quot;, is(&quot;title&quot;)));
    }
}
</code></pre>

<h3 id="指定的todo项包含不合法字段">指定的Todo项包含不合法字段</h3>

<p>添加测试用例的思路如下：</p>

<ol>
<li>使用@ExpectedDatabase注解来验证接口没有对数据库表状态产生变化</li>
<li>模拟执行&rdquo;/api/todo&rdquo;的POST请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为400</li>
<li>对返回的响应结果作断言：Content-type的值是”application/json”，并且字符集是”UTF-8”</li>
<li>对返回的响应结果作断言：返回了预期的错误说明</li>
</ol>

<p>最终代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.status;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class})
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData.xml&quot;)
    public void addTodoWhenTitleAndDescriptionAreTooLong() throws Exception {
        String title = TodoTestUtil.createStringWithLength(101);
        String description = TodoTestUtil.createStringWithLength(501);
        TodoDTO added = TodoTestUtil.createDTO(null, description, title);
 
        mockMvc.perform(post(&quot;/api/todo&quot;)
                .contentType(IntegrationTestUtil.APPLICATION_JSON_UTF8)
                .body(IntegrationTestUtil.convertObjectToJsonBytes(added))
        )
                .andExpect(status().isBadRequest())
                .andExpect(content().contentType(TestUtil.APPLICATION_JSON_UTF8))
                .andExpect(jsonPath(&quot;$.fieldErrors&quot;, hasSize(2)))
                .andExpect(
                    jsonPath(
                        &quot;$.fieldErrors[*].path&quot;, containsInAnyOrder(&quot;title&quot;, &quot;description&quot;)
                    )
                )
                .andExpect(jsonPath(&quot;$.fieldErrors[*].message&quot;, containsInAnyOrder(
                        &quot;The maximum length of the description is 500 characters.&quot;,
                        &quot;The maximum length of the title is 100 characters.&quot;
                )));
    }
}
</code></pre>

<h3 id="添加todo项成功">添加Todo项成功</h3>

<p>添加测试用例的思路如下：</p>

<ol>
<li>使用@ExpectedDatabase注解来验证接口往数据库中写入了一条记录</li>
<li>模拟执行&rdquo;/api/todo&rdquo;的POST请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为200</li>
<li>对返回的响应结果作断言：Content-type的值是”application/json”，并且字符集是”UTF-8”</li>
<li>对返回的响应结果作断言：返回的结果符合预期</li>
</ol>

<p>最终代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import com.github.springtestdbunit.assertion.DatabaseAssertionMode;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.status;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class})
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(value=&quot;toDoData-add-expected.xml&quot;, assertionMode = DatabaseAssertionMode.NON_STRICT)
    public void add() throws Exception {
        TodoDTO added = TodoTestUtil.createDTO(null, &quot;description&quot;, &quot;title&quot;);
        mockMvc.perform(post(&quot;/api/todo&quot;)
                .contentType(IntegrationTestUtil.APPLICATION_JSON_UTF8)
                .body(IntegrationTestUtil.convertObjectToJsonBytes(added))
        )
                .andExpect(status().isOk())
                .andExpect(content().contentType(TestUtil.APPLICATION_JSON_UTF8))
                .andExpect(jsonPath(&quot;$.id&quot;, is(3)))
                .andExpect(jsonPath(&quot;$.description&quot;, is(&quot;description&quot;)))
                .andExpect(jsonPath(&quot;$.title&quot;, is(&quot;title&quot;)));
    }
}
</code></pre>

<p>使用到的<code>toDoData-add-expected.xml</code>文件的内容如下：</p>

<pre><code class="language-xml">&lt;dataset&gt;
    &lt;todos id=&quot;1&quot; description=&quot;Lorem ipsum&quot; title=&quot;Foo&quot; version=&quot;0&quot;/&gt;
    &lt;todos id=&quot;2&quot; description=&quot;Lorem ipsum&quot; title=&quot;Bar&quot; version=&quot;0&quot;/&gt;
    &lt;todos id=&quot;3&quot; description=&quot;description&quot; title=&quot;title&quot; version=&quot;0&quot;/&gt;
&lt;/dataset&gt;
</code></pre>

<h2 id="put-修改todo项">PUT 修改Todo项</h2>

<p>根据参数的不同，添加指定Todo项接口会有不同的返回结果：</p>

<ul>
<li>指定的Todo项为空，修改失败，返回错误信息</li>
<li>指定的Todo项参数不合法，修改失败，返回错误信息</li>
<li>指定的Todo项被正确修改，返回修改后的结果</li>
<li>指定的Todo项不存在，修改失败</li>
</ul>

<p>下面来分别编写测试用例。</p>

<h3 id="指定的todo项字段为空-1">指定的Todo项字段为空</h3>

<p>添加测试用例的思路如下：</p>

<ol>
<li>使用@ExpectedDatabase注解来验证接口没有对数据库表状态产生变化</li>
<li>模拟执行&rdquo;/api/todo/1&rdquo;的PUT请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为400</li>
<li>对返回的响应结果作断言：Content-type的值是”application/json”，并且字符集是”UTF-8”</li>
<li>对返回的响应结果作断言：返回了预期的错误说明</li>
</ol>

<p>最终代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import com.github.springtestdbunit.assertion.DatabaseAssertionMode;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.status;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class})
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData.xml&quot;)
    public void updateEmptyTodo() throws Exception {
        TodoDTO updated = TodoTestUtil.createDTO(1L, &quot;&quot;, &quot;&quot;);
 
        mockMvc.perform(put(&quot;/api/todo/{id}&quot;, 1L)
                .contentType(IntegrationTestUtil.APPLICATION_JSON_UTF8)
                .body(IntegrationTestUtil.convertObjectToJsonBytes(updated))
        )
                .andExpect(status().isBadRequest())
                .andExpect(content().mimeType(IntegrationTestUtil.APPLICATION_JSON_UTF8))
                .andExpect(content().string(&quot;{\&quot;fieldErrors\&quot;:[{\&quot;path\&quot;:\&quot;title\&quot;,\&quot;message\&quot;:\&quot;The title cannot be empty.\&quot;}]}&quot;));
    }
}
</code></pre>

<h3 id="指定的todo项包含不合法字段-1">指定的Todo项包含不合法字段</h3>

<p>添加测试用例的思路如下：</p>

<ol>
<li>使用@ExpectedDatabase注解来验证接口没有对数据库表状态产生变化</li>
<li>模拟执行&rdquo;/api/todo/1&rdquo;的PUT请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为400</li>
<li>对返回的响应结果作断言：Content-type的值是”application/json”，并且字符集是”UTF-8”</li>
<li>对返回的响应结果作断言：返回了预期的错误说明</li>
</ol>

<p>最终代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import com.github.springtestdbunit.assertion.DatabaseAssertionMode;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.status;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class})
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData.xml&quot;)
    public void updateTodoWhenTitleAndDescriptionAreTooLong() throws Exception {
        String title = TodoTestUtil.createStringWithLength(101);
        String description = TodoTestUtil.createStringWithLength(501);
 
        TodoDTO updated = TodoTestUtil.createDTO(1L, description, title);
 
        mockMvc.perform(put(&quot;/api/todo/{id}&quot;, 1L)
                .contentType(IntegrationTestUtil.APPLICATION_JSON_UTF8)
                .body(IntegrationTestUtil.convertObjectToJsonBytes(updated))
        )
                .andExpect(status().isBadRequest())
                .andExpect(content().mimeType(IntegrationTestUtil.APPLICATION_JSON_UTF8))
                .andExpect(content().string(startsWith(&quot;{\&quot;fieldErrors\&quot;:[&quot;)))
                .andExpect(content().string(allOf(
                        containsString(&quot;{\&quot;path\&quot;:\&quot;description\&quot;,\&quot;message\&quot;:\&quot;The maximum length of the description is 500 characters.\&quot;}&quot;),
                        containsString(&quot;{\&quot;path\&quot;:\&quot;title\&quot;,\&quot;message\&quot;:\&quot;The maximum length of the title is 100 characters.\&quot;}&quot;)
                )))
                .andExpect(content().string(endsWith(&quot;]}&quot;)));
    }
}
</code></pre>

<h3 id="指定的todo项不存在-2">指定的Todo项不存在</h3>

<p>添加测试用例的思路如下：</p>

<ol>
<li>使用@ExpectedDatabase注解来验证接口没有对数据库表状态产生变化</li>
<li>模拟执行&rdquo;/api/todo/3&rdquo;的PUT请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为404</li>
</ol>

<p>最终代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.status;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class})
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(&quot;toDoData.xml&quot;)
    public void updateTodoWhenTodoIsNotFound() throws Exception {
        TodoDTO updated = TodoTestUtil.createDTO(3L, &quot;description&quot;, &quot;title&quot;);
 
        mockMvc.perform(put(&quot;/api/todo/{id}&quot;, 3L)
                .contentType(IntegrationTestUtil.APPLICATION_JSON_UTF8)
                .body(IntegrationTestUtil.convertObjectToJsonBytes(updated))
        )
                .andExpect(status().isNotFound());
    }
}
</code></pre>

<h3 id="指定的todo项存在-2">指定的Todo项存在</h3>

<p>添加测试用例的思路如下：</p>

<ol>
<li>使用@ExpectedDatabase注解来验证接口对数据库的修改符合预期</li>
<li>模拟执行&rdquo;/api/todo/1&rdquo;的PUT请求，并取得返回的响应结果</li>
<li>对返回的响应结果作断言：HTTP状态码为200</li>
<li>对返回的响应结果作断言：Content-type的值是”application/json”，并且字符集是”UTF-8”</li>
<li>对返回的响应结果作断言：返回的结果符合预期</li>
</ol>

<p>最终代码如下：</p>

<pre><code class="language-java">import com.github.springtestdbunit.DbUnitTestExecutionListener;
import com.github.springtestdbunit.annotation.DatabaseSetup;
import com.github.springtestdbunit.annotation.ExpectedDatabase;
import com.github.springtestdbunit.assertion.DatabaseAssertionMode;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
import org.springframework.test.context.support.DirtiesContextTestExecutionListener;
import org.springframework.test.context.transaction.TransactionalTestExecutionListener;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.samples.context.WebContextLoader;
 
import static org.springframework.test.web.server.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.server.result.MockMvcResultMatchers.status;
 
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = WebContextLoader.class, classes = {ExampleApplicationContext.class})
@TestExecutionListeners({DependencyInjectionTestExecutionListener.class,
        DirtiesContextTestExecutionListener.class,
        TransactionalTestExecutionListener.class,
        DbUnitTestExecutionListener.class})
@DatabaseSetup(&quot;toDoData.xml&quot;)
public class ITTodoControllerTest {
 
    //Add web application context here
 
    private MockMvc mockMvc;
 
    //Add setUp() method here
 
    @Test
    @ExpectedDatabase(value=&quot;toDoData-update-expected.xml&quot;, assertionMode = DatabaseAssertionMode.NON_STRICT)
    public void update() throws Exception {
        TodoDTO updated = TodoTestUtil.createDTO(1L, &quot;description&quot;, &quot;title&quot;);
 
        mockMvc.perform(put(&quot;/api/todo/{id}&quot;, 1L)
                .contentType(IntegrationTestUtil.APPLICATION_JSON_UTF8)
                .body(IntegrationTestUtil.convertObjectToJsonBytes(updated))
        )
                .andExpect(status().isOk())
                .andExpect(content().mimeType(IntegrationTestUtil.APPLICATION_JSON_UTF8))
                .andExpect(content().string(&quot;{\&quot;id\&quot;:1,\&quot;description\&quot;:\&quot;description\&quot;,\&quot;title\&quot;:\&quot;title\&quot;}&quot;));
    }
}
</code></pre>

<p>代码中使用到的<code>toDoData-update-expected.xml</code>文件内容如下：</p>

<pre><code class="language-xml">&lt;dataset&gt;
    &lt;todos id=&quot;1&quot; description=&quot;description&quot; title=&quot;title&quot; version=&quot;1&quot;/&gt;
    &lt;todos id=&quot;2&quot; description=&quot;Lorem ipsum&quot; title=&quot;Bar&quot; version=&quot;0&quot;/&gt;
&lt;/dataset&gt;
</code></pre>

<h1 id="总结">总结</h1>

<p>本文的要点如下：</p>

<ul>
<li>如何对GET接口进行集成测试</li>
<li>如何对POST接口进行集成测试</li>
<li>如何对PUT接口进行集成测试</li>
<li>如何对DELETE接口进行集成测试</li>
</ul>

<p>下一篇是 <a href="/2016/04/09/spring-mvc-testing-integration-testing-security/">Spring MVC Integration Testing - Security</a>。</p>
</div>

    
    

    

    

</main>

        <footer>

            <p class="copyright text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a></p>

        </footer>

    </body>

</html>

