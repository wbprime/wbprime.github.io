<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Learning Java Concurrency - FutureTask &amp; Callable</title>
        <style>

    html body {
        font-family: Raleway, sans-serif;
        background-color: white;
    }

    :root {
        --accent: lightseagreen;
        --border-width:  0 ;
    }

</style>


<link rel="stylesheet" href="/css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 


    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

     <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/c&#43;&#43;.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/kotlin.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js"></script>  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script> 

    <script>hljs.initHighlightingOnLoad();</script>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.49" />
        
    </head>

    <body>

        <nav class="navbar navbar-default navbar-fixed-top">

            <div class="container">

                <div class="navbar-header">

                    <a class="navbar-brand visible-xs" href="#">Learning Java Concurrency - FutureTask &amp; Callable</a>

                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>

                </div>

                <div class="collapse navbar-collapse">

                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/posts/">Posts</a></li>
                            
                                <li><a href="/categories/">Categories</a></li>
                            
                                <li><a href="/tags/">Tags</a></li>
                            
                        </ul>
                    

                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="https://github.com/wbprime/"><i class="fa fa-github"></i></a></li>
                            
                        </ul>
                    

                </div>

            </div>

        </nav>


<main>

    <div class="item">

    
    
    

    
    

    <h4><a href="/posts/2016-04-13-learning-java-concurrency-futuretask-callable/">Learning Java Concurrency - FutureTask &amp; Callable</a></h4>
    <h5>April 13, 2016</h5>
     <kbd class="item-tag">java</kbd>  <kbd class="item-tag">concurrency</kbd> 

</div>


    <br> <div class="text-justify">

<p>Java的<code>java.util.concurrent</code>包里面提供了多线程并发和同步的支持。</p>

<p>最开始的时候，多线程被认为是执行任务的手段，也就是说，我启动一个新线程来执行代码，至于资源共享、线程同步等可以用锁、同步器等解决。所以<code>Thread</code>类和<code>Rannable</code>接口暴露了一个<code>void run()</code>方法来提供自定义行为。</p>

<p>但慢慢地，人们开始发现如果自定义的线程是计算结果的，那我怎么来拿到计算之后的结果呢？另外，我得知道什么时候计算结束了，如果计算的时间太长了，我也想能够终止计算线程的执行。这些需求其实用基本的多线程工具也可以实现，但是过程比较繁琐；而且这些需求有一段时间又特别普遍。终于，jdk 1.5开始引入了<code>Callable</code>接口和<code>Future</code>接口，用于支援有返回值的计算任务。</p>

<!-- More -->

<h1 id="callable">Callable</h1>

<p><code>Callable</code>接口和<code>Runnable</code>接口很接近，有多接近呢？对比一下代码就知道了。</p>

<p>这是<code>Runnable</code>的代码：</p>

<pre><code class="language-java">public interface Runnable {
    public abstract void run();
}
</code></pre>

<p>这是<code>Callable</code>的接口：</p>

<pre><code class="language-java">public interface Callable&lt;V&gt; {
    V call() throws Exception;
}
</code></pre>

<p>可以看到，<code>Callable</code>接口比<code>Runnable</code>接口多了两个功能：</p>

<ul>
<li>方法可以有返回值</li>
<li>方法可以抛出Checked异常</li>
</ul>

<p>添加返回值就是为了支援计算类的任务；可以抛出Checked异常则是为了完善错误处理机制。</p>

<p>Thread/Runnable 机制是不允许抛出Checked异常的；如果抛出了Unchecked异常，会自动去寻找线程的异常处理器进行处理，参见 <a href="/2016/04/11/learning-java-concurrency-thread-runnable/">Learning Java Concurrency - Thread &amp; Runnable</a> 里面关于线程异常处理的部分。</p>

<h1 id="future">Future</h1>

<p><code>Future</code>接口封装了异步计算的结果，用于在异步任务完成之后获取结果。</p>

<p>接口的方法如下：</p>

<pre><code class="language-java">public interface Future&lt;V&gt; {
    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();

    V get() throws InterruptedException, ExecutionException;

    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre>

<p><code>get()</code>方法用于获取异步任务的结果。如果异步任务还没有结束，该方法的调用会被阻塞，一直到异步任务运行结束（正常结束或者抛出异常），或者异步任务线程被中断。如果异步任务线程被中断，该方法抛出<code>InterruptedException</code>异常；如果异步任务执行抛出异常，该方法抛出<code>ExecutionException</code>异常。</p>

<p><code>get(long, TimeUnit)</code>方法同上，添加了过期时间的设置：当在指定时间内异步任务没有执行完毕，该方法抛出<code>TimeoutException</code>异常。</p>

<p>除了获取异步任务计算结果的方法之外，<code>Future</code>接口还提供了判断异步任务状态的方法和取消任务的方法。</p>

<p><code>isDone()</code>方法返回异步任务是否结束。异步任务正常、异常结束，异步任务被手动取消，都被认为是结束（Done）。</p>

<p><code>isCancelled()</code>方法返回异步任务是否被取消。</p>

<p><code>cancle(boolean mayInterruptIfRunning)</code>方法用于取消异步任务。顾名思义，如果异步任务已经运行完毕了，当然没法再取消了，该方法会返回失败；同理，一个已经被取消了的异步任务，该方法也会返回失败。对于正在执行的任务，该方法会根据<code>mayInterruptIfRunning</code>参数的值去判断是否需要中断异步线程。对于未开始执行的任务，调用该方法之后，任务永远不会再运行。</p>

<h1 id="callable-future-的使用">Callable &amp; Future 的使用</h1>

<p>因为<code>Thread</code>类并不支持直接使用<code>Callable</code>接口，所以JUC在<code>ExecutorService</code>框架中提供了使用<code>Callable</code>和<code>Future</code>的入口。</p>

<pre><code class="language-java">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
</code></pre>

<p>使用方法很简单：自定义一个<code>Callable</code>接口的实现，然后提交给<code>ExecutorService</code>实例，然后调用<code>Future.get()</code>等待异步任务运行结束并获取结果就好了。当然，如果任务运行期间等不及的话，也可以取消任务。</p>

<pre><code class="language-java">public class CallableFutureCase {
    private static class SumupTask implements Callable&lt;Long&gt; {
        private final int val_;

        public SumupTask(final int val) {
            this.val_ = val;
        }

        public Long call() throws Exception {
            long result = 0;
            for (int i = 1; i &lt;= val_; i++) {
                result = result + i;
            }

            return Long.valueOf(result);
        }
    }

    public static void main(String [] _args) {
        final ExecutorService executor = Executors.newCachedThreadPool();

        final Future&lt;Long&gt; result = executor.submit(new SumupTask(10000));

        System.out.println(&quot;Main thread started!&quot;);

        try {
            final Long longResult = result.get();
            System.out.println(&quot;Result is &quot; + longResult);
        } catch (InterruptedException e) {
            // do nothing
        } catch (ExecutionException e) {
            // do nothing
        }

        System.out.println(&quot;Main thread finished!&quot;);

        executor.shutdown();
    }
}
</code></pre>

<h1 id="futuretask">FutureTask</h1>

<p>然而，既然已经设计了<code>Callable</code>接口和<code>Future</code>接口，却不能直接与<code>Thread</code>类一起使用，感觉有点心里不是滋味。所以有人设计了一个<code>FutureTask</code>类。</p>

<pre><code class="language-java">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {}

public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {}
</code></pre>

<p>因为<code>FutureTask</code>实现了<code>Runnable</code>接口，所以可以与<code>Thread</code>类配合使用；又因为<code>FutureTask</code>实现了<code>Future</code>接口，所以可以控制任务的状态以及获取任务执行结果。</p>

<p><code>FutureTask</code>类有两个构造方法：</p>

<ul>
<li>public FutureTask(Callable<V> callable)</li>
<li>public FutureTask(Runnable runnable, V result)</li>
</ul>

<p>可以通过实例来看一下<code>FutureTask</code>类实际使用。</p>

<h2 id="futuretask-by-callable">FutureTask by Callable</h2>

<pre><code class="language-java">public class FutureTaskCase {
    private static class CallableMax implements Callable&lt;Integer&gt; {
        private final List&lt;Integer&gt; list_;

        public CallableMax(final List&lt;Integer&gt; list) {
            this.list_ = list;
        }

        public Integer call() throws Exception {
            if (null != list_ &amp;&amp; !list_.isEmpty()) {
                int result = list_.get(0).intValue();
                for (final Integer val: list_) {
                    if (result &lt; val.intValue()) {
                        result = val.intValue();
                    }

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        // do nothing
                    }
                }
                return Integer.valueOf(result);
            } else {
                return null;
            }
        }
    }

    public static void main(String [] _args) {
        final List&lt;Integer&gt; list = ImmutableList.of(
            1, 199, 6, 3, 56, 299, 199, 28, 10, 234
        );

        final FutureTask&lt;Integer&gt; task1 = new FutureTask(new CallableMax(list));

        final Thread task1Thread = new Thread(task1);
        task1Thread.start();

        System.out.println(&quot;Main thread started!&quot;);

        try {
            final Integer re1 = task1.get();
            System.out.println(&quot;Result is &quot; + re1);
        } catch (InterruptedException e) {
            // do nothing
        } catch (ExecutionException e) {
            // do nothing
        }

        System.out.println(&quot;Main thread finished!&quot;);
    }
}
</code></pre>

<p>使用<code>Callable</code>实例去构造<code>FutureTask</code>类实例时，因为结果是<code>call()</code>方法直接返回的，所以用法比较简单。但是使用<code>Runnable</code>实例去构造<code>FutureTask</code>实例时，因为<code>run()</code>方法不能返回结果，所以要提供一个共享变量用来作为容器接受<code>run()</code>方法处理的结果，同时传递结果给调用线程。注意，使用<code>Runnable</code>方式时，共享的变量需要是一个可变的对象，不可遍对象类如<code>String</code>、<code>Integer</code>等需要提供一个包装类。</p>

<h2 id="futuretask-by-runnable">FutureTask by Runnable</h2>

<pre><code class="language-java">public class FutureTaskCase {
    private static class ValueHolder {
        Integer value;
    }

    private static class RunnableMax implements Runnable {
        private final List&lt;Integer&gt; list_;
        private final ValueHolder holder;

        public RunnableMax(
            final List&lt;Integer&gt; list, final ValueHolder valueHolder
        ) {
            this.list_ = list;
            this.holder = valueHolder;
        }

        public void run() {
            if (null == holder) return ;

            if (null != list_ &amp;&amp; !list_.isEmpty()) {
                int result = list_.get(0).intValue();
                for (final Integer val : list_) {
                    if (result &lt; val.intValue()) {
                        result = val.intValue();
                    }

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        // do nothing
                    }
                }

                holder.value = Integer.valueOf(result);
            } else {
                holder.value = null;
            }
        }
    }

    public static void main(String [] _args) {
        final List&lt;Integer&gt; list = ImmutableList.of(
            1, 199, 6, 3, 56, 299, 199, 28, 10, 234
        );

        final ValueHolder holder = new ValueHolder();
        final FutureTask&lt;ValueHolder&gt; task2 = new FutureTask(
            new RunnableMax(list, holder),
            holder
        );

        final Thread task2Thread = new Thread(task2);
        task2Thread.start();

        System.out.println(&quot;Main thread started!&quot;);

        try {
            final ValueHolder re2 = task2.get();
            System.out.println(&quot;Result is &quot; + re2.value);
        } catch (InterruptedException e) {
            // do nothing
        } catch (ExecutionException e) {
            // do nothing
        }

        System.out.println(&quot;Main thread finished!&quot;);
    }
}
</code></pre>

<p>代码中使用了<code>ValueHolder</code>来保存<code>run()</code>计算的结果并传递给<code>Future.get()</code>返回调用线程。</p>

<p>为什么要使用这种方式呢？我们来看一下<code>FutureTask</code>的对应代码。</p>

<pre><code class="language-java">public FutureTask(Runnable runnable, V result) {
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
}
</code></pre>

<p>该构造器调用了<code>Executors.callable()</code>方法。</p>

<pre><code class="language-java">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) {
    if (task == null)
        throw new NullPointerException();
    return new RunnableAdapter&lt;T&gt;(task, result);
}
</code></pre>

<p><code>Executors.callable()</code>方法用一个<code>RunnableAdapter</code>类对传入的参数进行了包装。</p>

<pre><code class="language-java">static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; {
    final Runnable task;
    final T result;
    RunnableAdapter(Runnable task, T result) {
        this.task = task;
        this.result = result;
    }
    public T call() {
        task.run();
        return result;
    }
}
</code></pre>

<p>在包装类<code>RunnableAdapter</code>内部简单地保存了<code>Runnable</code>实例和目标类型对象。可以理解为，<code>T</code>类型的对象负责记录任务结果，而<code>Runnable</code>实例的<code>run()</code>方法在执行过程中修改该对象的值。如果<code>T</code>是一个不可变对象，则<code>run()</code>方法中的修改传递不到外部来。</p>

<p>既然这么复杂，那么还是尽量使用带<code>Callable</code>构造器的版本吧！</p>

<h1 id="代码下载">代码下载</h1>

<p><a href="CallableFutureCase.java">CallableFutureCase.java</a>
<a href="FutureTaskCase.java">FutureTaskCase.java</a></p>
</div>

    
    

    

    

        <h4 class="page-header">Comments</h4>

        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "wbprime" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    

</main>

        <footer>

            <p class="copyright text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a></p>

        </footer>

    </body>

</html>

