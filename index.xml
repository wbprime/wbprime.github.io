<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>wbprime</title>
    <link>http://www.wbprime.me/</link>
    <description>Recent content on wbprime</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 06 Feb 2018 11:40:06 +0800</lastBuildDate>
    
	<atom:link href="http://www.wbprime.me/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Mybatis Note</title>
      <link>http://www.wbprime.me/posts/2018-02-06-mybatis-note/</link>
      <pubDate>Tue, 06 Feb 2018 11:40:06 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-06-mybatis-note/</guid>
      <description>&amp;ldquo;select&amp;rdquo; &amp;lt;select id=&amp;quot;selectPerson&amp;quot; parameterType=&amp;quot;int&amp;quot; parameterMap=&amp;quot;deprecated&amp;quot; resultType=&amp;quot;hashmap&amp;quot; resultMap=&amp;quot;personResultMap&amp;quot; flushCache=&amp;quot;false&amp;quot; useCache=&amp;quot;true&amp;quot; timeout=&amp;quot;10000&amp;quot; fetchSize=&amp;quot;256&amp;quot; statementType=&amp;quot;PREPARED&amp;quot; resultSetType=&amp;quot;FORWARD_ONLY&amp;quot;&amp;gt;     属性 描述     id 在命名空间中唯一的标识符，可以被用来引用这条语句。   parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。   parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。   resultType 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。   resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。   flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。   useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。   timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。   fetchSize 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。   statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。   resultSetType FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。   databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。   resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。   resultSets 这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。    &amp;ldquo;selectKey&amp;rdquo; &amp;lt;selectKey keyProperty=&amp;quot;id&amp;quot; resultType=&amp;quot;int&amp;quot; order=&amp;quot;BEFORE&amp;quot; statementType=&amp;quot;PREPARED&amp;quot;&amp;gt;     属性 描述     keyProperty selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。   keyColumn 匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。   resultType 结果的类型。MyBatis 通常可以推算出来，但是为了更加确定写上也不会有什么问题。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。   order 这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先选择主键，设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 元素 - 这和像 Oracle 的数据库相似，在插入语句内部可能有嵌入索引调用。   statementType 与前面相同，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 语句的映射类型，分别代表 PreparedStatement 和 CallableStatement 类型。    &amp;ldquo;insert&amp;rdquo; &amp;lt;insert id=&amp;quot;insertAuthor&amp;quot;&amp;gt; &amp;lt;selectKey keyProperty=&amp;quot;id&amp;quot; resultType=&amp;quot;int&amp;quot; order=&amp;quot;BEFORE&amp;quot;&amp;gt; select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.</description>
    </item>
    
    <item>
      <title>Maven Note</title>
      <link>http://www.wbprime.me/posts/2018-02-06-maven-note/</link>
      <pubDate>Tue, 06 Feb 2018 10:50:17 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-06-maven-note/</guid>
      <description>Local Repository Location conf/setting.xml
&amp;lt;settings ...&amp;gt; &amp;lt;localRepository&amp;gt;/path/to/local/repo&amp;lt;/localRepository&amp;gt; &amp;lt;/settings&amp;gt;  Use mvn help:system to confirm it.
Create New Project mvn archetype:create -DgroupId=me.wbprime.test -DartifactId=hello -DpackageName=me.wbprime.test -Dversion=1.0
Maven Dependency mvn dependency:copy-dependencies -DoutputDirectory=lib
Lifecycles Three builtin lifecycles:
 default clean site  &amp;ldquo;clean&amp;rdquo; Lifecycle    phase description     pre-clean execute processes needed prior to the actual project cleaning   clean remove all files generated by the previous build   post-clean execute processes needed to finalize the project cleaning    &amp;ldquo;site&amp;rdquo; Lifecycle    phase description     pre-site execute processes needed prior to the actual project site generation   site generate the project&amp;rsquo;s site documentation   post-site execute processes needed to finalize the site generation, and to   prepare for site deployment   site-deploy deploy the generated site documentation to the specified web server    &amp;ldquo;default&amp;rdquo; Lifecycle    phase description     validate validate the project is correct and all necessary information is available.</description>
    </item>
    
    <item>
      <title>Posix &amp; GNU Make Note</title>
      <link>http://www.wbprime.me/posts/2018-02-05-posix-make-note/</link>
      <pubDate>Mon, 05 Feb 2018 18:00:50 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-posix-make-note/</guid>
      <description>Compile Source code -&amp;gt; object file: &amp;ldquo;*.c -&amp;gt; *.o&amp;rdquo;
Link Object files -&amp;gt; executable: &amp;ldquo;*.o -&amp;gt; a.out&amp;rdquo;
makefile Rules target : prerequisites command1 command2 ... commandn   target is a target to be generated. It can be a object file, or a executable file or a label. prerequisites are dependecies of target. It is required to generate target. commandn are commands to generate target. Lines started with a &amp;lsquo;\t&amp;rsquo;  If any of prerequisites is newer than target, then make will call command1 to commandn.</description>
    </item>
    
    <item>
      <title>Access Control List</title>
      <link>http://www.wbprime.me/posts/2018-02-05-acl-note/</link>
      <pubDate>Mon, 05 Feb 2018 17:46:28 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-acl-note/</guid>
      <description>Linux ACL - Access Control List Commands  setfacl getfacl  ACL Permission - Comma separated entry. - Each entry consists of type, value and permissions, separated by colon. - type is one of `u` (user), `g` (group), `o` (other), `m` (mask) - value is the user name or uid for `u`, group name or gid for `g`, nothing for `o` - permissions is the combination of `r` (read), `w` (write) and `e` (execute) - if value is empty, then means all users/groups - if no read permission is to granted, the replace `r` with `-` for read char - if no write permission is to granted, the replace `w` with `-` for read char - if no execute permission is to granted, the replace `x` with `-` for read char - `-` in value can be ommited, if at least one of `r`, `w` and `x` is present: `r-x` =&amp;gt; `rx` - at least one `-` in value must be present if none of `r`, `w` and `x` is present: `---` =&amp;gt; `-` - e.</description>
    </item>
    
    <item>
      <title>Libevent Note</title>
      <link>http://www.wbprime.me/posts/2018-02-05-libevent-notes/</link>
      <pubDate>Mon, 05 Feb 2018 17:08:50 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-libevent-notes/</guid>
      <description>Event Context Structure event_base
Setup a Default Context #include &amp;lt;event2/event.h&amp;gt; struct event_base *event_base_new(void);  Setup a Custom Context 可以用 event_config 来自定义上下文。
struct event_config *event_config_new(void); struct event_base *event_base_new_with_config(const struct event_config *cfg); void event_config_free(struct event_config *cfg);  event_config 的自定义方法：
#include &amp;lt;event2/event.h&amp;gt; int event_config_avoid_method(struct event_config *cfg, const char *method); enum event_method_feature { EV_FEATURE_ET = 0x01, EV_FEATURE_O1 = 0x02, EV_FEATURE_FDS = 0x04, }; int event_config_require_features(struct event_config *cfg, enum event_method_feature feature); enum event_base_config_flag { EVENT_BASE_FLAG_NOLOCK = 0x01, EVENT_BASE_FLAG_IGNORE_ENV = 0x02, EVENT_BASE_FLAG_STARTUP_IOCP = 0x04, EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08, EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10, EVENT_BASE_FLAG_PRECISE_TIMER = 0x20 }; int event_config_set_flag(struct event_config *cfg, enum event_base_config_flag flag);  event_config_avoid_method() 指定不使用的后端名</description>
    </item>
    
    <item>
      <title>Jvm Memory Model</title>
      <link>http://www.wbprime.me/posts/2018-02-05-jvm-memory-model/</link>
      <pubDate>Mon, 05 Feb 2018 16:47:59 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-jvm-memory-model/</guid>
      <description>JVM 的内存模型，从网上整理的图片：</description>
    </item>
    
    <item>
      <title>Jvm GC Options</title>
      <link>http://www.wbprime.me/posts/2018-02-05-jvm-gc-options/</link>
      <pubDate>Mon, 05 Feb 2018 16:16:53 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-jvm-gc-options/</guid>
      <description>General options  -XX:+PrintFlagsFinal -XX:+PrintFlagsInitial -XX:+PrintCommandLineFlags -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions
 -XX:+ParallelRefProcEnabled
  java -server -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal java -client -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal  GC See following image first:
Young generation  &amp;ldquo;Serial&amp;rdquo; 是串行收集器，也是 -client 默认的GC收集器，可以 -XX:+UseSerialGC 来强制开启 &amp;ldquo;ParNew&amp;rdquo; 是并行收集齐，也是 -server 默认的GC收集器，可以 -XX:+UseParallelGC 来强制开启 &amp;ldquo;Parallel Scavenge&amp;rdquo; 是吞吐量优先收集器，可以通过 -XX:+UseParallelGC 来强制开启  Old generation  &amp;ldquo;CMS&amp;rdquo; 是 Concurrent Mark Sweep 收集器  执行阶段：
 CMS-initial-mark CMS-concurrent-mark CMS-concurrent-preclean CMS-remark CMS-concurrent-sweep CMS-concurrent-reset  相关参数：</description>
    </item>
    
    <item>
      <title>Jdk VS Jre</title>
      <link>http://www.wbprime.me/posts/2018-02-05-jdk-vs-jre/</link>
      <pubDate>Mon, 05 Feb 2018 15:54:01 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-jdk-vs-jre/</guid>
      <description>&lt;p&gt;JDK 与 JRE 的区别。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Note] Http Responce Status Code</title>
      <link>http://www.wbprime.me/posts/2018-02-05-http_responce_status_code/</link>
      <pubDate>Mon, 05 Feb 2018 15:45:52 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-http_responce_status_code/</guid>
      <description>&lt;p&gt;Notes about HTTP response status code.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Awk Tips: md5</title>
      <link>http://www.wbprime.me/posts/2017-06-01-awk-tips-md5/</link>
      <pubDate>Thu, 01 Jun 2017 09:43:06 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2017-06-01-awk-tips-md5/</guid>
      <description>Awk 之 md5 用例 有这么一个需求：文本文件中每一行是用户名和密码，现在需要对文件进行变换，输出用户名和对应的密码的md5值。
原始文件(&amp;ldquo;input.txt&amp;rdquo;)如下：
user1 user1_password user2 user2_password user3 user3_password user4 user4_password user5 user5_password user6 user6_password user7 user7_password  解决 可以使用支持GNU扩展特性的awk来完成这个任务。
awk 脚本如下:
#!/usr/bin/awk -f BEGIN { md5cmd = &amp;quot;md5sum&amp;quot;; } { printf $2 |&amp;amp; md5cmd; close(md5cmd, &amp;quot;to&amp;quot;); md5cmd |&amp;amp; getline md5result; close(md5cmd); print $1, substr(md5result, 1, 32); }  脚本另存为 &amp;ldquo;md5.awk&amp;rdquo; 。
在终端中输入:
&amp;gt; awk -f md5.awk input.txt  输出结果如下：
user1 b4ca6e90dcef1196a20930c2d9ecfbc0 user2 049914ab3268e59eb90526f64a5322d9 user3 99675fb0c81fdf505a95318e4c72b685 user4 5f3cca1f85aa649323c336546b3c7cc0 user5 41a87fa27533b238ed77824267259837 user6 758b093168f255636ad83f5f076213e6 user7 c1293b0e2400acb1461d25dbe4c6e75c  释义 解决方案使用了GNU awk扩展的协程功能，详解参见 [Two-Way Communications with Another Process](https://www.</description>
    </item>
    
    <item>
      <title>当时明月在 曾照彩云归</title>
      <link>http://www.wbprime.me/posts/2017-04-07-huangyi-memory/</link>
      <pubDate>Fri, 07 Apr 2017 10:42:29 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2017-04-07-huangyi-memory/</guid>
      <description>当时明月在，曾照彩云归。  </description>
    </item>
    
    <item>
      <title>Fast into Graphviz</title>
      <link>http://www.wbprime.me/posts/2017-03-20-fast-into-graphviz/</link>
      <pubDate>Mon, 20 Mar 2017 11:55:45 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2017-03-20-fast-into-graphviz/</guid>
      <description>Graphviz - Graph Visualization Software 由 AT&amp;amp;T 出品， 是一种结构化信息的可视化方式，也是一套开放源代码软件，可以被广泛地使用于网络拓扑、软件工程、数据库设计、机器学习等方向的图表展示。
Graphviz 1.2D 及之前的版本使用了 AT&amp;amp;T 代码许可证 (the AT&amp;amp;T Source Code Agreement)，之后的版本使用了EPL (The Eclipse Public License) 。
Graphviz 是一款面向程序员的绘图软件，不仅体现在其设计和使用方式上，还体现在其文档上 :)
Demos Hello world 新建一个文本文件 a.dot 。
graph start { hello -- {graphviz world}; graphviz -- world }  运行 dot -Tpng a.dot -o a.png
得到：
程序调用 新建一个文本文件 b.dot 。
digraph Invoke { size = &amp;quot;4, 4&amp;quot;;// 图片大小 main[shape=box];/* 形状 */ main-&amp;gt;parse; parse-&amp;gt;execute; main-&amp;gt;init[style = dotted];// 虚线 main-&amp;gt;cleanup; execute-&amp;gt;{make_string; printf}// 连接两个 init-&amp;gt;make_string; edge[color = red]; // 连接线的颜色 main-&amp;gt;printf[style=bold, label=&amp;quot;100 times&amp;quot;];// 线的 label make_string[label = &amp;quot;make a\nstring&amp;quot;]// \n, 这个node的label，注意和上一行的区别 node[shape = box, style = filled, color = &amp;quot;.</description>
    </item>
    
    <item>
      <title>Learning Java Concurrency - Executors(1) ExecutorService</title>
      <link>http://www.wbprime.me/posts/2016-04-15-learning-java-concurrency-executors-1-executorservice/</link>
      <pubDate>Fri, 15 Apr 2016 16:34:20 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-15-learning-java-concurrency-executors-1-executorservice/</guid>
      <description>回过头来看Thread类，其实可以发现该类是对一件任务的抽象。通过将要完成的任务抽象出来用Thread或者Runnable来表示，然后委托给另外的线程来处理。Thread类在这里充当的是任务执行者的角色，表示一个执行任务的线程。
有时候，任务是不是由另一个线程执行并不重要，甚至于由几个线程共同完成我们也并不在意，我们只关心任务被完成了。任务这个概念已经被抽象的很好了：Runnable；接下来要抽象出任务执行者这个概念了。
Java提供了另一个接口Executor来真正地抽象任务执行者这个概念：线程池。怎么理解呢，看一下Executor接口的代码就好了。
Executor public interface Executor { void execute(Runnable command); }  是不是很简单？
任务执行者的角色有了，但是还是不够，我们还需要控制任务执行者的行为。
ExecutorService public interface ExecutorService extends Executor { void shutdown(); List&amp;lt;Runnable&amp;gt; shutdownNow(); boolean isShutdown(); boolean isTerminated(); boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task); &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result); Future&amp;lt;?&amp;gt; submit(Runnable task); &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks) throws InterruptedException; &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll( Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks, long timeout, TimeUnit unit ) throws InterruptedException; &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title>Learning Java Concurrency - FutureTask &amp; Callable</title>
      <link>http://www.wbprime.me/posts/2016-04-13-learning-java-concurrency-futuretask-callable/</link>
      <pubDate>Wed, 13 Apr 2016 10:17:57 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-13-learning-java-concurrency-futuretask-callable/</guid>
      <description>Java的java.util.concurrent包里面提供了多线程并发和同步的支持。
最开始的时候，多线程被认为是执行任务的手段，也就是说，我启动一个新线程来执行代码，至于资源共享、线程同步等可以用锁、同步器等解决。所以Thread类和Rannable接口暴露了一个void run()方法来提供自定义行为。
但慢慢地，人们开始发现如果自定义的线程是计算结果的，那我怎么来拿到计算之后的结果呢？另外，我得知道什么时候计算结束了，如果计算的时间太长了，我也想能够终止计算线程的执行。这些需求其实用基本的多线程工具也可以实现，但是过程比较繁琐；而且这些需求有一段时间又特别普遍。终于，jdk 1.5开始引入了Callable接口和Future接口，用于支援有返回值的计算任务。
Callable Callable接口和Runnable接口很接近，有多接近呢？对比一下代码就知道了。
这是Runnable的代码：
public interface Runnable { public abstract void run(); }  这是Callable的接口：
public interface Callable&amp;lt;V&amp;gt; { V call() throws Exception; }  可以看到，Callable接口比Runnable接口多了两个功能：
 方法可以有返回值 方法可以抛出Checked异常  添加返回值就是为了支援计算类的任务；可以抛出Checked异常则是为了完善错误处理机制。
Thread/Runnable 机制是不允许抛出Checked异常的；如果抛出了Unchecked异常，会自动去寻找线程的异常处理器进行处理，参见 Learning Java Concurrency - Thread &amp;amp; Runnable 里面关于线程异常处理的部分。
Future Future接口封装了异步计算的结果，用于在异步任务完成之后获取结果。
接口的方法如下：
public interface Future&amp;lt;V&amp;gt; { boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; }  get()方法用于获取异步任务的结果。如果异步任务还没有结束，该方法的调用会被阻塞，一直到异步任务运行结束（正常结束或者抛出异常），或者异步任务线程被中断。如果异步任务线程被中断，该方法抛出InterruptedException异常；如果异步任务执行抛出异常，该方法抛出ExecutionException异常。</description>
    </item>
    
    <item>
      <title>Learning Java Concurrency - Thread &amp; Runnable</title>
      <link>http://www.wbprime.me/posts/2016-04-11-learning-java-concurrency-thread-runnable/</link>
      <pubDate>Mon, 11 Apr 2016 10:04:31 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-11-learning-java-concurrency-thread-runnable/</guid>
      <description>Java并发多线程的第一课，应该就是Thread了。顾名思义，Thread就是一个线程。线程是很底层的一个概念，在不同的操作系统上实现的模型和细节并不相同，甚至于可以说天差地别；但是总体来说，线程是比进程更细粒度的操作系统调度的单位，线程有自己的运行栈，但是同一个进程的线程共享方法区和堆区数据。
对于进程和线程的差别，有一种说法是：线程是操作系统调度的基本单位，而进程是操作系统分配运行资源的基本单位。
Java中对线程作了很好的封装：Thread类。Thread类的使用非常简单。
public class ThreadCase { private static class EchoThread extends Thread { private final String word; public EchoThread(final String word) { this.word = word; } @Override public void run() { for (int i = 0; i &amp;lt; 1000; i++) { System.out.println(this.getName() + &amp;quot; echos &amp;quot; + word); } } } public static void main(String [] _args) { final Thread echo1 = new EchoThread(&amp;quot;First&amp;quot;); final Thread echo2 = new EchoThread(&amp;quot;Second&amp;quot;); System.</description>
    </item>
    
    <item>
      <title>Spring MVC Integration Testing - JsonPath</title>
      <link>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-integration-testing-jsonpath/</link>
      <pubDate>Sat, 09 Apr 2016 23:09:10 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-integration-testing-jsonpath/</guid>
      <description>本文是Spring MVC Testing集成测试系列的第1篇，原文链接：Integration Testing of Spring MVC Applications: Write Clean Assertions with JsonPath。</description>
    </item>
    
    <item>
      <title>Spring MVC Integration Testing - Security</title>
      <link>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-integration-testing-security/</link>
      <pubDate>Sat, 09 Apr 2016 23:08:58 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-integration-testing-security/</guid>
      <description>本文是Spring MVC Testing集成测试系列的第1篇，原文链接：Integration Testing of Spring MVC Applications: Security。</description>
    </item>
    
    <item>
      <title>Spring MVC Integration Testing - REST API</title>
      <link>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-integration-testing-rest-api/</link>
      <pubDate>Sat, 09 Apr 2016 23:08:39 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-integration-testing-rest-api/</guid>
      <description>本文是 Spring MVC Testing 集成测试系列的第4篇，原文链接：Integration Testing of Spring MVC Applications: REST API, Part One 和 Integration Testing of Spring MVC Applications: REST API, Part Two。
本文主要介绍如何为基于Spring MVC的REST-full的web应用程序添加集成测试。REST服务通过HTTP标准方法的语义（GET/POST/PUT/DELETE等）来隐喻常见的增删改查（CRUD）操作。
本文主要演示如何一步一步地为REST-full API服务添加集成测试用例，包括：
 获取Todo项列表接口的集成测试 获取单个Todo项接口的集成测试 删除单个Todo项接口的集成测试 添加新Todo项接口的集成测试 更新Todo项接口的集成测试  示例web应用结构 Domain 层 Domain层有一个Todo的实体类，代码如下：
import org.hibernate.annotations.Type; import org.joda.time.DateTime; import javax.persistence.*; @Entity @Table(name=&amp;quot;todos&amp;quot;) public class Todo { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @Column(name = &amp;quot;creation_time&amp;quot;, nullable = false) @Type(type=&amp;quot;org.jadira.usertype.dateandtime.joda.PersistentDateTime&amp;quot;) private DateTime creationTime; @Column(name = &amp;quot;description&amp;quot;, nullable = true, length = 500) private String description; @Column(name = &amp;quot;modification_time&amp;quot;, nullable = false) @Type(type=&amp;quot;org.</description>
    </item>
    
    <item>
      <title>Spring MVC Integration Testing - Forms</title>
      <link>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-integration-testing-forms/</link>
      <pubDate>Sat, 09 Apr 2016 23:08:24 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-integration-testing-forms/</guid>
      <description>本文是 Spring MVC Testing 集成测试系列的第3篇，原文链接：Integration Testing of Spring MVC Applications: Forms。
本文主要介绍为处理Form表单请求的接口编写集成测试用例。
本文紧接着上一篇 Spring MVC Integration Testing - Controllers 的内容，主要涉及到两个接口：创建新的Todo项和更新指定的Todo项。
通过Maven获取依赖 除了上一篇中介绍的依赖之外，本文添加了新的依赖：
 jackson-core-asl 1.9.9 jackson-mapper-asl 1.9.9  对应的pom.xml文件片段如下：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.codehaus.jackson&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-core-asl&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.9&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.codehaus.jackson&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-mapper-asl&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.9&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;  示例web应用结构 DTO 本文主要处理Form表单，对应的类为TodoDTO。TodoDTO类是一个简单的Java Bean类，除了setter和getter方法外，还是用到了validator规则：
 title项不能为空 title项的最大长度为100 description项的最大长度为500  对应的代码如下：
import org.hibernate.validator.constraints.Length; import org.hibernate.validator.constraints.NotEmpty; public class TodoDTO { private Long id; @Length(max = 500) private String description; @NotEmpty @Length(max = 100) private String title; public TodoDTO() { } //Getters and setters }  Service 层 对应地，TodoService接口也添加了两个方法：</description>
    </item>
    
    <item>
      <title>Spring MVC Integration Testing - Controllers</title>
      <link>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-integration-testing-controllers/</link>
      <pubDate>Sat, 09 Apr 2016 23:08:01 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-integration-testing-controllers/</guid>
      <description>本文是Spring MVC Testing 集成测试系列的第2篇，原文链接：Integration Testing of Spring MVC Applications: Controllers。
本文主要介绍如何为“标准”Controller编写集成测试。在这里“标准”的含义延续前一个序列 Spring MVC Testing 中的含义，表示不使用Ajax的请求或者处理Form结果的请求。
同样地，本文还是一步一步地为我们的TodoApplication编写集成测试。该程序提供Todo项的增删改查（CRUD）接口，本文主要关注其中的3个接口：获取Todo项列表；查看单个Todo项的详情；以及删除某个Todo项。
通过Maven获取依赖 本文用到的依赖如下：
 Hamcrest 1.3 JUnit 4.10 Spring Test 3.2.3.RELEASE Spring Test DBUnit 1.0.0 DBUnit 2.4.8  生成的pom.xml文件的片段如下：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hamcrest&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hamcrest-all&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.10&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;artifactId&amp;gt;hamcrest-core&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;org.hamcrest&amp;lt;/groupId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.2.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2.3.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.github.springtestdbunit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-test-dbunit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>Spring MVC Integration Testing - Configuration</title>
      <link>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-integration-testing-configuration/</link>
      <pubDate>Sat, 09 Apr 2016 23:07:53 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-integration-testing-configuration/</guid>
      <description>本文是 Spring MVC Testing 集成测试系列的第1篇，原文链接：Integration Testing of Spring MVC Applications: Configuration。
没有人会否认集成测试的重要性，它是验证我们开发的组件能够正常协同工作的重要手段。不幸的是，对使用Spring MVC开发的web应用程序作集成测试有一点麻烦。
过去我们一直用 Selenium 和 JWebUnit 来对web应用接口作集成测试，然后效果不是很好。这种方法有以下三个缺点：
 对于开发中的web接口，编写和维护测试的工作量比较大 对于使用Javascript，尤其是Ajax的web应用，可用性不高 必须在web容器中启动运行，导致速度慢而且很没有效率  经常就是开发者在后续开发过程中觉得维护之前的集成测试用例太过耗时而且效果不大，所以废弃了这种形式的集成测试。幸运的是，我们找到了一种新型的集成测试框架Spring MVC Test可以用来简化测试工作。
本文主要介绍如何配置Spring MVC Test框架来进行web应用的测试。本系列使用的工具包括：
 Spring Framework 3.2 JUnit 4.10 Maven 3.0.3  我们一起来开始进入Spring MVC Test的世界吧！
通过Maven获取依赖 译者注：原文写作的时候是基于Spring Framework 3.1.2，当时Spring-test-mvc还是作为一个独立的项目进行开发和发布。在Spring Framework 3.2以后，该项目被合并到Spring Framework中去了。现在Spring Framework已经发布了4.X系列，很少有人在使用3.2以下的版本，为了减少混淆，直接将原文的pom文件加以修改。特此说明。
生成的pom.xml文件如下：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;  MockMvc 配置 Spring MVC Test框架提供了MockMvc类体系来辅助编写基于Spring MVC开发的web应用的测试代码。我们需要做的就是使用MockMvcBuilder接口的实际实现来生成MockMvc实例。MockMvcBuilders工厂类提供了两个工厂方法创建MockMvcBuilder实例：
 StandaloneMockMvcBuilder standaloneSetup(Object… controllers) 主要用来对单个Controller进行测试，需要手动地配置各种Bean DefaultMockMvcBuilder webAppContextSetup(WebApplicationContext context) 主要使用配置好的Spring上下文来配置Bean  下面来详细看一下这两种方式分别如何使用。</description>
    </item>
    
    <item>
      <title>Spring MVC Unit Testing - REST API</title>
      <link>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-unit-testing-rest-api/</link>
      <pubDate>Sat, 09 Apr 2016 23:07:22 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-unit-testing-rest-api/</guid>
      <description>本文是 Spring MVC Testing 单元测试系列的第3篇，原文链接：Unit Testing of Spring MVC Controllers: REST API。
使用Spring MVC可以很方便第创建REST风格的接口，但是编写REST风格接口的单元测试并不是那么方便。幸运的是，Spring MVC Test极大地简化了我们为REST风格controller编写单元测试的工作。
本文将通过为Todo项的增删改查（CRUD）的REST风格接口操作编写单元测试的方式，一步一步地讲解如何使用Spring MVC Test来进行单元测试。OK，我们快点进入正文吧！
通过Maven获取依赖 本系列用到的依赖如下：
 Hamcrest 1.3 (hamcrest-all) Junit 4.11 Mockito 1.9.5 (mockito-core) Spring Test 3.2.3.RELEASE JsonPath 0.8.1 (json-path and json-path-assert)  生成的pom.xml文件的片段如下：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hamcrest&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hamcrest-all&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;artifactId&amp;gt;hamcrest-core&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;org.hamcrest&amp;lt;/groupId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mockito&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mockito-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.5&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2.3.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.</description>
    </item>
    
    <item>
      <title>Spring MVC Unit Testing - Normal Controllers</title>
      <link>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-unit-testing-normal-controllers/</link>
      <pubDate>Sat, 09 Apr 2016 23:07:12 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-unit-testing-normal-controllers/</guid>
      <description>本文是 Spring MVC Testing 单元测试系列的第2篇，原文链接：Unit Testing of Spring MVC Controllers: &amp;ldquo;Normal&amp;rdquo; Controllers。
本系列的第1部分讲述了使用Spring MVC Test应如何进行单元测试的配置，现在可以开始实战一下如何对标准controller编写单元测试。
首先需要明确一下。
 何为标准controller？
 注意：原文标准是加了双引号的（&amp;rdquo;normal&amp;rdquo;）
我们称之为标准controller的Controller，是渲染view或者处理form提交请求的Controller。（与之相对的是Rest Controller）。
OK，现在我们进入正文。
通过Maven获取依赖 本系列用到的依赖如下：
 Jackson 2.2.1 (core and databind modules) Hamcrest 1.3 JUnit 4.11 Mockito 1.9.5 Spring Test 3.2.3.RELEASE  生成的pom.xml文件的片段如下：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.1&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.1&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hamcrest&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hamcrest-all&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;artifactId&amp;gt;hamcrest-core&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>Spring MVC Unit Testing - Configuration</title>
      <link>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-unit-testing-configuration/</link>
      <pubDate>Sat, 09 Apr 2016 23:06:57 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-unit-testing-configuration/</guid>
      <description>本文是 Spring MVC Testing 单元测试系列的第1篇，原文链接：Unit Testing of Spring MVC Controllers: Configuration。
一直以来，为Spring MVC的Controller写单元测试的工作既简单又问题多多。简单体现在单元测试可以很简单地写个测试用例调用一下目标Controller的方法；问题在于这种单元测试完全没有用（不是HTTP的请求），比如说，这种单元测试的方法没办法测试请求映射、参数验证和异常映射等。
幸运的是，从Spring 3.2开始，我们可以使用Spring MVC Test Framework这一强大的工具通过DispatcherServlet来仿照HTTP请求的方式来单元测试Controller的方法。
本文主要介绍如何配置Spring使得可以单元测试Spring MVC Controllers。
下面进入正题。
通过Maven获取依赖 本系列用到的依赖如下：
 JUnit 4.11 Mockito Core 1.9.5 Spring Test 3.2.3.RELEASE  生成的pom.xml文件的片段如下：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mockito&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mockito-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.5&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2.3.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;  然后，我们进一步去看一下示例程序。
示例程序的结构 本教程的示例程序提供用于访问todo项的增删改查（CRUD）入口。为了更好地理解测试配置，首先看一下需要测试的controller类。
到目前为止，我们需要回答以下两个问题：
 待测试的controller类有哪些依赖 这些以来是如何注入待测试的controller类  我们可以创建的TodoController目标类的代码中去查找答案。相关代码如下：
import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.MessageSource; import org.springframework.stereotype.Controller; @Controller public class TodoController { private final TodoService service; private final MessageSource messageSource; @Autowired public TodoController(MessageSource messageSource, TodoService service) { this.</description>
    </item>
    
    <item>
      <title>Spring MVC Testing: Content</title>
      <link>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-content/</link>
      <pubDate>Sat, 09 Apr 2016 23:03:35 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-09-spring-mvc-testing-content/</guid>
      <description>本系列翻译自Spring MVC Test Tutorial。
Springframework自3.2版本以后，提供了Spring MVC Test Framework用于对Spring MVC项目进行测试。
本系列一共两个部分：单元测试和集成测试。
单元测试将一个一个的Spring MVC Controller作为一个单元，对每一个接口进行测试。Controller层对Service层的调用使用Mockito进行模拟。
集成测试对整个web服务进行测试，虽然测试的单位仍然是接口，但是测试结果更偏向于生产环境。为了保证测试的稳定性，使用了DBUnit来控制每一次测试的数据样本。
需要注意的是，虽然这个系列将Spring MVC Test Framework分为单元测试和集成测试两个部分，但是对于Spring本身来说，其内部实现都是一样的。单元测试和集成测试的区分，是从开发者的角度进行的区分。
Spring MVC 单元测试：
 Unit Testing - Configuration Unit Testing - Normal Controllers Unit Testing - REST API  Spring MVC 集成测试：
 Integration Testing - Configuration Integration Testing - Controllers Integration Testing - Forms Integration Testing - REST API Integration Testing - Security Integration Testing - JsonPath  </description>
    </item>
    
    <item>
      <title>Learning Java Concurrency - ReentrantReadWriteLock</title>
      <link>http://www.wbprime.me/posts/2016-04-07-learning-java-concurrency-reentrantreadwritelock/</link>
      <pubDate>Thu, 07 Apr 2016 21:54:38 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-07-learning-java-concurrency-reentrantreadwritelock/</guid>
      <description>ReentrantLock是互斥锁，对于要保护的资源，同一时间只能有一个线程进行访问。所谓的访问，就是读和写。但是在实际中，往往是读操作对互斥性的要求远远低于写操作。
考虑一个共享资源，比如一个List对象，可能会有多个线程对其进行读写。
下面是使用ReentrantLock实现的一个版本。
private static class ExclusiveLockStack { private final List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); private final ReentrantLock lock = new ReentrantLock(); public void push(final String val) { if (null == val) return; lock.lock(); try { list.add(val); } finally { lock.unlock(); } } public String last() { lock.lock(); String str = null; try { final int lastIdx = list.size() - 1; if (lastIdx &amp;gt;= 0) { str = list.get(lastIdx); } } finally { lock.</description>
    </item>
    
    <item>
      <title>Learning Java Concurrency - ReentrantLock &amp; Condition</title>
      <link>http://www.wbprime.me/posts/2016-04-07-learning-java-concurrency-reentrantlock-condition/</link>
      <pubDate>Thu, 07 Apr 2016 09:47:10 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-07-learning-java-concurrency-reentrantlock-condition/</guid>
      <description>ReentrantLock是synchronized的高阶版本，用来控制多线程同步。ReentrantLock是一种独占锁，同一时间只能有一个线程使用一把锁，其他请求加锁的线程都会被阻塞。除了控制多线程同步之外，ReentrantLock还提供了Condition用来进行多线程通讯。Condition是Object类的方法wait &amp;amp; notify的替代版本，可以用等待/通知模式来有效控制多线程对共享资源的访问。
仿synchronized，用ReentrantLock实现单例模式的代码如下：
private static class Singleton { private static volatile Singleton INSTANCE; private static ReentrantLock lock = new ReentrantLock(); private Singleton() {} public static Singleton instance() { Singleton var = INSTANCE; if (null == var) { lock.lock(); try { var = INSTANCE; if (null == var) { INSTANCE = var = new Singleton(); } } finally { lock.unlock(); } } return var; } }  仿wait &amp;amp; notify，用Condition来实现父子通知汇款的代码如下：</description>
    </item>
    
    <item>
      <title>Learning Java Concurrency - wait &amp; notify</title>
      <link>http://www.wbprime.me/posts/2016-04-06-learning-java-concurrency-wait-notify/</link>
      <pubDate>Wed, 06 Apr 2016 10:00:56 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-06-learning-java-concurrency-wait-notify/</guid>
      <description>在synchronized关键字之外，Java提供了另外的wait和notify函数族用于支援多线程通信，使用上类似于JUC的Condition类。
wait()、notify()和notifyAll()是Object类的方法，与synchronized配套使用。
public class Object { ... public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException; public final void wait() throws InterruptedException; public final native void notify(); public final native void notifyAll(); ... }  wait一共有三个函数。调用wait的线程必须已经持有了同一个对象的同步器（使用synchronized）。调用wait的线程会进入等待状态，直到另外的线程调用了同一个对象的notify函数，或者指定的等待时间过期，或者被中断（引发InterruptedException）。调用wait函数之后，当前线程会放弃已经持有的同步器。
notify一共是有两个函数。notify()函数会唤醒当前的由于执行wait而进入等待的某个线程；注意，被唤醒的线程是不可预料的，也就是说不同的JVM实现可以用不同的规则算法来决定被唤醒的是哪一个线程。notifyAll()函数会唤醒所有的等待线程，但是只会有一个线程最终进入执行。
下面用两个例子来说明wait &amp;amp; notify的使用场景和使用方式。
银行取钱 银行取钱是传统的生产者和消费者模型的一个简化版本。
假设有一个银行账户，两个用户分别要往里面存钱和取钱（可以想象为一个通知汇款，儿子在上大学要花钱，打电话让父亲给打钱；两个ATM机，父亲手哆嗦地五百五百地存，儿子不耐烦地刷，有钱就取出来）。
代码 package me.wbprime.showcase.concurrent; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * Class: DepositCase * Date: 2016/04/05 14:42 * * @author Elvis Wang [mail@wbprime.</description>
    </item>
    
    <item>
      <title>Learning Java Concurrency - synchronized</title>
      <link>http://www.wbprime.me/posts/2016-04-01-java-concurrency-synchronized/</link>
      <pubDate>Fri, 01 Apr 2016 16:39:24 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-04-01-java-concurrency-synchronized/</guid>
      <description>synchronized，同步控制器，是Java原生提供的多线程同步控制的工具，是Java语法的一部分。
synchronized在语义上等同于一个独占锁。synchronized可以用来修饰一个方法，标识该方法是可同步的；也可以用来修饰语句块，标识该语句块是同步的。在代码经过编译之后，JVM会在方法或者语句块的前后插入monitorenter和monitorexit的虚拟机指令，这两条指令又会隐式地调用lock原语。
synchronized可以使用在普通方法里，也可以使用在静态方法里。
class Synchronized { public synchronized void method1(final String val) { System.out.println(&amp;quot;1: Begin add &amp;quot; + val); System.out.println(&amp;quot;1: Finish add &amp;quot; + val); } public synchronized static void method2(final String val) { System.out.println(&amp;quot;2: Begin add &amp;quot; + val); System.out.println(&amp;quot;2: Finish add &amp;quot; + val); } public void method3(final String val) { synchronized(this) { System.out.println(&amp;quot;3: Begin add &amp;quot; + val); System.out.println(&amp;quot;3: Finish add &amp;quot; + val); } } public static void method4(final String val) { synchronized(Synchronized.</description>
    </item>
    
    <item>
      <title>Learning Java Concurrency - Content</title>
      <link>http://www.wbprime.me/posts/2016-03-31-java-concurrency-content/</link>
      <pubDate>Thu, 31 Mar 2016 10:10:46 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-03-31-java-concurrency-content/</guid>
      <description> Java Concurrency是学习Java的过程中绕不过去的一道坎。既然绕不过去，只能一点一点去学习它，然后了解它。本系列是在学习Java Concurrency过程中的记录，鉴于网络上关于原理和实现代码的文章一大堆，所以本系列会尽量以实际应用为主。毕竟原理了解的再深，还是要落地为代码。
本系列主要参考《深入浅出Java Concurrency》系列。
目录  Learning Java Concurrency - Thread &amp;amp; Runnable Learning Java Concurrency - FutureTask &amp;amp; Callable Learning Java Concurrency - synchronized Learning Java Concurrency - wait &amp;amp; notify Learning Java Concurrency - ReentrantLock &amp;amp; Condition Learning Java Concurrency - CountDownLatch Learning Java Concurrency - CyclicBarrier Learning Java Concurrency - Semaphore Learning Java Concurrency - ReentrantReadWriteLock Learning Java Concurrency - Executors(1)  </description>
    </item>
    
    <item>
      <title>Learning Java Concurrency - CyclicBarrier</title>
      <link>http://www.wbprime.me/posts/2016-03-30-java-concurrency-cyclicbarrier/</link>
      <pubDate>Wed, 30 Mar 2016 21:06:26 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-03-30-java-concurrency-cyclicbarrier/</guid>
      <description>CyclicBarrier，正如同名字里面表达出来的，是一个可以循环使用的屏障。与CountDownLatch类似，它可以用来表达等待某个状态，比如大家都到齐了，那么开始开会吧。与CountDownLatch不同的是，它可以多次等待，也就是可以等待多个状态。
好吃不过栗子。比如哈利波特的三强争霸赛，要一项一项任务地完成，大家都结束了（不管成功还是失败），才开始计划下一个任务。第一个是去挑战龙；然后是到海里面挑战人鱼群；最后是挑战伏地魔。每一个任务总是要等大家都完成了才开始。
还有一个栗子。大家一起去面试，有的公司为了省事，等凑齐了一波人才开始走流程。HR领着大家一起先笔试，然后安排初面官，然后安排复试官。每一关刷掉一波人，但是只有大家都结束了才进行下一轮。别问我哪里有这样的招聘部门，人家开心就好。
CyclicBarrier 的简单使用 首先，需要判断有哪些关卡，设计好通关条件。
然后，创建闯关的线程，各自吃好喝好，准备闯关。
然后，每过一关，可以有看守的线程出来引导，这也是一个任务。
之后，就可以开始了。
CyclicBarrier 的API CyclicBarrier是来做多线程同步的，首先需要确定有多少个线程参与同步。每一个线程都需要调用await()表示自己已经就绪；当所有线程都调用了await()之后，CyclicBarrier达到了第一个屏障。此时可以简单地放行，也可以设置一个任务，由最后一个就绪的线程执行，执行完才放行。
 CyclicBarrier(int n) 构造一个有n个线程参与同步的同步器，阻塞所有线程直到阻塞的线程个数大于等于n。 CyclicBarrier(int n, Runnable action) 构造一个有n个线程参与同步的同步器，阻塞所有线程直到阻塞的线程个数大于等于n。接触阻塞之前，由最后一个达到的新城执行action。 int await() throws InterruptedException, BrokenBarrierException 阻塞调用线程，直到所有n个线程都调用了本方法。最后一个调用本方法的线程，需要去执行设置的阻塞任务，如果设置了的话。 int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException 同上，加上了超时限制。返回值表示还有多少个线程未就绪，0表示调用线程是最后一个线程。 int getParties() 返回构造器传入的n值。 boolean isBroken() 是否被损坏，损坏原因可能是线程被中断或者超时，或者阻塞action发生异常。 void reset() 重置到初始化状态。 int getNumberWaiting() 返回当前已经等待的线程数。  CyclicBarrier内部是通过一个ReentrantLock实例来进行同步的，用该实例的一个Condition实例来控制是否达到放行状态。
/** The lock for guarding barrier entry */ private final ReentrantLock lock = new ReentrantLock(); /** Condition to wait on until tripped */ private final Condition trip = lock.</description>
    </item>
    
    <item>
      <title>Learning Java Concurrency - CountDownLatch</title>
      <link>http://www.wbprime.me/posts/2016-03-30-java-concurrency-countdownlatch/</link>
      <pubDate>Wed, 30 Mar 2016 21:06:08 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-03-30-java-concurrency-countdownlatch/</guid>
      <description>CountDownLatch 是一种比较有意思的线程同步方法，主要用于需要同步启动的环境中。
举个栗子，部门进行聚餐要等到大家都到齐了才能开动。这个时候CountDownLatch可以理解为“还有多少人没有到”这个东西，来了一个，这个东西的值就会减1。一直到人都到齐了，这个东西的值变为了0,也就是可以开吃了。
举个栗子，通用的make进行多工程代码编译，必须所有工程编译完了才能结束。
举个栗子，项目上线，各个模块都上线完了，leader说一句OK，大家才能走。
要注意以上几个栗子都是每个线程减1，但是实际中具体减多少不做限制。
比如，猫有9条命，两个人你一下我一下一刀一刀砍上去，然后它就死了。这个也可用CountDownLatch来描述。
CountDownLatch 的简单使用 首先，估计要参与工作的子工作数，创建一个CountDownLatch。
然后，创建干活的线程，持有该CountDownLatch实例，调用await()等待事件。比如具体到聚餐就是“开吃”，具体到9命猫就是“命没了要死了”。
然后，创建多个准备的线程，每个线程持有相同的CountDownLatch实例。这些线程用来做准备工作，争取早日达到能干活的状态。具体到聚餐上就是“人一个一个来”，具体到猫上就是“一次一次被砍死”。
然后，就结束了。
CountDownLatch 的 API  CountDownLatch(int) 构造一个可以由n个线程共享的闭锁。 void await() throws InterruptedException 等待原始的n变成0。调用的线程会被阻塞，直到条件达到。 boolean await(long timeout, TimeUnit unit) throws InterruptedException 等待原始的n变成0。调用的线程会被阻塞，直到条件达到(return true)或者超时(return false)。 void countDown() n - 1。 long getCount() 查询n的值。  CountDownLatch内部有一个静态类Sync。CountDownLatch的所有方法都委托到内部一个Sync实例。
private static final class Sync extends AbstractQueuedSynchronizer  Sync可以理解为一个共享锁，主要使用AbstractQueuedSynchronizer的共享锁方面的功能。
示例代码 package me.wbprime.showcase.concurrent; import java.util.Random; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * Class: CountDownLatchCase * Date: 2016/03/30 13:05 * * @author Elvis Wang [mail@wbprime.</description>
    </item>
    
    <item>
      <title>Learning Java Concurrency - Semaphore</title>
      <link>http://www.wbprime.me/posts/2016-03-30-java-concurrent-semaphore/</link>
      <pubDate>Wed, 30 Mar 2016 20:33:17 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2016-03-30-java-concurrent-semaphore/</guid>
      <description>Semaphore，信号量。信号量可以理解为令牌掌牌使，负责令牌的发放；当线程需要执行任务时，先到信号量处领取令牌，领取到了令牌再去执行任务；如果令牌被领光了，就需要一直等待；如果任务执行完了，需要到信号量处交还令牌。很简单的逻辑！
还是吃个栗子，地铁里面公厕，一般也就3、4个坑位。人有三急，当你有需要的时候，还必须得靠这个解决。这个时候，如果公厕里没有人，或者还剩最后一个坑位，那就啥也别说了，进去吧。但是，如果，满了。就，只有，等，了。不着急可以等一等；实在憋不住的，可以催一催。但是不管急不急，都要等里面随便一个里面出来人了才能进去。这个就是典型的信号量。
还有就是非常典型的生产者/消费者问题了。有一个仓库，里面的仓位是有限的。生产者只有当仓库里面有空仓位时才能进行生产；如果没有空仓位，则需要等待；如果生产了一次，则仓库少了一个空仓位。消费者只有当仓库里有非空仓位时才能消费；如果没有非空仓位，就需要等待；如果消费了一次，仓库里多了一个空仓位。
Semaphore的简单实用 首先，初始化信号量控制的令牌的个数。
然后，消费者去申请令牌，可能申请到，也可能被阻塞。
然后，生产者去释放令牌。
然后，交互就可以开始了。
注意，信号量只是保证资源的可用性，当资源不可用时，阻塞线程；然而线程使用资源的过程不保证是原子的，需要另外加锁控制。
举个例子，你成功申请到了令牌开始执行任务，但是这个任务可能失败，可能成功，还有可能部分成功部分失败。
Semaphore的API  Semaphore(int permits) &amp;amp; Semaphore(int permits, boolean fair) 构造一个信号量实例（可以是公平的或者非公平的），默认是非公平的。 void acquire() throws InterruptedException 申请一枚令牌；如果没有可用令牌，则阻塞。 void acquireUninterruptibly() 同上；当调用线程被中断时，不抛出异常。 void acquire(int permits) throws InterruptedException 申请多枚令牌；如果没有可用令牌，则阻塞。 void acquireUninterruptibly(int permits) 同上；当调用线程被中断时，不抛出异常。 boolean tryAcquire() 申请一枚令牌；立即返回，申请成功返回true，反之false。 boolean tryAcquire(int permits) 申请多枚令牌；立即返回，申请成功返回true，反之false。 boolean tryAcquire(long timeout, TimeUnit unit) throws TimeoutException 申请一枚令牌，不允许超时；立即返回，申请成功返回true，反之false。 boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws TimeoutException 申请多枚令牌，不允许超时；立即返回，申请成功返回true，反之false。 void release() 归还一枚令牌。 void release(int permits) 归还多枚令牌。 int availablePermits() 当前可用的令牌数。 int drainPermits() 申请获取所有可用令牌，返回申请到的令牌数。 boolean isFair() 是否公平。  Semaphore内部有一个静态类Sync来实现公平策略，NonFairSync来实现非公平策略。</description>
    </item>
    
    <item>
      <title>Spring: Annotation based configuration</title>
      <link>http://www.wbprime.me/posts/2015-06-08-spring-annotation-based-configuration/</link>
      <pubDate>Mon, 08 Jun 2015 10:45:49 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-06-08-spring-annotation-based-configuration/</guid>
      <description>Despite XML-based configuration, the Springframework provides full support for annotation-based metadata configuration.
XML-based configuration isolates the configuration metadata from source code using independent xml files, while annotation-based configuration mixes source code and configuration data. Thus which is the better one to collaborate with the Springframework? The answer is it depends. The XML one performes good isolation between source code and configuration, however you need to bear its stupid and complex and long-but-useless xml syntax, and you must do additional work to sync youc onfiguration data and you source code when you need to update your code, which however is very frequent during development.</description>
    </item>
    
    <item>
      <title>Spring: XML based configuration</title>
      <link>http://www.wbprime.me/posts/2015-06-02-spring-xml-based-configuration/</link>
      <pubDate>Tue, 02 Jun 2015 10:12:47 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-06-02-spring-xml-based-configuration/</guid>
      <description>Overview Spring Configuration The Springframework supports 3 kinds of configuration methods, including XML-based configuration, annotation-based configuration and Java-based configuration.
 Xml-based configuration: traditionally supplied as a simple and intuitive XMl format metadata. Annotation-based configuration: introduced by Spring 2.5. Java-based configuration: introduced as the Spring JavaConfig project by Spring 3.0.  XML-based configuration is widely used and best supported.
Typical xml configuration file:
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.</description>
    </item>
    
    <item>
      <title>Spring DI: At First Glance</title>
      <link>http://www.wbprime.me/posts/2015-05-28-spring-at-first-glance/</link>
      <pubDate>Thu, 28 May 2015 19:11:56 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-28-spring-at-first-glance/</guid>
      <description>Spring is a world famous Java developing framework.
 The Spring Framework is a lightweight solution and a potential one-stop-shop for building your enterprise-ready applications. However, Spring is modular, allowing you to use only those parts that you need, without having to bring in the rest. You can use the IoC container, with any web framework on top, but you can also use only the Hibernate integration code or the JDBC abstraction layer.</description>
    </item>
    
    <item>
      <title>JDK installation on Archlinux</title>
      <link>http://www.wbprime.me/posts/2015-05-25-jdk-installation-on-archlinux/</link>
      <pubDate>Mon, 25 May 2015 11:07:13 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-25-jdk-installation-on-archlinux/</guid>
      <description>Basically, Archlinux provide OpenJDK 7&amp;frasl;8 in official repository. Java JDK environment will be setup in quite a little minutes follwing Archliux official guide.
However, some java programmes does not work well on OpenJDK, and achives better performance on Sun/Oracle JDK. For example, Intellij Idea in Archlinux official repository produces warning message blaming OpenJDK. So Sun/Oracle JDK maybe welcomed by some users who wanted a clean installation of Intellij Idea.
 Choose and download the JDK version you want to install.</description>
    </item>
    
    <item>
      <title>慢慢走</title>
      <link>http://www.wbprime.me/posts/2015-05-16-man-man-zou/</link>
      <pubDate>Sat, 16 May 2015 20:00:57 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-man-man-zou/</guid>
      <description>转眼间已经工作了两年，似乎什么也没有改变。
毕业那会儿还是躇踌满志。
现在也还躇踌满志。
毕业那会儿还是战战兢兢。
现在也还战战兢兢。
似乎什么也没有改变，似乎，全都已经改变了。
好像真的不是从前的自己了。
好像没有以前那么乐观。
好像没有以前那么从容。
好像没有以前那么富有爱心。
好像开始急忙火燎地挣钱。
好像开始漫无目的地社交。
好像开始莫名其妙地吐槽和抱怨。
始终还是要慢慢来啊。
车子不是一天能有的。
房子不是一天能有的。
生活也不是一天能有的。
所以，定下个计划，然后按部就班的实现，有条有理地修正。
日子慢慢来，慢慢过，慢慢走。</description>
    </item>
    
    <item>
      <title>白云依旧在</title>
      <link>http://www.wbprime.me/posts/2015-05-16-baiyun-yijiu-zai/</link>
      <pubDate>Sat, 16 May 2015 19:59:21 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-baiyun-yijiu-zai/</guid>
      <description>白云依旧在，桃花笑春风。
白云依旧在，黄河入海流。
白云依旧在，低头思故乡。
白云依旧在，何人不识君。
白云依旧在，天涯若比邻。
白云依旧在，萧萧班马鸣。
白云依旧在，飞入百姓家。
白云依旧在，千里共婵娟。
白云依旧在，我亦是行人。
白云依旧在，何处是归乡。</description>
    </item>
    
    <item>
      <title>说好的安静的美男子呢</title>
      <link>http://www.wbprime.me/posts/2015-05-16-shuohaode-anjingde-meinanzi-ne/</link>
      <pubDate>Sat, 16 May 2015 19:54:33 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-shuohaode-anjingde-meinanzi-ne/</guid>
      <description>最近挺多事的。
事情太多太芜杂，耽误了我的美男子大业。
安静的美男子大业，需要一杯清茶，一本书，和一个小马凳。
以前还想着要一抔阳光。
阳光，太奢侈了，能有亮就不错了，大不了开着灯。
一杯茶。茶是必须的，有了茶心就能静下来，安安静静地做自己的事情，吹一口茶面，喝一丁茶，感觉自己终于属于自己了。
一本书。书是必须的，就算不看也要放着一本。多少年了，书始终是一方镇纸，轻轻一翻，心头涟漪顿时全消了。
小马凳。安安静静的美男子最迷人的是坐着的侧影。坐在椅子上直着腰身的样子太古板，坐着小马凳，垂着袖子的样子，好像文质彬彬。
最好还要落地窗透着明亮。
最好还要小树发着新绿。
最好还要风铃滴答滴答伴着蝉唱。
说到底就是心里头的一个梦想。
想做一个安安静静的美男子还真是难呢！</description>
    </item>
    
    <item>
      <title>C 漫谈</title>
      <link>http://www.wbprime.me/posts/2015-05-16-c-mantan/</link>
      <pubDate>Sat, 16 May 2015 19:18:33 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-c-mantan/</guid>
      <description>a[i] = i[a]  在C的世界里，无奇不有。
数组a进行下标运算的结果，相当于指针的算术运算。
a[i] = *(a + i) = *(i + a) = i[a]  好吧，我承认这个只是别人说的，我个人没有进行验证。
因为C实在太灵活了，我竟然不敢说它是错的，虽然很有可能是错的。
毕竟整数不会有下标运算的，强制转换差不多。
但它毕竟有可能是正确的。
除非经过验证，我不能断定它是对是错；我不敢断定它是错是对。
也许人的悲哀就在于这里。
想要肯定，早已失去肯定的自信；想要否定，却又恐惧未知的恐惧。
伛偻前行，战战兢兢。
如临深渊，如履薄冰。
有人说，人这一生，就是在不断挣扎然后无可避免地走向死亡。
这句话未免太过乐观。
因为也许你明天就走向了死亡，不需要挣扎，不需要纠结，自然而然。
明白了这一点，就知道应该怎么去生活。
从明天起，泡一杯茶，寄一张明信片。
从明天起，深呼吸，然后迎接我的宿命。</description>
    </item>
    
    <item>
      <title>看电影</title>
      <link>http://www.wbprime.me/posts/2015-05-16-kan-dianying/</link>
      <pubDate>Sat, 16 May 2015 19:15:55 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-kan-dianying/</guid>
      <description>人不知道为什么，总有点少年故事历久弥新的情怀。看到丰盛宴席，也许会想起老家时候外婆炒的的老咸菜；看到可爱小宠，也许会怀念看家赶狼还顺带抓老鼠的那匹老黄狗；走在路上，不自觉就回忆到那些个到中午就扑腾在竹林里打闹的夏天。
来北京也已经快八年了，少小离家也差不多吧，转眼间已经半半百了。在京师里面吃喝，租着房子，购物，聊天，交友，仿佛就像个家似的。
想起小时候看电影的事情了。那大约是六七岁时候的事情吧。村头的大田里，本来是堆着稻草的。忽然有一天，来了几个人，跑到田里面踱了两步，说话间点点头。过不半响，叔叔伯伯家的男人们都围了过去，女人们也抱着小孩跟着。我在窗户边写作业，听见阿大阿二他们几个小孩子的声音，就抬头张望。
过了一会儿，看见他们一些人开始叉稻草，就是那叉棍把稻草堆起来弄到一边去。主要是男人们动手，不时有着大笑；不一会儿女人们也有上前帮忙的；小孩子尖叫着跑来跑去，还能听着有的在哭，约摸是打架了。
过了一会，家里大人回来，说是村里面要放电影。
那时候看电影，要找一个空旷的大场子，树两根竿支块幕布，有放电影的人摇个机子把影像投上去。大伙儿也不用买票，自己家里搬条长凳过去围起来坐。
到了晚上开始演。我写完作业，也是跟着大人们一起出去。
那天演的什么电影我已经忘记了，什么台词什么人物都没在意。大人们看得很高兴，一阵一阵大笑；好也不是大笑，就是开心的开心的笑。
我跟着小伙伴们也没心没肺地叫，从人群里面冲来冲去，抢别人东西吃，追着打架。有时候大人们大声地骂两句，有时候也不管，自己在那边笑。
到现在也忘了为啥那么兴奋地尖叫跑闹；尖叫跑闹声响在脑子里面一阵一阵的，仿佛在昨天，又仿佛在十辈子以前。
再没有那么尖叫跑闹过了。</description>
    </item>
    
    <item>
      <title>大难</title>
      <link>http://www.wbprime.me/posts/2015-05-16-danan/</link>
      <pubDate>Sat, 16 May 2015 19:14:49 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-danan/</guid>
      <description>唐和尚去取经，历八十一难，首难是两界山遇虎，末难是通天河沉经，一山一水，一者天定，一者人为。 援道而登山，山巅自有雄奇瑰丽之景，谓事业成就也。遇虎，难也。登山而遇虎，自是造化欲予先夺、欲得先失之理。盖不经风霜何来傲菊也。 乘舟而渡水，彼岸自有艳丽夺目之花，谓爱情美满也。沉经，难也。渡水而沉经，不亦历久弥新、历艰弥坚乎？所谓贵难得之货、尚非常之礼是也。 今有一人，于事业有不顺，于情感有不谐，而妄自菲薄、愤懑于天，可乎？曰不可。事有顺不顺，时也。元亨利贞，君子终有时。家有谐不谐，命也。修短随化，君子岂由命乎？且夫修身齐家而家齐国治天下平，一旦身修，天下予取予夺，何况二三子哉？ 易曰，天行健，君子以自强不息。是言也，其勉乎哉，其勉乎哉！</description>
    </item>
    
    <item>
      <title>将进酒</title>
      <link>http://www.wbprime.me/posts/2015-05-16-qiangjinjiu/</link>
      <pubDate>Sat, 16 May 2015 19:10:58 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-qiangjinjiu/</guid>
      <description>酒一曰天地。天地造化万物，有生老病死、吃喝玩乐万声万态。饮之 酒二曰人伦。无人伦则无父子兄弟姐妹姻亲，亲亲孝悌而后百世不绝。饮之 酒三曰太一。太一为神灵，为善有所赏，为恶有所惩，虽曰缈缈天意，不亦铮铮浩然之气哉。饮之 酒四曰律法。杀之刑之囚之，而后百姓莫敢犯之。饮之 酒五曰先生。先我而生，生我也。先我而学，引我也。先我而知道，教我也。生有先后，学有先后，而得道有先后，此传道授业解惑之理也。饮之 酒六曰后生。青松苍苍，江水泱泱，焉知后之来者之不如今。饮之 酒七曰独独之我。知之者，我也。好之者，我也。乐之者，我也。无我，如天地人伦何？饮之 酒八曰爱恨。无我亦无爱，无我亦无恨，无爱无恨，如我何？饮之 酒九曰无。人死如灯灭，喜何如哉。饮之 九则老矣，过犹不及。饮九杯酒，酸甜苦辣俱有，喜怒哀乐皆在其中矣。不如饮之，不如饮之</description>
    </item>
    
    <item>
      <title>小王二三事</title>
      <link>http://www.wbprime.me/posts/2015-05-16-xiaowang-ersanshi/</link>
      <pubDate>Sat, 16 May 2015 19:07:06 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-xiaowang-ersanshi/</guid>
      <description>1 小王是我的一个朋友，很好的朋友。 有一天，他跟我说，“最近想换工作了，帮忙推荐一个呗！” 我想了想，问了一句，“###公司想去吗？” “没听说过，不去。其实我也不是非得大公司才去，就是觉得去了一家小小小公司发展不开！” 我又想了想，问，“@@@公司如何？” “老加班，去了受不了。其实我也不是怕吃苦，就是觉得人不能只有工作，也该留出时间诗意地生活！” 我又想了想，“%%%公司？” “听说待遇一般啊。我觉得就这待遇我离职也没有意义啊！” 说完他有点不好意思，解释了一下，“其实差不多都可以，你再想一想？” 我觉得还是先摸好底，问他当时为啥找的现在这家单位。 他顿时脖子就粗了，红着脸给我急，“当时还不是想着要找一个待遇好一点的工作，最好不怎么加班还得有面子嘛！不就折中到这里了撒。”
2 小王最近有点迷茫。 我问他原因。 他说，“在燕城工作了两年，觉得不怎么适应，压力又大；想回老家徽城吧，又放心不下这里的繁华，奈何啊奈何！” 小王是徽城人，读大学来的燕城，三年研究生之后在这里找了份工作。 我问，“你要是回去徽城了还能再来燕城吗？” 一言而决。
3 小王跟女朋友闹别扭，跟我吐槽，“心情好的时候就是如胶似漆吧，心情一不好就是各种吵架生气。关键是心情老不定，下一秒就爆发了。” 我跟他说，“等小二心情好的时候跟她约法三章好了，不要在她心情不爽的时候硬碰硬。” 小二就是她女朋友。 他说，“一说这个事她心情就不好！”
4 小王跟我说，“听我的你找女朋友一定要找一个性格温柔一点、脾气小一点、懂得给男朋友留面子的，不然就是又受气又吃亏的下场。” 我明白他在说小二。 他又说，“女朋友一碰火就着，没来由的，这个对将来没好处。” 他还是说小二。 我说，“两个人和则在一起，不和则分。老是盯着双方的缺点，最后肯定会分的”</description>
    </item>
    
    <item>
      <title>去所对</title>
      <link>http://www.wbprime.me/posts/2015-05-16-qusuodui/</link>
      <pubDate>Sat, 16 May 2015 19:04:12 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-qusuodui/</guid>
      <description>王生与聂生俱供职于华北所，以聂年长，故事于聂。 春，荧惑犯于角，凶。王生于是有去意，白聂曰愿乞骸骨。 聂生问曰，凤凰非梧桐不栖，子去，寡人之过也，不然，何以匆匆求去。 王生对曰，吾闻之，昔者唐尧教化天下而许由藏深山，世人皆称尧氏之治而不非失人之过也。武王伐一夫纣而伯夷死首阳，后世咸多武王之功而不讽杀人之罪也。且夫小人长不满八尺，书不足五车，熙熙攘攘之人也，一旦不识黄钟雷鸣，只求蝇蝇苟且，岂敢害君盛德。 问曰，虽然，何以去之急也。 对曰，唯唯，否否。吴王夫差失败于勾践者，何也，死生之事对以妇人之仁也。淮阴侯信死于宫人之手者，何也，当断不断反受其乱也。去所之事，虽小亦大，缓而图之，病矣。大者害君之宏图大计，小者伤吾之经济根本。急于求去，是不得已也，唯君察之。 聂生曰，天下未定，君子就食何处。 答曰，贱名不足以辱君贵耳。 问曰，然则何以强于华北所。 答曰，不然，各有优劣而已。华北所主用心而臣用力，声名 播于中国，天下英雄慕之久矣。承国之重器而保密重于泰山，大忠也；萧规曹随代码不改者，大智也；重情谊而轻五斗之禄，大义也。大忠大智大义之人，君子皆爱之也。 问，然则何以去之。 曰，吾辈小人也，何足道哉。 聂生默然，曰，吾知之矣。 夫大人者，先臣下之忧而忧，后臣下之乐而乐是也。夫饥则食，寒则衣，人之常情也。不食则殍，不衣则馁。食臣下之食致臣下食不果腹，衣臣下之衣致臣下衣不蔽体，然后曰人才不我用也。岂人才不我用耶，我不用人才也。 王生于是去华北所。</description>
    </item>
    
    <item>
      <title>所办趣事</title>
      <link>http://www.wbprime.me/posts/2015-05-16-suoban-qushi/</link>
      <pubDate>Sat, 16 May 2015 19:01:57 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-suoban-qushi/</guid>
      <description>离职手续需要所长书记签字。 所长书记在机关小楼里，渐次而邻。小楼东向，东西扩展，中间有天井，北屋落地窗采光，然后走廊，然后办公室南北向，左窗右门，所长书记居于其中。小楼红砖黑瓦，左右松柏，杂以四季青，梧桐拱卫四周，肃穆庄严，溢于言表。 从东门入寻所长书记，须从所办过一小玻璃门。所办者，华北所办公室也。所长书记身居重位，平日觥筹交错，日理万机，在所里之日少而在所外之日多也；而员工出入境入离职一切手续皆须所长签字书记盖章才行，故而特设所办下接员工一切事宜，统而交由所长书记办理之后，再交返个人，以提高工作效率。原之约莫古之中书省、龙图阁是也。 办理离职需要所长书记签字，故而直接去机关小楼了。一入门，碰着所办秘书。所办秘书，所办执事也。具以所办事宜白所办秘书。所办秘书将文件搁下，曰退下。 于是等待所办秘书电话，上午过去了。 于是等待所办秘书电话，下午过去了。 于是等待所办秘书电话，翌日上午过去了。 翌日下午，遇一同事去找所长书记签字，遂结伴而行。入门，同事直接穿玻璃门而去，过所办而不入。至所长办公室，敲门招呼签字谢谢关门；至书记办公室，敲门招呼签字谢谢关门。然后手续完成。 吾至所办秘书处交涉，发现只有所长签字而无书记盖章。所办秘书让吾自己去找书记，如果不愿意等待。 于是至书记处，签字，离开。 十分钟之事，拖累两日还不完。两日之事，如之奈何。 所办趣事，记之。</description>
    </item>
    
    <item>
      <title>起来(live)</title>
      <link>http://www.wbprime.me/posts/2015-05-16-qilai-live/</link>
      <pubDate>Sat, 16 May 2015 17:27:36 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-qilai-live/</guid>
      <description>这首歌的原唱版本是什么四分卫啥的，没有听说过之前，孤陋寡闻的说。
然后在网易云音乐的歌单上看到这首歌，五月天DNA，就点了一下。
音乐起，耳朵一亮。
气势恢宏的配乐，铺天盖地的潮水汹涌而来，先声夺人。
然后是起来。
起来。好一种奇怪的感觉。长在红旗下的我们，说到起来，不自然地就会哼出那段旋律，哒哒哒，不愿做奴隶的人们。。。
接下来的几句就觉得很违和。
然后先声夺人之后，杏红开始低吟浅唱，开始抒情。
这之前我没有看歌词，听着主歌旋律和歌词，大约的确是五月天的风格，感伤但又要充满希望，叛逆又那么找不到方向。
接着往下听，没有惊艳的意思。
然后，于是我闭上眼睛去抚摸。
然后，在那黑暗中挣扎的光线。
然后，于是我又开始这疼痛感觉。
赞。
我连忙点开歌词，对着歌词往下听。
越听越惊喜，大概是因为live版开始大合唱了，渐渐情绪投入了，觉得歌词大赞，歌曲大赞，合唱大赞。
就又听了一遍，一边翻看评论，才发现原唱不是五月天，是叫什么四分卫的乐团。
于是找了原唱的版本，听了几句，不知道为啥有点很乏味的意思，不知道因为改编的原因，还是live气势很足的样子，杏红唱的版本很有劲儿，原唱太娘。
心情不好的时候听一遍，能显著调整情绪振奋精神。不过重复播放性不强。
起来 作词：陈如山 作曲：陈如山 起来 我要你看得见 再大的风雨要用力飞 起来 或许你觉得累 记得我 在末日来临之前 海浪在退潮之前 将我消失在泡沫里面 我承受这份孤单 留下脚印在沙滩 远方灯火通明 让海和天一样黑 微风吹动风帆 失去引力向前追 突然间我才发现 前方灯塔已熄灭 我又被影子拉回地面 被夜晚冷却的沙滩 快乐悲伤浮在上边 无法抗拒这味道 让空气分割我的脸 忽然间我才了解 就在起飞的那一瞬间 我不能独自在海上漂浮 于是我闭上眼睛去抚摸 在那黑暗中挣扎的光线 于是我又开始这疼痛感觉 起来 我要你看得见 再大的风雨要用力飞 起来 或许你觉得累 记得我 在末日来临之前 感觉全身在颤抖 无法用心对齐你我的脚步 太多太快来不及去接受 太多太远太过份执着 鼓起勇气才看见失去理由 起来 我要你看得见 再大的风雨要用力飞 起来 或许你觉得累 记得我 在末日来临之前 起来 我要你看得见 再大的风雨要用力飞 起来 或许你觉得 觉得累 记得我 在末日来临之前 起来 起来 起来 起来 起来 起来 起来 起来 起来 起来 起来 起来 起来 起来 起来 起来 起来 记得 我在末日来临之前  </description>
    </item>
    
    <item>
      <title>非常六加一</title>
      <link>http://www.wbprime.me/posts/2015-05-16-feichangliujiayi/</link>
      <pubDate>Sat, 16 May 2015 14:44:12 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-feichangliujiayi/</guid>
      <description>人生如逆旅，年轮旋转压出一条车辙通向远方，远方是终点也是起点。起点叫死亡，终点叫希望。 希望，是什么希望？ 解脱的希望。 周一之后是周二。 周二之后是周三。 周三之后是周四。 周四之后是周五。 周五之后是周六。 周六之后是周七。 为什么没有周七？ 因为周七这个词太悲观了，周而复始已经够让人绝望的了，还要叫周期。宿命也未免欺负人得太赤裸裸了！ 所以说那一天肯定不能叫周七。 人生就是一个周期。 人生也是无数个周七。 犯错，然后咽下苦果。咽下苦果，然后再次犯错。 周一，起床跟自己说要好好享受生活，晚上跟自己说加班就是享受生活。 周二，起床跟自己说上班要简洁高效，晚上跟自己说拖拖沓沓显得从容。 周三，起床跟自己说从容不迫方显自信，晚上跟自己说人在屋檐下不得不追着项目目进度跑。 周四，起床跟自己说时光如梭分秒必争，晚上跟自己说人是生灵须要劳逸结合。 周五，起床跟自己说轻轻松松收官之战，晚上跟自己说人行百里半九十。 周六，起床跟自己说要积极进取锻炼身体，晚上跟自己说睡觉睡觉睡觉最大。 终于，周日了，醒了，终于决定要好好享受生活。看了看表，下午三点了，那么明天再说吧！ 这样，周七就过去了，下一个周七就要来了。 有人说，明天还有就是希望，今天只是现在，未来永远是无限可能。 是的，今天才是周五，何必着急？ 周七过去了，下一个周七还回来的。 下一个周七总要来的。</description>
    </item>
    
    <item>
      <title>记怀柔烧烤</title>
      <link>http://www.wbprime.me/posts/2015-05-16-ji-huairou-shaokao/</link>
      <pubDate>Thu, 14 May 2015 08:23:02 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-ji-huairou-shaokao/</guid>
      <description>一 缘起 过了清明，天气转暖。身在帝都也终于感受到了一丝春意，欣欣然，在点点花香环绕下生出来两分造化自然物我合一的感觉来。然而，花香再香，也只是一袖花香；柳条再绿，也只是一丝柳绿；何如万紫千红、千丝万缕呢？
然则，帝都怀抱于燕山之中，却突兀于群山之间。所谓春草年年绿，春风不过门。帝都，人多，春风少。
正好同事田氏在怀柔家开了农家乐，迎宾好客，生意兴隆。田氏为人多逸气，有感于柳绿花红鸟飞风鸣之意，颇生踏青之心冶游之意。于是振臂一呼，应斯人胸中之意，又利用自家便利，定下了西元四月十八烧烤之约。
二 出发 是日。
早七点，闹铃响了，身体开始冷启动。初始化引导区和内核，三分钟。初始化硬件，两分钟。启动基础服务，三分钟。启动工作环境，两分钟。完毕，可以起床了。
刷牙洗脸，饭也来不及吃就上去地铁，发动行程。
八点二十，同事孟某汪某杜某出现，四人碰头，坐上916，兴致勃勃朝怀柔进发。
今天是周六，出城的人多。人多就车多，车多就堵车，堵车就慢。本来预想的是人在江上游，水在两边流。结果是寻寻、觅觅、寻寻。车子以瓜牛的速度行驶，不一会儿人就昏昏欲睡了。
昏昏然，昏昏然，然后就到了。大约历时两个半小时。
下车之后，寻了一道公交，过了不用十五分钟就到站。
下车之后，用力呼吸一口大怀柔的空气。果然，果然不愧是出产大板栗的地方，空气就是清新一个赞。
三 砸炭 进了田氏庄园大门，迎面是天井里面一畦畦的菜园。农家乐，果然名副其实。
烧烤，首先有凉菜，然后有串，然后有架子。最重要的是什么？当然必须是要有炭了。
其他几个人在哪里穿串，我自领了砸炭的大令。半天，砸了一簸箕的碎炭。没累出一身大汗，双手沾上了满满黑灰。
田氏在厨房炖鸡，香味飘散，让人食指大动。
四 烤串 终于开始烤串了，我跃跃欲试。按照指导说明开始端着烤串盘，架上羊排，喷上孜然粉、粉盐粒和胡椒粉，之后羊肉的香气扑面而来，赞一个。烤完了羊排开始烤肉串。我把羊排烤的香喷喷，也想把肉串烤的香喷喷。结果跟想象的完全不一样，羊排肉厚，结果对火候的考验不高；肉串量小，火一大就黑了。结果第一把肉串烤出来有点焦。
之后果断让高手烤。然后试了试手，烤了一下鱼。鱼不耐烤，只用稍稍用火就可以了，芳香四溢，超级赞。烤出来鱼肉又白又嫩又爽又滑，口感非常赞。
五 宴席 吃饭的时候，八个人围成一圈，开始一边烤肉一边吃。
菜有烤羊排、烤串、烤鱼、骨肉相连、烤鸡翅，还有炖鸡、冰虹鳟鱼、炸虾和一些凉菜。
喝的有鲜橙多，和啤酒。
大家一起吃饭，不一会儿就玩起来了真心话大冒险，够劲爆。
六 归程 吃完了之后，帮忙收拾完桌子，大家就开始回去了。
天气不是很晴，头顶一片雾蒙蒙，不知道是阴了天还是雾霾。春天就是如此，阴晴变化，造化阴阳。
大家一起走到车站，有说有笑。坐上916路长途车，回家在望。
在车站，大家依依惜别，挥手道别，笑容满面。心中满是不舍。</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://www.wbprime.me/posts/2015-05-16-hello-world/</link>
      <pubDate>Wed, 13 May 2015 12:30:23 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2015-05-16-hello-world/</guid>
      <description>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick Start Create a new post $ hexo new &amp;quot;My New Post&amp;quot;  More info: Writing
Run server $ hexo server  More info: Server
Generate static files $ hexo generate  More info: Generating</description>
    </item>
    
    <item>
      <title>坚持住 外婆</title>
      <link>http://www.wbprime.me/posts/2014-05-16-jianchizhu-waipo/</link>
      <pubDate>Fri, 16 May 2014 20:09:06 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2014-05-16-jianchizhu-waipo/</guid>
      <description>外婆 小时候跟你一起长大
现在 长大了外婆却老了
还记得那时 大清早去一起别人家的栗子树下面捡板栗
还记得那时 偷摸摸把我叫到房间塞给我一大把糖果
还记得那时 跑到山上面去摘茶树果子一边唱山歌
还记得那时侯的外婆拉着我的手 讲解放前的新鲜事儿 夜空中繁星闪烁 萤火虫在身边上下翻舞
那是外婆
这几年在外面游荡 外婆不经意间就老了
老着老着 不经意间身体就差了
上上周回家 7月9号去看的外婆 拉着她的手 她看着我 说 泼你来了
现在想起来 潸然泪下
现在出了意外 希望她老人家逢凶化吉 恢复健康
人生在世 其实值得哭一场的只有那么几个人 有些事情 如果缘分已尽 就不必强求了
外婆 愿你安静走过</description>
    </item>
    
    <item>
      <title>突然想起注释来</title>
      <link>http://www.wbprime.me/posts/2014-05-16-turan-xiangqi-zhushi-lai/</link>
      <pubDate>Fri, 16 May 2014 20:03:36 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2014-05-16-turan-xiangqi-zhushi-lai/</guid>
      <description>很奇怪的念头突然在脑中浮现出来：为什么代码中可以有注释？
先来看看C/C++的代码：
int main(int, char **) { ...... int a; doSomthing(a); // maybeDosomthing(a); ...... return 0; }  这一行：// maybeDosomthing(a);说明了注释的用途。可能作者原来想干点什么事情，然后在后续的过程中又改变了主意。
注释在这里起到了一个后悔药的作用，以前的东西先暂时保存起来，在当前消失，在未来可能再现。
然而，版本控制工具可以达到更好的效果，不需要注释：不是代码本身，而是额外的载体记录代码改动的变化。过去就是过去，历史就是历史。过往的可以存在于记忆中，可以记录在空气里，但是却不能再回来了。
没有事情会永远不变，也没有东西永远改变。希望过去的要过去，过去了就过去。
什么乱七八糟的，自己都不知道自己在说什么。
在南京第二天了，昨天晚上吃完饭心情极其低落。打了个车走上长江边上，夜晚中的江流起伏，暗涌的潮声淹没在夜幕里。听得见去看不见，听见了就会很害怕，害怕未知，害怕黑暗，害怕恐惧。凉风侵袭过来，漫天的都是黑夜，看不见江水，看不见灯光，看不见北京。
谨记之！</description>
    </item>
    
    <item>
      <title>知足</title>
      <link>http://www.wbprime.me/posts/2013-05-16-zhizu/</link>
      <pubDate>Thu, 16 May 2013 21:08:50 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-zhizu/</guid>
      <description>一直很喜欢这首知足；但是一直也不想写这首知足。
为什么？
因为知足，当然是在经历过失去的悲痛欲绝和求不得的纠结难耐之后，才明白的要珍惜拥有的惶惶然和主动放手的戚戚然。
所以知足，是一种决然。
但是，不知天高地厚的人，怎么知足，怎么知道知足？
得到了，害怕失去；拥有了，害怕分离；即使过去了，也希望有一只时光机器。
也许是过去太美好了，也许是未来太残酷了。
也许是人太懦弱了。
也许是我太悲观了。
五月天，知足。
传说是六月份蟹子的最爱。
因为蟹子内心的敏感不安；也因为蟹子天性的内向消极。
什么是真实的？
什么是永恒的？
过去终究是梦诞的；未来永远是虚妄的。
失去的到底是别人的；追求的未必是自己的。
只有现在才是真实的；只有攥在手心能够听见自己心跳的才是永恒的。
所以要知足！
所以要知足。
知足 作词：阿信 作曲：阿信 怎么去拥有 一道彩虹 怎么去拥抱 一夏天的风 天上的星星 笑地上的人 总是不能懂 不能觉得足够 如果我爱上 你的笑容 要怎么收藏 要怎么拥有 如果你快乐 不是为我 会不会放手 其实才是拥有 当一阵风 吹来 风筝飞上天空 为了你 而祈祷 而祝福 而感动 终于你身影 消失在人海尽头 才发现 笑着哭最痛 那天你和我 那个山丘 那样的唱着 那一年的歌 那样的回忆 那么足够 足够我天天 都品尝着寂寞 当一阵风吹来 风筝飞上天空 为了你 而祈祷 而祝福 而感动 终于你身影 消失在人海尽头 才发现 笑着哭最痛 当一阵风吹来 风筝飞上天空 为了你 而祈祷 而祝福 而感动 终于你身影 消失在人海尽头 才发现 笑着哭最痛 如果我爱上 你的笑容 要怎么收藏 要怎么拥有 如果你快乐 再不是为我 会不会放手 其实才是拥有 知足的快乐 叫我忍受心痛 知足的快乐 叫我忍受心痛  </description>
    </item>
    
    <item>
      <title>生命有一种绝对</title>
      <link>http://www.wbprime.me/posts/2013-05-16-shengmingzhong-you-yizhong-juedui/</link>
      <pubDate>Thu, 16 May 2013 21:04:55 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-shengmingzhong-you-yizhong-juedui/</guid>
      <description>从来都不是一个豪气凌云的人，也从来没有经历过什么热血澎湃的岁月。
上学，考试，升学；上学，考试，升学；上学，考试，升学； 上学，考试，升学； 上学，然后呢？
放佛一下子就老了，突然之间觉得人生就这么没了。
不知不觉开始觉得，我不这样又如何？
开始想为什么活着，又要如何活着了。
这个世界有你不能到达的地方，有你不应到达的地方，有你一辈子也不会去到达的地方，你的世界并不如你想象的那么大，界限也许就在你的身边，可你却以为你可以去任何地方。 《悟空传》  你或许领悟到了，也或许没有领悟到，又或者这仅仅是一个错觉？
然而，你肯定会有这种感觉，那就是：
你以为你有很多路可以选择，但是在你四周有很多看不见的墙，其实你只有一条路可以走。 《悟空传》  或者一种命中注定的挫败感会缠着你，让你陷入某种玄之又玄的宿命之中。
是不是选择任何一个方向，都会游向同一个宿命呢？ 《悟空传》  这是所有生灵的悲剧，从空而来，又向空而去，经历了，却又不知道要经历什么。然后就死了。
死是什么也看不见，什么也听不见，什么也感觉不到，什么也不会想，就像你未出生时一样。 《悟空传》  只是，回忆中那个少年，为何依然不停的追？
我要天下再无我战不胜之物！ 《悟空传》  尽管，想要征服的世界，始终都没有改变。
他宁愿死，也不肯输。 《悟空传》  是的，生命有一种绝对！
绝对的不能放弃，绝对的不能认输，绝对的固执坚守最后的底线。
你跳不出这个世界，是因为你不知道这个世界有多大，一旦你知道了，你就超出了它。《悟空传》  勉之！
生命有一种绝对 作词：阿信 作曲：阿信 如果我不曾走过这一遍 生命中还有多少苦和甜美 那风中的歌声 孤单哽咽的声音是谁 回忆中那个少年 为何依然不停的追 想要征服的世界 始终都没有改变 那地上无声蒸发我的泪 黑暗中期待光线 生命有一种绝对 等待我 请等待我 直到约定融化成笑颜 那生命灿烂烟火般上演 你和我最后都要回归地平线 那留下的足迹 浪花冲走回忆海岸线 靠近我 再拥抱我 请不要让我的心冷却 想要征服的世界 始终都没有改变 那地上无声蒸发我的泪 黑暗中期待光线 生命有一种绝对 等待我 请等待我 直到约定融化成笑颜 想要征服的世界 始终都没有改变 那地上无声蒸发我的泪 黑暗中期待光线 生命有一种绝对 等待我 请等待我 直到约定融化成笑颜 想要征服的世界 始终都没有改变 那地上无声蒸发我的泪 黑暗中期待光线 生命有一种绝对 等待我 请等待我 靠近我 再拥抱我 不要走 请不要走 直到约定融化成笑颜 直到我看见生命的绝对  </description>
    </item>
    
    <item>
      <title>一颗苹果</title>
      <link>http://www.wbprime.me/posts/2013-05-16-yikepingguo/</link>
      <pubDate>Thu, 16 May 2013 21:03:17 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-yikepingguo/</guid>
      <description>累了，就停下来听这首歌。
倦了，也停下来听这首歌。
当你走着走着，突然忘了自己要往哪里走的时候。
当你飞着飞着，突然想起来没地方落下脚的时候。
当你努力努力，突然觉得自己很委屈无奈的时候。
也许，曾经的曾经早已变成了遗忘，未来的未来还只是幻想。
请记得，活着其实很好， 幸福刚好够用。
反正就这样吧，我知道我努力过，再吃一颗苹果！
一颗苹果 作词：阿信 作曲：阿信 经过了漫长的等候 梦想是梦想 我还是一个我 那时间忘记挽留 最美时候 不经意匆匆的放过 曾经想拥抱的彩虹 盛开的花朵 那纯真的笑容 突然有风吹过 那一转眼只剩我 我不懂 人世间的那些愁 他为什么要缠著我 到底这会是谁的错 还是我不放手 喔 人世间的那些愁 这世界给我的幽默 这是不是要告诉我 潮起终究潮落 总要有人来陪我 咽下苦果 喔 再尝一点美梦 要等你先开口 那冬天才会走 有些人经过我身旁 住在我脑中 在我心里钻洞 有些人变成相片 堆在角落 灰尘像雪一般冰冻 时间如果可以倒流 我想我还是 会卯起来蹉跎 反正就这样吧 我知道我努力过 我想到 遥远遥远的以后 会不会有人知道我 在这个寂寞的星球 曾这样的活过 喔 遥远遥远的以后 天长和地久的尽头 应该没有人能抢走 我永远的感动 总要有一首我的歌 大声唱过 喔 再看天地辽阔 活著不多不少 幸福刚好够用 活著其实很好 再吃一颗苹果  </description>
    </item>
    
    <item>
      <title>疯狂世界</title>
      <link>http://www.wbprime.me/posts/2013-05-16-fengkuangshijie/</link>
      <pubDate>Thu, 16 May 2013 21:01:44 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-fengkuangshijie/</guid>
      <description>五月天的歌曲，早期的代表作之一，疯狂世界。
我好想好想飞，逃离这个疯狂世界。
一无所有，又想拥有一切的年代。
失去了所有，绝望了存在的臆想。
恍惚间，那些曾经让我很热血很亢奋的词句都已经暗淡了下来。
好长时间没有去听这样一首歌了。
嗓音有一点稚嫩了，节奏有一点喧哗了。
然而，依然感动那一句。
你是一种感觉，写在夏日晚风里面。
不管怎样，五月天的词，总有能钻进你心里面去的。
疯狂世界 作词：阿信 作曲：阿信 如果说了后悔 是不是一切就能倒退 回忆多么美 活着多么狼狈 为什么这个世界 总要叫人尝伤悲 我不能了解 也不想了解 我好想好想飞 逃离这个疯狂世界 那么多苦 那么多累 那么多莫名的泪水 我好想好想飞 逃离这个疯狂的世界 如果是你 发现了我 也别将我挽回 想了你一整夜 再也想不起你的脸 你是一种感觉 写在夏夜晚风里面 青春是挽不回的水 转眼消失在指间 用力地浪费 再用力地后悔 我好想好想飞 逃离这个疯狂世界 那么多苦 那么多累 那么多莫名的泪水 我好想好想飞 逃离这个疯狂的世界 如果是你 发现了我 也别将我挽回 我好想好想飞 逃离这个疯狂世界 那么多苦 那么多累 那么多莫名的泪水 我好想好想飞 逃离这个疯狂的世界 如果是你 发现了我 也别将我挽回 我好想好想飞 逃离这个疯狂世界 那么多苦 那么多累 那么多莫名的伤悲 我好想好想飞 逃离这个疯狂的世界 如果是你 发现了我 也别将我挽回  </description>
    </item>
    
    <item>
      <title>九号球</title>
      <link>http://www.wbprime.me/posts/2013-05-16-jiuhaoqiu/</link>
      <pubDate>Thu, 16 May 2013 21:00:11 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-jiuhaoqiu/</guid>
      <description>不知道这首歌的主旨是什么，这首歌的内涵是什么。
也许这一首歌，写给的对象是那种不想去思考内涵和意义，也没来及思考的人们，写给当年那个意气风发、浮躁叛逆的少年的。
我只能逃走，奔向自由。
自由了，才是人生的终极意义。
但人生哪有什么终极的意义啊？
也许我这一生，始终在追逐那颗九号球，追逐那些年少的轻狂和自由的独立。
却忘了是谁在爱我。
却忘了，父母才是我来到这个世界的理由。
九号球 作词：阿信 作曲：怪兽 逃走 翻过围墙 我只能逃走 从教室里头 奔向自由 熟悉角落 有人在等我 有挑衅的笑容 今天谁先开球 让谁尝点苦头 绿色地平线上 我撞著彩色堕落 也许我这一杆 又没办法进球 就像我的生活 一直在出差错 也许我这一生 始终在追逐那颗九号球 却忘了 是谁在爱我 却忘了 是谁在罩著我 从前 书包很满 装不下的梦 就丢了一些 未来我们 要怎么活 凝视著白球 暂时我不去想 天空渐渐变红 影子爬满球桌 输赢没有结果 像人生难以捉摸 也许我这一杆 又没办法进球 就像我的生活 一直在出差错 也许我这一生 始终在追逐那颗九号球 却忘了 是谁在爱我 却忘了 是谁在罩著我 也许我这一杆 又没办法进球 就像我的生活 一直在出差错 也许我这一生 始终在追逐那颗九号球 却忘了 是谁在爱我 也许我这一杆 又没办法进球 就像我的生活 一直在出差错 也许我这一生 始终在追逐那颗九号球 却忘了 是谁在爱我 却忘了 是谁在罩著我  </description>
    </item>
    
    <item>
      <title>洗衣机</title>
      <link>http://www.wbprime.me/posts/2013-05-16-xiyiji/</link>
      <pubDate>Thu, 16 May 2013 20:57:59 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-xiyiji/</guid>
      <description>一首感怀母爱的歌曲，洗衣机应该是很平常。但是放在整张专辑里面来说，就有一些特殊的意味。
专辑名字叫作《第二人生》。
也许人这一辈子，最容易忽视的东西，其中有一样就叫做母爱。
洗衣机的前半部分，节奏轻快明了。
后半部分，听着听着就开始想起了小时候的那些场景。
那个骂你同时还紧紧抱着你的人啊。
那个厨房里炒菜时轻轻抹汗的人啊。
那个洗着衣服不时捶捶腰椎的人啊。
她总是不想你弱于人；也不想你累于己。
不管怎样，衣锦还乡，还是碌碌无为，那个女人，都是你的母亲。
母亲，对于你，只要健康快乐。
而已。
希望母亲，也要健康快乐，一定！
洗衣机 词：阿信 曲：怪兽 洗衣机 穿著一身退色塑料压克力 独坐在阳台上 受日晒风吹雨淋 电视机 孩子们目光都以他为中心 黑色简约外型 多适合客厅 就算是吹风机 也有流线外型 紧握在手心像 跳舞亲密 光荣的电唱机 晋身为古董级 典雅的中音比 谁都更受欢迎 木讷的洗衣机 从没有主题曲 只有风霜灰尘 让人不想接近 从来没有一句的怨言 你丢多少它都洗 脱水总是全心又全力 直到颤抖了身体 多少年了旋转又旋转 时间一眨眼过去 上了年纪却依然尽力 孤独勇敢洗衣机 咖啡机 欧洲进口带著书卷贵族气 孩子都长大了 爱围著它喝那堤 洗衣机 一直以来度量很大没心机 它的唯一关心 是何时放晴 就算是已退役 的那台光碟机 也带我经历冒 险和爱情 冰箱的肚子里 啤酒和冰淇淋 抚慰了多少失 眠和失恋的心 木讷的洗衣机 从学不会讨喜 洗过多少四季 然后再一世纪 所有电器都住在屋檐 下不必风吹雨淋 却只有它孤独的守在 阳台角落里运行 多少年了旋转又旋转 时间一眨眼过去 上了年纪却依然尽力 孤独勇敢洗衣机 突然有天好想要帮忙 衣服放进洗衣机 才发现了它早就坏了 只是舍不得换新 奇怪是谁一直清洗著 我闯的祸和污泥 好久以来原来我衣服 全部都是妈妈洗 从来没有一句的怨言 你丢多少她都洗 她却总是全心又全力 直到颤抖了身体 多少年了旋转又旋转 时间一眨眼过去 才发现了妈妈一直是 我无声洗衣机 才发现了她的皱纹是 无法偿还的借据 才发现了她的背影是 无法释怀的风景  </description>
    </item>
    
    <item>
      <title>我们</title>
      <link>http://www.wbprime.me/posts/2013-05-16-women/</link>
      <pubDate>Thu, 16 May 2013 20:56:25 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-women/</guid>
      <description>终于知道，为什么那么多人会信奉宗教？
世界的每一个角落里，遍布了上帝的信徒、安拉的仆人和佛陀的信众。
将自己的信仰放到一个自己理性上却只不会存在的存在上，让自己的心灵去向往美好，去追寻幸福。这是自我麻醉，也是自我救赎。
听过这首《我们（时时刻刻）》，突然觉得真善美，确实是我一直想追求的，也一直在追求的事物。
不知道阿信哪里来这么悲观绝望的黑暗？
希望所有的人幸福和快乐！
希望所有的人都充满了希望。
我们 词：阿信 曲：阿信 我为何要存在 为何要感慨 为何颤抖停不下来 你为何要推翻 为何要离开 为何给我这个答案 我们曾经那么精彩 我们曾经那么期待 最后你把回忆还我 要我好好过 你话中的计算 准确的伤害 像精心打造的对白 我划开了动脉 也许不醒来 至少昨天无法毁坏 我们曾经那么精彩 我们曾经那么期待 最后你把回忆还我 要我好好过 我们最后这么遗憾 我们最后这么无关 时时刻刻每个现在 都在嘲笑我 我们曾经那么精彩 我们曾经那么期待 最后你把回忆还我 要我好好过 我们最后这么遗憾 我们最后这么无关 时时刻刻每个现在 都在嘲笑我 我们曾经那么精彩 我们曾经那么期待 最后你把回忆还我 要我好好过 我们最后这么遗憾 我们最后这么无关 时时刻刻每个现在 都在嘲笑我 嘲笑着我  </description>
    </item>
    
    <item>
      <title>米老鼠</title>
      <link>http://www.wbprime.me/posts/2013-05-16-milaoshu/</link>
      <pubDate>Thu, 16 May 2013 20:53:27 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-milaoshu/</guid>
      <description>五月天的歌曲确实写的很有新意。
不管是纯真、温柔还是倔强，明明是已经写无可写、唱无可唱的主题，明明是已经山穷水尽，竟然真的可以柳暗花明。
这一首米老鼠，就是阿信创作才情之汪洋奔肆的绝佳体现。
以为我爱著孤独；以为自己不会迷路；以为自己跟自己，再不用谁照顾；以为我爱著孤独，却又崩溃的无助。
这样一句词，醍醐灌顶，顿时让我动弹不得。
曾几何时，年少轻狂；曾几何时，鲜衣怒马。
冠盖满京华，斯人独憔悴。
人生天地间，忽如远行客。
有一天累了，倦了，乏了，跌倒在命运里面，哪里会有，那样一只，米老鼠。
谁能让我拥抱著，尽情的哭 ？
谁又会扶着我，说一句，辛苦了！
米老鼠 词：阿信 曲：怪兽 一身黑皮肤 白手套红短裤 一双大大耳朵 随时在 向人打招呼 他是我朋友 陪我笑陪我哭 尤其是当我 当我最无助 有他 听著我倾诉 梦中 城堡里面跳舞 醒了 世界依然残酷 以为我爱著孤独 以为自己不会迷路 以为自己跟自己 再不用谁照顾 以为我爱著孤独 却又崩溃的无助 谁能让我拥抱著 尽情的哭 谁是草莓族 你才是榴连族 一身伤 仍顽固 伤害我 还要我不哭 摩天轮停住 咖啡杯不跳舞 孩子练习著 让悲伤麻木 快乐 也开始麻木 梦中 城堡里面跳舞 醒了 世界依然残酷 以为我爱著孤独 以为自己不会迷路 以为自己跟自己 再不用谁照顾 以为我爱著孤独 却又崩溃的无助 谁能让我拥抱著 尽情的哭 让我唯一的朋友 不是老鼠 让我唯一的朋友 不是老鼠  </description>
    </item>
    
    <item>
      <title>仓颉</title>
      <link>http://www.wbprime.me/posts/2013-05-16-cangjie/</link>
      <pubDate>Thu, 16 May 2013 20:50:09 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-cangjie/</guid>
      <description>如果世界上不存在语言与文字，我们的相遇，究竟是命运或几率？
如果世界上不存在语言与文字，我们的曾经，究竟是真实或梦境？
《淮南子 本经训》：昔者仓颉作书，而天雨粟，鬼夜哭；伯益作井，而龙登玄云，神栖昆仑。能愈多而德愈薄矣。故周鼎著倕，使衔其指，以明大巧之不可为也。 仓颉造字，开民智，教化了天下百姓。而天下也开始美美恶丑，追逐欲望。  故而老子摒弃仁义，专讲道德。
《道德经》：大道废，有仁义；慧智出，有大伪；六亲不和，有孝慈；国家昏乱，有忠臣。 《道德经》：绝圣弃智，民利百倍；绝仁弃义，民复孝慈；绝巧弃利，盗贼无有。  然而，仓颉造字，创造光同时也创造了暗。然而若非有消极阴冷的暗，光的美好怎会那样吸引人？
爱。
有一句话，叫永远。
有一句话，叫我爱你。
有一句话，叫至死不渝。
有一句话，叫执子之手，与子偕老。
有一句话， 天雨粟，鬼夜哭，思念漫太古。
有些东西，错过了就不再拥有；有些事情，经历了就难以忘怀。
如果可以，我愿意为你写诗，用最美丽的文字描绘你的容颜，和我的思念。
突然好想你，那是想念；听仓颉，是在思念。
仓颉 词：阿信 曲：石头 一颗葡萄有多甜美 用尽了所有的图腾和语言描写 想一个人有多想念 那又是文字失效瞬间 结一个纪念的绳结 记录你离去后万语和千言瓦解 升起了慌张的狼烟 我遗落在最孤独史前的荒野 多遥远 多纠结 多想念 多无法描写 疼痛和疯癫 你都看不见 想穿越 想飞天 想变成 造字的仓颉 写出能让你 快回来的诗篇 一只蝴蝶有多鲜艳 能不能飞越过猜忌和冷漠世界 给你的简讯和留言 说不清万分之一追悔 当星宿都沉没山岳 只盼你会抬头看我寄托的弯月 当一个文明即将熄灭 有什么证明你我存在的岁月 多遥远 多纠结 多想念 多无法描写 疼痛和疯癫 你都看不见 想穿越 想飞天 想变成 造字的仓颉 创造能让你 想起我的字眼 多遥远 多纠结 多想念 多无法描写 疼痛和疯癫 你都看不见 想穿越 想飞天 想变成 造字的仓颉 写出能让你 快回来的诗 需要你 需要你 需要你 想逆转时间 回到最开始 有你的世界 想穿越 想飞天 想变成 造字的仓颉 写出让宇宙 能重来的诗篇 天雨粟 鬼夜哭 思念漫太古  </description>
    </item>
    
    <item>
      <title>后青春期的诗</title>
      <link>http://www.wbprime.me/posts/2013-05-16-houqingchunqi-de-shi/</link>
      <pubDate>Thu, 16 May 2013 20:46:59 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-houqingchunqi-de-shi/</guid>
      <description>青春之後，认输之前，我在哪里？
没有假若，没有如果，只有命中注定。
命中注定我们会在肆无忌惮的懵懂和天真之后，步入成年人的世界。
既然已经无法避免，那么就坦然接受。
如果未来是激情四射的阳光，那么就去尽情地享受；
如果未来是雾霭茫茫的寂寥，那么就去释放出自己的光和热。
谁说不能让我此生唯一自传，如同诗一般？
青春之后，认输之前，我依然用力的活著。
后青春期的诗 词：阿信 曲：阿信 当烟雾随晨光飘散 枕畔的湖已风乾 期待已退化成等待 而我告别了突然 当泪痕勾勒成遗憾 回忆夸饰著伤感 逝水比喻时光荏苒 终于我们不再为了生命狂欢 为爱情狂乱 然而青春彼岸 盛夏正要一天一天一天的灿烂 谁说不能让我此生唯一自传 如同诗一般 无论多远未来 读来依然一字一句一篇都灿烂 让天空解释著蔚蓝 浮云定义着洁白 落花铺成一片红色地毯 迎接我们到未来 精彩未完的未来  </description>
    </item>
    
    <item>
      <title>小时候</title>
      <link>http://www.wbprime.me/posts/2013-05-16-xiaoshihou/</link>
      <pubDate>Thu, 16 May 2013 20:43:42 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-xiaoshihou/</guid>
      <description>时间是一把无情的刻刀，将最纯真磨灭，将最梦想销毁，将曾经的小时候变成现在的长大后。
那时候，棒棒糖还是甜的。
那时候，星空还是明亮的。
那时候，唐僧心还是好的，悟空还是降妖伏怪的，猪八还是懒懒的，沙僧还是忠厚老实的。
那时候，女孩子还是要穿衣服的。
那时候，男孩子结婚是过家家的。
长大了，经历了，也成熟了。
毛毛虫从厚厚的茧中爬出来的时候，蜕变成了美艳的蝴蝶。
成长了也就蜕变了。
收获了一身的万众瞩目和丰功伟业。
留下了遍体的伤痕累累与疲惫重重。
失去了的呢？
怀念小时候，其实是对于现实产生了迷惘和怀疑。
我究竟得到了什么？
我究竟失去了什么？
当你的心已累，以为失去了一切，其实等在前面还有一整个世界；
当你的爱已碎，以为纯真会幻灭，其实等在前面还有一整个新的视野，新的起点。
谢谢张雨生，谢谢五月天。
我终于知道了，展翅高飞那是雄鹰的宿命，也是雄鹰独一无二的骄傲。
飞起来，像海燕一样，向风暴最猛烈的地方飞去吧！
历经风雨不褪色，这才是我的本色。
小时候 词：张雨生 曲：阿信 小时候 我一直有个梦 有一天 我要飞上外太空 就像夏夜繁星闪烁 幻想我能穿梭其中 你有没有过 你有没有过 小时候 渴望硕壮的成熟 长大后 我有雪亮的天空 风雨却让世界不同 面对遍体鳞伤的痛 你有没有放弃梦想的冲动 当你的心已累 以为失去了一切 其实等在前面 还有一整个世界 当你的爱已碎 以为纯真会幻灭 其实等在前面 还有一整个新的视野 新的起点 小时候 我一直有个梦 有一天 我要飞上外太空 即使越来越淡的星座 越来越远的神话传说 我不会忘记在夏夜里的时空遨游 当你的心已累 以为失去了一切 其实等在前面 还有一整个世界 当你的爱已碎 以为纯真会幻灭 其实等在前面 还有一整个新的视野 新的起点 当你的心已累 以为失去了一切 其实等在前面 还有一整个世界 当你的爱已碎 以为纯真会幻灭 其实等在前面 还有一整个新的视野 新的起点  </description>
    </item>
    
    <item>
      <title>2012</title>
      <link>http://www.wbprime.me/posts/2013-05-16-2012/</link>
      <pubDate>Thu, 16 May 2013 20:39:50 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-2012/</guid>
      <description>这首歌词，大爱啊！
总是在失去之后才会珍惜拥有。
总是在绝望里面坚持追寻希望。
五月天，亲手为我们描绘了末日的景象。
毁灭，还不够毁灭；绝望，还不够绝望。
落叶剂制造落叶的秋；辐射尘覆盖清晨的冬。
摘一颗星星，要盖高楼；爱一种自由，燃尽石油；追一种富有，却要挥霍。
寄生地表的虫，我们啊，是先坠落，或先坠入自甘堕落？
今天，珍重，谁知道是真是梦？
我们啊，将变星尘，永远飘在黑暗宇宙。
明天过后，是解答或解脱？
如果你在幸存的平行宇宙，请记得这首歌预言过。
要怎么做，要怎么活，请你对自己说 ！
PS：看了诺亚方舟和第二人生的MV，对2012的MV报了太大期待，结果很失望。想想也是，诺亚方舟是要给人以希望，所以MV恢弘大气；第二人生是劝人奋进，所以MV细腻动人；2012的歌词太过绝望，只能配以Mayday的现场，期许稍解人们的不安和恐惧吧！
2012 词：阿信 曲：阿信 再没有时间 能去延后 再没有后路 能去逃脱 再没有备案 没有逃生线索 再没蓝色天空 我突然想到 小的时候 总等着长大 去追的梦 就这么活着 突然西元尽头 却没有一件 真的去做 再看 最后一眼 青春的星空 灿烂 火光就像 盛夏的烟火 欢送 挣扎万年 文明的巅峰 我们啊 将变星尘 永远飘在黑暗宇宙 今天 珍重 谁知道是真是梦 明天 过后 是解答或解脱 摘一颗星星 要盖高楼 爱一种自由 燃尽石油 追一种富有 却要挥霍 寄生地表的虫 落叶剂制造 落叶的秋 辐射尘覆盖 清晨的冬 地球还残喘 人就创作末日 又何必等到 上帝没收 谁把 愉快的愉 换 偷窃的偷 难道 自找的找 是 自我的我 终于 未来的未 变 末日的末 我们啊 是先坠落 或先坠入自甘堕落 今天 珍重 谁知道是真是梦 明天 过后 解答或解脱 如果 你在 幸存的平行宇宙 请记得我 曾这么预言过 这首歌预言过 听着 无人电台 最终的播送 那些 爱过的歌 像浩瀚乡愁 花朵长出云朵 弹头落在街头 我们啊 停不下来 以为闯关 却在闯祸 今天 珍重 谁知道是真是梦 明天 过后 解答或解脱 如果 你在 幸存的平行宇宙 要怎么做 要怎么活 请你对自己说 诚实对自己说 快对自己说  </description>
    </item>
    
    <item>
      <title>星空</title>
      <link>http://www.wbprime.me/posts/2013-05-16-xingkong/</link>
      <pubDate>Thu, 16 May 2013 20:37:45 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-xingkong/</guid>
      <description>我问你，摸不到的颜色是否叫彩虹？
我问你，看不到的拥抱是否叫作微风？
每一个生灵都是天上的星宿，究竟星星还发不发光？
此时此刻，星空一片灰蒙蒙。
如果，给我一杆杠杆，我就能撬动地球。
结果，我只剩下半斤纯真和一两高尚。
曾经的初衷太也天真。
现实的苦衷太也无奈。
原来所有所得所获，不如一夜的星空。
不如，那一年我们一起望着的星空。
星空 词：阿信 曲：石头 摸不到的颜色 是否叫彩虹 看不到的拥抱 是否叫做微风 一个人 想着一个人 是否就叫寂寞 命运偷走如果 只留下结果 时间偷走初衷 只留下了苦衷 你来过 然后你走后 只留下星空 那一年 我们望着星空 有那么多的 灿烂的梦 以为快乐会永久 像不变星空 陪着我 猎户 天狼 织女 光年外沉默 回忆 青春 梦想 何时偷偷陨落 我爱过 然后我沈默 人海里漂流 那一年 我们望着星空 未来的未来 从没想过 当故事失去美梦 美梦失去线索 而我们失去联络 这一片 无言无语星空 为什么静静 看我泪流 如果你在 的时候 会不会伸手 拥抱我 细数繁星闪烁 细数此生奔波 原来 所有 所得 所获 不如一夜的星空 空气中的温柔 回忆你的笑容 彷彿只要伸手 就能触摸 摸不到的颜色 是否叫彩虹 看不到的拥抱 是否叫做微风 一个人 习惯一个人 这一刻 独自望着星空 从前的从前 从没变过 寂寞可以是忍受 也可以是享受 享受仅有的拥有 那一年我们望着星空 有那么多的 灿烂的梦 至少回忆会永久 像不变星空 陪着我 最后只剩下星空 像不变回忆 陪着我  </description>
    </item>
    
    <item>
      <title>纯真</title>
      <link>http://www.wbprime.me/posts/2013-05-16-chunzhen/</link>
      <pubDate>Thu, 16 May 2013 20:35:19 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-chunzhen/</guid>
      <description>首先，这是一首情歌。
然后，这一首让人绝望的情歌。
今晚的天空有一颗流星划过，在预言着什麽？
依稀记得梁静茹演唱这首歌的时候，玛莎为她弹钢琴伴奏。
静茹脸上的淡淡的笑，真的很让人心动。
在无声之中你拉起了我的手。
我怎么感觉整个黑夜在震动。
耳朵里我听到了心跳的节奏。
星星在闪烁，你会怎么说？
阿信说，我们在夜晚偷偷地听自己心脏的跳动，应该不忍心将这个纯洁的心弄脏才是。是啊，这样的美好，就算在梦里，也会满足到偷笑的。然而。
你已经有他就不应该再有我，世界的纯真此刻为你有迷惑。
我想我应该轻轻放开你的手，我却没有力气这么做。
我却没有力气这么做。
没有力气，这么做。
玛莎写的，到今天才知道，放手比握手更需要力气和勇气。
其实，你当时还是不知道。
想想玛莎和静茹当初的默契，再看看此刻的境遇。
一言成谶。
想不明白，为什么那时候静茹要唱这首歌？
又为什么，玛莎写下了那一句话？
玛莎，静茹。
纯真，五月天。
纯真 词：阿信 曲：阿信 长长的路上 我想我们是朋友 如果有期待 我想最好是不说 你总是微笑的你 总是不开口 世界被你 掌握 月亮绕地球 地球绕着太阳走 我以为世界 是座宁静的宇宙 今晚的天空 有一颗流星划过 在预言着 什么 在无声之中 你拉起了我的手 我怎么感觉 整个黑夜在震动 耳朵里我听到了 心跳的节奏 星星在闪烁 你怎么说 你心中一定 有座浓雾的湖泊 任凭月光再 皎洁照也照不透 你眼中闪烁湖面 无边的温柔 那波光在 诱惑 在无声之中 你拉起了我的手 我怎么感觉 整个黑夜在震动 耳朵里我听到了 心跳的节奏 星星在闪烁 你会怎么说 在无声之中 你拉起了我的手 我怎么感觉 整个黑夜在震动 耳朵里我听到了 心跳的节奏 星星在闪烁 你会怎么说 你已经有他 就不应该再有我 世界的纯真 此刻为你有迷惑 我想我应该轻轻 放开你的手 我却没有力气 这么做  </description>
    </item>
    
    <item>
      <title>时光机</title>
      <link>http://www.wbprime.me/posts/2013-05-16-shiguangji/</link>
      <pubDate>Thu, 16 May 2013 20:32:58 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-shiguangji/</guid>
      <description>其实，这应该不是一首情歌。
放肆张扬的岁月，狂放不羁的风光，都已经一去不返了。
青春就是挽不回的水，用力地浪费，再用力地后悔。
浪费，再后悔，之后继续浪费。
这就是人生！
想念那如朝阳般灿烂的笑容，想念那如永恒似的深邃星空。
如果可以，我多么愿意跟你交换，用我的黑西装和白领带，换你的时光机，哆啦A梦。
时光机 词：阿信 曲：阿信 那阳光 碎裂在熟悉场景 好安静 一个人 能背多少的往事 真不轻 谁的笑 谁的温暖的手心 我着迷 伤痕好像都变成 了曾经 全剧终 看见满场空座椅 灯亮起 这故事 好像真实又像虚幻的情境 只是那 好不容易被说服 的自己 借口又顶不住懊恼的侵袭 好后悔 好伤心 想重来 行不行 再一次 我就不会走向这样的结局 好后悔 好伤心 谁把我 放回去 我愿意 付出所有来换一个时光机 对不起 独自回荡在空气 没人听 最后又是孤单 到天明 真的痛 总是来的很轻盈 没声音 从背后 慢慢缓缓抱著我 就像你 你和我 还有很多的地方 还没去 为何留我荒唐地坐在这里 好后悔 好伤心 想重来 行不行 再一次 我就不会走向这样的结局 好后悔 好伤心 谁把我 放回去 我愿意 付出所有来换一个时光机 对不起 独自回荡在空气 没人听 最后又是孤单 到天明 最后又是孤单 到天明  </description>
    </item>
    
    <item>
      <title>我心中尚未崩坏的地方</title>
      <link>http://www.wbprime.me/posts/2013-05-16-woxinzhong-shangwei-benghuai-de-difang/</link>
      <pubDate>Thu, 16 May 2013 20:29:10 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-woxinzhong-shangwei-benghuai-de-difang/</guid>
      <description>倔强之后，寻找心中尚未崩坏的地方。
离开小时候的纯真，挥别米老鼠的拥抱，终于开始了后青春期的诗。
忘不了小时候的梦，忘不了幻想穿梭外太空的翱翔。
忘不了米老鼠的孤独，忘不了以为自己跟自己，再不用人照顾的麻木。
人拒绝不了长大，真的好可惜！
五月天大声呐喊，我心中不肯腐烂的土壤，孩子一样！
伟大和伪装，灰尘或辉煌，那是一线之隔，或是一线曙光 ？
每个孤单天亮，我都一个人唱。超爱这一句，写的很决绝。
无关爱情，追逐理想，这才是我无暇的纯真，和骄傲的倔强！
我心中尚未崩坏的地方 词：阿信 曲：怪兽 醒在陌生的地方 镜头变成了刀枪 耳语也变成了真相 吉他告别了肩膀 诗人弃守了边疆 我们活在巨大片厂 幸运的孩子 爬上了殿堂 成果代价都要品尝 单纯的孩子 是否变了样 跟着游戏规则 学着成长 轰轰烈烈的排行 沸沸扬扬的颁奖 跟着节奏我常迷惘 当人心变成市场 当市场变成战场 战场埋葬多少理想 回想着理想 稀薄的希望 走着钢索我的刚强 伟大和伪装 灰尘或辉煌 那是一线之隔 或是一线曙光 每个孤单天亮 我都一个人唱 默默的让这旋律 和我心交响 就算会有一天 没人与我合唱 至少在我的心中 还有个尚未崩坏的地方 歌手追逐销售量 记者追逐点击量 没有谁比谁更善良 无论天后或天王 无论小兵或老将 曲终人散都要苍凉 期待着彩虹 所以开了窗 窗外只有灼热闪光 所谓的彩虹 不过就是光 只要心还透明 就能折射希望 每个孤单天亮 我都一个人唱 默默的让这旋律 和我心交响 就算会有一天 没人与我合唱 至少在我的心中 还有个尚未崩坏的地方 其实我们都一模一样 无名却充满了莫名渴望 一生等一次 发光 宁愿重伤也不愿悲伤 让伤痕变成了我的徽章 刺在我心脏 永远不忘 默默的让这旋律 和我心交响 至少在我的心中 自己为自己鼓掌 每个孤单天亮 我都一个人唱 默默的让这旋律 和我心交响 就算会有一天 没人与我合唱 至少在我的心中 还有个尚未崩坏的地方 孩子一样 不肯腐烂的土壤 再唱 再唱 再唱 再唱 再唱  </description>
    </item>
    
    <item>
      <title>突然好想你</title>
      <link>http://www.wbprime.me/posts/2013-05-16-turan-hao-xiangni/</link>
      <pubDate>Thu, 16 May 2013 20:25:07 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-turan-hao-xiangni/</guid>
      <description>温柔、倔强、突然好想你。
这是五月天最值得听的三首歌，我认为。
温柔在于放弃，倔强在于坚持，而突然好想你，在于坚持或者放弃之后的淡淡惘然。
放弃了会后悔，坚持下来同样也会后悔的。
若干年后，我会怎么样？
此情可待成追忆，只是当时已惘然。
陈阿信说过一句，为了那些不能放弃的，我们究竟放弃了什么啊？
还有，为了那些想要放弃的，我们究竟放弃了什么啊？
也许没有什么，也不会有什么。
只是有点，突然好想你。
突然好想你 词：阿信 曲：阿信 最怕 空气突然安静 最怕 朋友突然的关心 最怕 回忆 突然翻滚绞痛着 不平息 最怕 突然 听到你的消息 想念 如果会有声音 不愿 那是悲伤的哭泣 事到如今 终于让自己属于我自己 只剩眼泪 还骗不过自己 突然好想你 你会在哪里 过的快乐或委屈 突然好想你 突然锋利的回忆 突然模糊的眼睛 我们 像一首最美丽的歌曲 变成两部悲伤的电影 为什么你 带我走过 最难忘的旅行 然后留下 最痛的纪念品 我们 那么甜 那么美 那么相信 那么疯 那么热烈的曾经 为何我们 还是要奔向 各自的幸福和遗憾中老去 突然好想你 你会在哪里 过的快乐或委屈 突然好想你 突然锋利的回忆 突然模糊的眼睛 最怕空气突然安静 最怕朋友突然的关心 最怕回忆 突然翻滚绞痛着 不平息 最怕 突然 听到你的消息 最怕此生 已经决心自己过 没有你 却又突然 听到你的消息  </description>
    </item>
    
    <item>
      <title>诺亚方舟</title>
      <link>http://www.wbprime.me/posts/2013-05-16-nuoya-fangzhou/</link>
      <pubDate>Thu, 16 May 2013 20:20:46 +0000</pubDate>
      
      <guid>http://www.wbprime.me/posts/2013-05-16-nuoya-fangzhou/</guid>
      <description>原来幻想中的这天，会比幻想更唯美 。
如果要告别，如果今夜就要和一切告别，如果你只能打一通电话，你会拨给谁？
诺亚方舟里面，是否会有一个人为我占座呢
或者，有没有那么一个人，让我冲动到去为她占座？
世界末日，诺亚方舟。
上帝对诺亚说，你把你的妻子、儿子、儿媳都带上方舟，地上的飞禽、走兽各带一雌一雄上方舟。
原来如此，原来如彼！
诺亚方舟 词：阿信 曲：玛莎 再见 草莓甜甜圈 街角咖啡店 落下雨点 再见 黑白老照片 回忆电影院 埋进地面 再见 我们初识的那个公园 那天是谁先吻了谁 被谁遗忘的秋千 再见 那麼多名车名表名鞋 最後我们只能带走 名为回忆的花园 如果要告别 如果今夜就要和一切告别 如果你只能打一通电话 你会拨给谁 晚安 鹦鹉和孔雀 花豹和人类 望著海面 晚安 底片和唱片 沉浮在浪间 就像诗篇 晚安 自由女神漂到华尔街 我们在甲板上摸到 杜拜塔顶的塔尖 晚安 海豚跃出西藏的屋檐 原来幻想中的这天 会比幻想更唯美 还是要告别 还是放弃海拔以下的世界 你会装进什麼回忆纪念 在行李里面 终於要告别 终於没有更多的明天要追 你有什麼遗憾依然残缺 还没有完美 当彗星燃烧天边 陨石像雨点 当辐射比阳光还要炽烈 当爱变得浓烈 当每段命运更加壮烈 当永远变成一种遥远 当句点变成一种观点 当人类终於变成同类 勇敢的告别 勇敢的向过去和未来告别 告别每段血缘身分地位 聪明或愚昧 最後的告别 最後一个心愿是学会高飞 飞在不存在的高山草原 星空和蓝天 让诺亚方舟航向了 海平线 让诺亚方舟航向了 换日线 让诺亚方舟航向了 天际线 让诺亚方舟航向了 无限  </description>
    </item>
    
  </channel>
</rss>