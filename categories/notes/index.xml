<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes on wbprime</title>
    <link>http://www.wbprime.me/categories/notes/</link>
    <description>Recent content in Notes on wbprime</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 06 Feb 2018 16:26:08 +0800</lastBuildDate>
    
	<atom:link href="http://www.wbprime.me/categories/notes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Nginx Note - Config Parsing and Loading</title>
      <link>http://www.wbprime.me/posts/2018-02-06-nginx-note-config-loading/</link>
      <pubDate>Tue, 06 Feb 2018 16:26:08 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-06-nginx-note-config-loading/</guid>
      <description>转载自Nginx 配置信息的解析流程
Nginx 配置信息的解析流程 这一系列的文章还是在09年写的，存在电脑里很久了，现在贴出来。顺序也不记得了，看到那个就发那个吧，最近都会发上来。欢迎转载，但请保留链接：http://lenky.info/ ，谢谢。
Nginx 的配置文件格式是 Nginx 作者自己定义的，并没有采用像语法分析生成器LEMON那种经典的LALR（1）来描述配置信息，这样做的好处就是自由，而坏处就是对于Nginx的每一项配置信息都必须自己去解析，因此我们很容易看到Nginx模块里大量篇幅的配置信息解析代码，比如模块 ngx_http_core_module。
当然，Nginx配置文件的格式也不是随意的，它有自己的一套规范：
Nginx配置文件是由多个配置项组成的。每一个配置项都有一个项目名和对应的项目值，项目名又被称为指令（Directive），而项目值可能简单的字符串（以分号结尾），也可能是由简单字符串和多个配置项组合而成配置块的复杂结构（以大括号}结尾），因此我们可以将配置项归纳为两种：简单配置项和复杂配置项。
其项目名 &amp;ldquo;daemon&amp;rdquo; 为一个token，项目值 &amp;ldquo;off&amp;rdquo; 也是一个token。而简单配置项：
error_page 404 /404.html;
其项目值就包含有两个token，分别为 &amp;ldquo;404&amp;rdquo; 和 &amp;ldquo;/404.html&amp;rdquo; 。
对于复杂配置项：
location /www { index index.html index.htm index.php; }  其项目名 location 为一个token，项目值是一个token(&amp;ldquo;/www&amp;rdquo;)和多条简单配置项组成的复合结构。
前面将token解释为一个配置文件字符串内容中被空格、引号、括号，比如 &amp;lsquo;{&amp;rsquo; 等分割开来的字符子串，那么很明显，上面例子中的taken是被空格分割出来，事实上下面这样的配置也是正确的：
&amp;quot;daemon&amp;quot; &amp;quot;off&amp;quot;; &#39;daemon&#39; &#39;off&#39;; daemon &#39;off&#39;; &amp;quot;daemon&amp;quot; off;  当然，一般情况下没必要这样费事去加些引号，除非我们需要在token内包含空格而又不想使用转义字符(&amp;rsquo;\&amp;lsquo;)的话就可以利用引号，比如：
log_format main &#39;$remote_addr – $remote_user [$time_local] $status &#39; &#39;&amp;quot;$request&amp;quot; $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39; &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;  但是像下面这种格式就会有问题，这对于我们来说很容易理解，不多详叙：
&amp;quot;daemon &amp;quot;off&amp;quot;;  对于如此多的配置项，Nginx怎样去解析它们呢？在什么时候去解析呢？事实上，对于Nginx所有可能出现的配置项(通过项目名即指令Directive去判断)，Nginx都会提供有对应的代码去解析它，如果配置文件内出现了Nginx无法解析的配置项，那么Nginx将报错并直接退出程序。</description>
    </item>
    
    <item>
      <title>Nginx Note - Process Cycle</title>
      <link>http://www.wbprime.me/posts/2018-02-06-nginx-note-process-cycle/</link>
      <pubDate>Tue, 06 Feb 2018 16:25:54 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-06-nginx-note-process-cycle/</guid>
      <description>转载自Nginx 的执行模型
Nginx 的执行模型 这一系列的文章还是在09年写的，存在电脑里很久了，现在贴出来。顺序也不记得了，看到那个就发那个吧，最近都会发上来。欢迎转载，但请保留链接：http://lenky.info/ ，谢谢。
Nginx 的进程模型和大多数同类服务程序一样，按职责将进程分成监控进程和工作进程两类。在多进程模型下，主进程就充当监控进程，而由主进程fork出来的子进程则充当工作进程；在单进程模型下，主进程就是工作进程，此时没有监控进程。Nginx 的单进程模型比较简单，下面主要分析多进程模型。
分析 Nginx 多进程模型的入口函数为主进程的 ngx_master_process_cycle ，在该函数做完信号处理设置等之后就会调用一个名为 ngx_start_worker_processes 的函数用于 fork 产生出子进程(子进程数目通过函数调用的第二个参数指定)，子进程作为一个新的实体开始充当工作进程的角色处理客户端的服务请求；而主进程继续执行 ngx_master_process_cycle 函数，也就是作为监控进程执行主体 for 循环，这是一个死循环，直到进程终止才退出，服务进程基本都是这种写法，所以不用详述，下面先看看这个模型的图示：
图示里表现得很明朗，监控进程和工作进程各有一个无限 for 循环，以便进程持续的等待和处理自己负责的事务，直到进程退出。
监控进程的无限 for 循环内有一个关键的 sigsuspend 函数调用，该函数的调用使得监控进程的大部分时间都处于挂起状态，直到监控进程接收到信号为止，当监控进程接收到信号时，调用信号处理函数 ngx_signal_handler 进行处理。我们知道，信号处理函数一般都比较简单，故此在函数 ngx_signal_handler 内执行的动作主要也就是对一些标识字段进行设置，而更具体的处理逻辑仍直接放在 for 循环内，所以该 for 循环接下来的代码就是判断那些标识字段，比如 ngx_reap (有子进程退出？), ngx_quit 或 ngx_terminate (进行要退出或终止？), ngx_reconfigure (重新加载配置？)等是否被置位并相应的做出处理。当所有信号都处理完时又挂起在函数 sigsuspend 调用处继续等待新的信号，如此反复，构成监控进程的主要执行体。
工作进程的执行主体与监控进程类似，不过工作进程既然是工作进程，那么它的主要关注点就是与客户端之间的数据可读/可写事件，而不是信号，所以，工作进程的阻塞点是在像 select, epoll_wait 等这样的函数调用处，以等待发生数据可读/可写事件或是被新收到的信号中断。Nginx 的 IO复用模型封装得相当不错，当然也非一两句言语能够说得清楚，这将在我们的IO复用模型章节做详细介绍。
转载请保留地址：http://www.lenky.info/archives/2011/09/48 或 http://lenky.info/?p=48
备注：如无特殊说明，文章内容均出自Lenky个人的真实理解而并非存心妄自揣测来故意愚人耳目。由于个人水平有限，虽力求内容正确无误，但仍然难免出错，请勿见怪，如果可以则请留言告之，并欢迎来信讨论。另外值得说明的是，Lenky的部分文章以及部分内容参考借鉴了网络上各位网友的热心分享，特别是一些带有完全参考的文章，其后附带的链接内容也许更直接、更丰富，而我只是做了一下归纳&amp;amp;转述，在此也一并表示感谢。关于本站的所有技术文章，欢迎转载，但请遵从CC创作共享协议，而一些私人性质较强的心情随笔，建议不要转载。</description>
    </item>
    
    <item>
      <title>Nginx Note - Signal Handling</title>
      <link>http://www.wbprime.me/posts/2018-02-06-nginx-note-signal-handling/</link>
      <pubDate>Tue, 06 Feb 2018 16:25:24 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-06-nginx-note-signal-handling/</guid>
      <description>转载自Nginx 的信号管理
Nginx 的信号管理 这一系列的文章还是在09年写的，存在电脑里很久了，现在贴出来。顺序也不记得了，看到那个就发那个吧，最近都会发上来。欢迎转载，但请保留链接：http://lenky.info/ ，谢谢。
Nginx对所有发往其自身的信号进行了统一管理，这部分相关实现代码不多，而且十分清晰易懂，下面来逐步解析。
首先，Nginx对一种信号以及该信号的处理封装了一个对应的名为ngx_signal_t的结构体：
typedef struct { int signo; // 信号值 char *signame; // 信号名 char *name; // 名称，和信号名不一样，名称表明该信号的自定义作用 void (*handler)(int signo);// 信号处理函数指针 } ngx_signal_t;  接着，Nginx定义了一个ngx_signal_t类型的全局数组变量signals，该变量内包含了Nginx所有要处理的信号，如下：
ngx_signal_t signals[] = { { ngx_signal_value(NGX_RECONFIGURE_SIGNAL), //SIGHUP &amp;quot;SIG&amp;quot; ngx_value(NGX_RECONFIGURE_SIGNAL), //&amp;quot;SIGHUP&amp;quot;，这里带了引号 &amp;quot;reload&amp;quot;, //表示SIGHUP用户重新加载Nginx，也就是reload configure ngx_signal_handler }, //信号处理函数，重点 { ngx_signal_value(NGX_REOPEN_SIGNAL), &amp;quot;SIG&amp;quot; ngx_value(NGX_REOPEN_SIGNAL), &amp;quot;reopen&amp;quot;, ngx_signal_handler }, // ... { SIGPIPE, &amp;quot;SIGPIPE, SIG_IGN&amp;quot;, &amp;quot;&amp;quot;, SIG_IGN }, //忽略信号也是一种处理方式 { 0, NULL, &amp;quot;&amp;quot;, NULL } //数组结束哨兵元素，很多地方都这么用 }  ngx_signal_value、NGX_RECONFIGURE_SIGNAL、ngx_value都是一些宏，扩展开来就容易看懂，而ngx_signal_handler为一个函数指针，用来处理接收到的信号。</description>
    </item>
    
    <item>
      <title>Nginx Note - Modules Design</title>
      <link>http://www.wbprime.me/posts/2018-02-06-nginx-note-modules-design/</link>
      <pubDate>Tue, 06 Feb 2018 16:23:34 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-06-nginx-note-modules-design/</guid>
      <description>转载自Nginx 模块的统一架构
Nginx 的模块统一架构 这一系列的文章还是在09年写的，存在电脑里很久了，现在贴出来。顺序也不记得了，看到那个就发那个吧，最近都会发上来。欢迎转载，但请保留链接：http://lenky.info/ ，谢谢。
当我们configure配置 Nginx 后，将在一个名为objs的文件夹里找一个 ngx_modules.c 源文件，该文件内就包含了我们待编译生成的 Nginx 程序即将包含的模块。
Nginx 的模块可以简单点分为 core, conf, event, http 和 mail 五种类型，这从 Nginx 源码的目录结构也可以依稀看出。
封装 Nginx 模块的结构体为 ngx_module_s，定义如下：
typedef struct ngx_module_s ngx_module_t; struct ngx_module_s { //存储当前模块在同类模块中的排号。 ngx_uint_t ctx_index; //存储当前模块在所有模块中的排号。 ngx_uint_t index; //以下四字段留作备用，用于将来扩展。 ngx_uint_t spare0; ngx_uint_t spare1; ngx_uint_t spare2; ngx_uint_t spare3; //记录模块版本号 ngx_uint_t version; //指向模块特有的数据，因为指向的数据类型不确定，所以是个void类型指针。 void *ctx; //指向一个ngx_command_t类型的数组，具体后面会讲解到。 ngx_command_t *commands; //取值为NGX_CORE_MODULE、NGX_EVENT_MODULE、 //NGX_HTTP_MODULE、NGX_MAIL_MODULE、NGX_CONF_MODULE //之一，用于标识当前模块属于哪种类型。 ngx_uint_t type; //以下7个字段为函数指针，可以给它们赋上合适的回调函数，则nginx会在 //相应的时机调用它们，如果模块不关心（比如不用做初始化或销毁）则直接 //赋值为NULL即可。 //回调函数，master初始化时调用。 ngx_int_t (*init_master)(ngx_log_t *log); //回调函数，模块初始化时调用。 ngx_int_t (*init_module)(ngx_cycle_t *cycle); //回调函数，工作进程初始化时调用。 ngx_int_t (*init_process)(ngx_cycle_t *cycle); //回调函数，线程初始化时调用。 ngx_int_t (*init_thread)(ngx_cycle_t *cycle); //回调函数，线程退出时调用。 void (*exit_thread)(ngx_cycle_t *cycle); //回调函数，工作进程退出时调用。 void (*exit_process)(ngx_cycle_t *cycle); //回调函数，master退出时调用。 void (*exit_master)(ngx_cycle_t *cycle); //同之前的spare0~ spare4字段一样，下面这八个字段留作备用。 uintptr_t spare_hook0; uintptr_t spare_hook1; uintptr_t spare_hook2; uintptr_t spare_hook3; uintptr_t spare_hook4; uintptr_t spare_hook5; uintptr_t spare_hook6; uintptr_t spare_hook7; };  众览Nginx各模块对应的 ngx_module_t 结构体变量，可以看到上面介绍的各字段基本都为 NULL 或 0，而只有几个字段 ctx, commands, type，几乎每个模块都有使用，而 type 显然是必须的，那么另外两个字段 ctx, commands 有何作用？</description>
    </item>
    
    <item>
      <title>Tomcat Note</title>
      <link>http://www.wbprime.me/posts/2018-02-06-tomcat-note/</link>
      <pubDate>Tue, 06 Feb 2018 15:28:53 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-06-tomcat-note/</guid>
      <description>Notes of Tomcat 系统架构与设计模式，第 1 部分 and Tomcat 系统架构与设计模式，第 2 部分.
Tomcat Architecture --------------------------------------------- | Server | | - Service | | - Connector Coyote | | - Connector Coyote | | - Connector Coyote | | - Connector Coyote | | - ... | | - Container Catalina | | - Session | | - Jasper | | - Naming | | - Logging | | - JMX | ---------------------------------------------  Structures LifeCycle void addLifecycleListner(.</description>
    </item>
    
    <item>
      <title>Thrift Note</title>
      <link>http://www.wbprime.me/posts/2018-02-06-thrift-note/</link>
      <pubDate>Tue, 06 Feb 2018 13:22:50 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-06-thrift-note/</guid>
      <description>笔记，来自网络，来源不可考。
一个简单的 Thrift 实例 thrift 源文件 清单 1. Hello.thrift
 namespace java service.demo service Hello{ string helloString(1:string para) i32 helloInt(1:i32 para) bool helloBoolean(1:bool para) void helloVoid() string helloNull() }  HelloSerivce 实现代码 清单 2. HelloServiceImpl.java
 package service.demo; import org.apache.thrift.TException; public class HelloServiceImpl implements Hello.Iface { @Override public boolean helloBoolean(boolean para) throws TException { return para; } @Override public int helloInt(int para) throws TException { try { Thread.sleep(20000); } catch (InterruptedException e) { e.</description>
    </item>
    
    <item>
      <title>IP TCP UDP Frame Header Structure</title>
      <link>http://www.wbprime.me/posts/2018-02-06-ip-tcp-udp-frames/</link>
      <pubDate>Tue, 06 Feb 2018 13:08:22 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-06-ip-tcp-udp-frames/</guid>
      <description>IP v4 header structure:
TCP header structure:
UDP header structure:</description>
    </item>
    
    <item>
      <title>Spring Mvc Note</title>
      <link>http://www.wbprime.me/posts/2018-02-06-spring-mvc-note/</link>
      <pubDate>Tue, 06 Feb 2018 12:51:13 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-06-spring-mvc-note/</guid>
      <description>Scenario 1 In client application (application is not web application, e.g may be swing app)
private static ApplicationContext context = new ClassPathXmlApplicationContext(&amp;quot;test-client.xml&amp;quot;); context.getBean(name);  No need of web.xml. ApplicationContext as container for getting bean service. No need for web server container. In test-client.xml there can be Simple bean with no remoting, bean with remoting.
Conclusion: In Scenario 1 applicationContext and DispatcherServlet are not related.
Scenario 2 In a server application (application deployed in server e.</description>
    </item>
    
    <item>
      <title>Mybatis Note</title>
      <link>http://www.wbprime.me/posts/2018-02-06-mybatis-note/</link>
      <pubDate>Tue, 06 Feb 2018 11:40:06 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-06-mybatis-note/</guid>
      <description>&amp;ldquo;select&amp;rdquo; &amp;lt;select id=&amp;quot;selectPerson&amp;quot; parameterType=&amp;quot;int&amp;quot; parameterMap=&amp;quot;deprecated&amp;quot; resultType=&amp;quot;hashmap&amp;quot; resultMap=&amp;quot;personResultMap&amp;quot; flushCache=&amp;quot;false&amp;quot; useCache=&amp;quot;true&amp;quot; timeout=&amp;quot;10000&amp;quot; fetchSize=&amp;quot;256&amp;quot; statementType=&amp;quot;PREPARED&amp;quot; resultSetType=&amp;quot;FORWARD_ONLY&amp;quot;&amp;gt;     属性 描述     id 在命名空间中唯一的标识符，可以被用来引用这条语句。   parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。   parameterMap 这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。   resultType 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。使用 resultType 或 resultMap，但不能同时使用。   resultMap 外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。   flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。   useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。   timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。   fetchSize 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。   statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。   resultSetType FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。   databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。   resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。   resultSets 这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。    &amp;ldquo;selectKey&amp;rdquo; &amp;lt;selectKey keyProperty=&amp;quot;id&amp;quot; resultType=&amp;quot;int&amp;quot; order=&amp;quot;BEFORE&amp;quot; statementType=&amp;quot;PREPARED&amp;quot;&amp;gt;     属性 描述     keyProperty selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。   keyColumn 匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。   resultType 结果的类型。MyBatis 通常可以推算出来，但是为了更加确定写上也不会有什么问题。MyBatis 允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。   order 这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先选择主键，设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 元素 - 这和像 Oracle 的数据库相似，在插入语句内部可能有嵌入索引调用。   statementType 与前面相同，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 语句的映射类型，分别代表 PreparedStatement 和 CallableStatement 类型。    &amp;ldquo;insert&amp;rdquo; &amp;lt;insert id=&amp;quot;insertAuthor&amp;quot;&amp;gt; &amp;lt;selectKey keyProperty=&amp;quot;id&amp;quot; resultType=&amp;quot;int&amp;quot; order=&amp;quot;BEFORE&amp;quot;&amp;gt; select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.</description>
    </item>
    
    <item>
      <title>Maven Note</title>
      <link>http://www.wbprime.me/posts/2018-02-06-maven-note/</link>
      <pubDate>Tue, 06 Feb 2018 10:50:17 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-06-maven-note/</guid>
      <description>Local Repository Location conf/setting.xml
&amp;lt;settings ...&amp;gt; &amp;lt;localRepository&amp;gt;/path/to/local/repo&amp;lt;/localRepository&amp;gt; &amp;lt;/settings&amp;gt;  Use mvn help:system to confirm it.
Create New Project mvn archetype:create -DgroupId=me.wbprime.test -DartifactId=hello -DpackageName=me.wbprime.test -Dversion=1.0
Maven Dependency mvn dependency:copy-dependencies -DoutputDirectory=lib
Lifecycles Three builtin lifecycles:
 default clean site  &amp;ldquo;clean&amp;rdquo; Lifecycle    phase description     pre-clean execute processes needed prior to the actual project cleaning   clean remove all files generated by the previous build   post-clean execute processes needed to finalize the project cleaning    &amp;ldquo;site&amp;rdquo; Lifecycle    phase description     pre-site execute processes needed prior to the actual project site generation   site generate the project&amp;rsquo;s site documentation   post-site execute processes needed to finalize the site generation, and to   prepare for site deployment   site-deploy deploy the generated site documentation to the specified web server    &amp;ldquo;default&amp;rdquo; Lifecycle    phase description     validate validate the project is correct and all necessary information is available.</description>
    </item>
    
    <item>
      <title>Posix &amp; GNU Make Note</title>
      <link>http://www.wbprime.me/posts/2018-02-05-posix-make-note/</link>
      <pubDate>Mon, 05 Feb 2018 18:00:50 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-posix-make-note/</guid>
      <description>Compile Source code -&amp;gt; object file: &amp;ldquo;*.c -&amp;gt; *.o&amp;rdquo;
Link Object files -&amp;gt; executable: &amp;ldquo;*.o -&amp;gt; a.out&amp;rdquo;
makefile Rules target : prerequisites command1 command2 ... commandn   target is a target to be generated. It can be a object file, or a executable file or a label. prerequisites are dependecies of target. It is required to generate target. commandn are commands to generate target. Lines started with a &amp;lsquo;\t&amp;rsquo;  If any of prerequisites is newer than target, then make will call command1 to commandn.</description>
    </item>
    
    <item>
      <title>Access Control List</title>
      <link>http://www.wbprime.me/posts/2018-02-05-acl-note/</link>
      <pubDate>Mon, 05 Feb 2018 17:46:28 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-acl-note/</guid>
      <description>Linux ACL - Access Control List Commands  setfacl getfacl  ACL Permission - Comma separated entry. - Each entry consists of type, value and permissions, separated by colon. - type is one of `u` (user), `g` (group), `o` (other), `m` (mask) - value is the user name or uid for `u`, group name or gid for `g`, nothing for `o` - permissions is the combination of `r` (read), `w` (write) and `e` (execute) - if value is empty, then means all users/groups - if no read permission is to granted, the replace `r` with `-` for read char - if no write permission is to granted, the replace `w` with `-` for read char - if no execute permission is to granted, the replace `x` with `-` for read char - `-` in value can be ommited, if at least one of `r`, `w` and `x` is present: `r-x` =&amp;gt; `rx` - at least one `-` in value must be present if none of `r`, `w` and `x` is present: `---` =&amp;gt; `-` - e.</description>
    </item>
    
    <item>
      <title>Libevent Note</title>
      <link>http://www.wbprime.me/posts/2018-02-05-libevent-notes/</link>
      <pubDate>Mon, 05 Feb 2018 17:08:50 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-libevent-notes/</guid>
      <description>Event Context Structure event_base
Setup a Default Context #include &amp;lt;event2/event.h&amp;gt; struct event_base *event_base_new(void);  Setup a Custom Context 可以用 event_config 来自定义上下文。
struct event_config *event_config_new(void); struct event_base *event_base_new_with_config(const struct event_config *cfg); void event_config_free(struct event_config *cfg);  event_config 的自定义方法：
#include &amp;lt;event2/event.h&amp;gt; int event_config_avoid_method(struct event_config *cfg, const char *method); enum event_method_feature { EV_FEATURE_ET = 0x01, EV_FEATURE_O1 = 0x02, EV_FEATURE_FDS = 0x04, }; int event_config_require_features(struct event_config *cfg, enum event_method_feature feature); enum event_base_config_flag { EVENT_BASE_FLAG_NOLOCK = 0x01, EVENT_BASE_FLAG_IGNORE_ENV = 0x02, EVENT_BASE_FLAG_STARTUP_IOCP = 0x04, EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08, EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10, EVENT_BASE_FLAG_PRECISE_TIMER = 0x20 }; int event_config_set_flag(struct event_config *cfg, enum event_base_config_flag flag);  event_config_avoid_method() 指定不使用的后端名</description>
    </item>
    
    <item>
      <title>Jvm Memory Model</title>
      <link>http://www.wbprime.me/posts/2018-02-05-jvm-memory-model/</link>
      <pubDate>Mon, 05 Feb 2018 16:47:59 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-jvm-memory-model/</guid>
      <description>JVM 的内存模型，从网上整理的图片：</description>
    </item>
    
    <item>
      <title>Jvm GC Options</title>
      <link>http://www.wbprime.me/posts/2018-02-05-jvm-gc-options/</link>
      <pubDate>Mon, 05 Feb 2018 16:16:53 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-jvm-gc-options/</guid>
      <description>General options  -XX:+PrintFlagsFinal -XX:+PrintFlagsInitial -XX:+PrintCommandLineFlags -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions
 -XX:+ParallelRefProcEnabled
  java -server -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal java -client -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal  GC See following image first:
Young generation  &amp;ldquo;Serial&amp;rdquo; 是串行收集器，也是 -client 默认的GC收集器，可以 -XX:+UseSerialGC 来强制开启 &amp;ldquo;ParNew&amp;rdquo; 是并行收集齐，也是 -server 默认的GC收集器，可以 -XX:+UseParallelGC 来强制开启 &amp;ldquo;Parallel Scavenge&amp;rdquo; 是吞吐量优先收集器，可以通过 -XX:+UseParallelGC 来强制开启  Old generation  &amp;ldquo;CMS&amp;rdquo; 是 Concurrent Mark Sweep 收集器  执行阶段：
 CMS-initial-mark CMS-concurrent-mark CMS-concurrent-preclean CMS-remark CMS-concurrent-sweep CMS-concurrent-reset  相关参数：</description>
    </item>
    
    <item>
      <title>Jdk VS Jre</title>
      <link>http://www.wbprime.me/posts/2018-02-05-jdk-vs-jre/</link>
      <pubDate>Mon, 05 Feb 2018 15:54:01 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-jdk-vs-jre/</guid>
      <description>&lt;p&gt;JDK 与 JRE 的区别。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Note] Http Responce Status Code</title>
      <link>http://www.wbprime.me/posts/2018-02-05-http_responce_status_code/</link>
      <pubDate>Mon, 05 Feb 2018 15:45:52 +0800</pubDate>
      
      <guid>http://www.wbprime.me/posts/2018-02-05-http_responce_status_code/</guid>
      <description>&lt;p&gt;Notes about HTTP response status code.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>